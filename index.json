[
{
	"uri": "https://laravel5-book.kejyun.com/qa/qa-call-undefined-method-getcachedcompilepath/",
	"title": "Call to undefined method getCachedCompilePath()",
	"tags": [],
	"description": "",
	"content": "Call to undefined method getCachedCompilePath() 我在使用 Laravel 5.0.x 時，使用 composer update 去更新目前的套件時，跳出了這樣的訊息：\n（PS:也有人在執行 php artisan clear-compiled 出現這樣的狀況）\n PHP Fatal error: Call to undefined method Illuminate\\Foundation\\Application::getCachedCompilePath()\n 這個是因為 Laravel 5 在執行時會把整個 Framework 編譯到 storage/framework/compiled.php，若這個檔案已產生，Laravel 5 在更新套件時執行一些相關 Laravel 的功能時，會預設執行 compiled.php 檔案中的類別函式，而更新的檔案中有 getCachedCompilePath() 這個方法，所以呼叫時 Laravel 會在舊的 compiled.php 找不到這個方法\n 解決方式\n直接把 storage/framework/compiled.php 刪除即可，Laravel 5 會自動重新產生這個 compiled.php 檔案！\n參考資料  RuntimeException on fresh install  "
},
{
	"uri": "https://laravel5-book.kejyun.com/software/software-redis/",
	"title": "Redis",
	"tags": [],
	"description": "",
	"content": "Redis 管理  Redis Desktop Manager - Redis GUI management tool for Windows, Mac OS X, Ubuntu and Debian. Redis-Commander Medis - GUI Manager for Redis  "
},
{
	"uri": "https://laravel5-book.kejyun.com/hosting/nginx/hosting-install-nginx/",
	"title": "安裝 Nginx",
	"tags": [],
	"description": "",
	"content": "安裝 Nginx 更新系統套件 sudo apt-get update 安裝 Nginx 使用 Ubuntu 內建的 nginx 套件安裝，安裝完後預設的 nginx 設定檔是 /etc/nginx/sites-available/default，網站目錄會在 /usr/share/nginx/html\nsudo apt-get install nginx  設定虛擬主機 Virtualhost 設定 編輯新的 virtualhost 設定檔案\n在這裡通常我會用主機網域名稱當作他的檔案名稱，如果我有一個網域是 kejyun.dev，則我就會用 kejyun.dev 當作虛擬主機設定檔名稱\nsudo vim /etc/nginx/sites-available/kejyun.dev 設定 Listen 的 port 設定主機要使用哪一個 port 傾聽 HTTP 請求\nlisten 80; 設定服務主機名稱 設定你申請的網域名稱，nginx 會以 HTTP Request 的網域不同導向不同的 Virtualhost，所以一定要設定，以下以 kejyun.dev 為例\nserver_name kejyun.dev; 設定網站根目錄路徑 我們將 Laravel 5 的程式放在使用者 kejyun 的家目錄下，而我們必須要將網站路徑指定到 Laravel 專案下的 public 目錄下才可以正常執行 Laravel 專案\nroot \u0026quot;/home/kejyun/laravel52/public\u0026quot;; 設定 Log 路徑 設定當 Request 發生錯誤的時候，本 Virtualhost 要將 Log 存放在哪個檔案\nerror_log /var/log/nginx/kejyun.dev-error.log error; 完整虛擬主機設定 設定檔中有包括設定 php 檔案處理方式，在這邊我們可以先設定，等之後安裝完 php 7 時就可以直接使用\nserver { # 設定 Listen 的 port listen 80; # 設定服務主機名稱 server_name kejyun.dev; # 設定網站根目錄路徑 root \u0026quot;/home/kejyun/laravel52/public\u0026quot;; # 設定讀取檔案優先順序 index index.html index.htm index.php; # 設定網站編碼 charset utf-8; location / { try_files $uri $uri/ /index.php?$query_string; } location = /favicon.ico { access_log off; log_not_found off; } location = /robots.txt { access_log off; log_not_found off; } access_log off; # 設定 Log 路徑 error_log /var/log/nginx/kejyun.dev-error.log error; sendfile off; client_max_body_size 100m; # 設定 php 檔案處理方式 location ~ \\.php$ { fastcgi_split_path_info ^(.+\\.php)(/.+)$; fastcgi_pass unix:/var/run/php/php7.0-fpm.sock; fastcgi_index index.php; include fastcgi_params; fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; fastcgi_intercept_errors off; fastcgi_buffer_size 16k; fastcgi_buffers 4 16k; fastcgi_connect_timeout 300; fastcgi_send_timeout 300; fastcgi_read_timeout 300; } location ~ /\\.ht { deny all; } } 連結虛擬主機 Virtualhost 設定 Nginx 虛擬主機設定主要是讀取 /etc/nginx/sites-enabled/ 目錄下的所有檔案，如果要讓此設定檔案啟用，則必須要將原設定檔目錄 /etc/nginx/sites-available/ 的設定檔案使用軟連結連結過去\nsudo ln -s /etc/nginx/sites-available/kejyun.dev /etc/nginx/sites-enabled/kejyun.dev 重新啟動 nginx 重新啟動 nginx 以讀取新的設定\nsudo service nginx restart 這樣我們就完成了 Nginx Server 的設定了！！\n參考資料  How To Set Up nginx Virtual Hosts (Server Blocks) on Ubuntu 12.04 LTS php - How do I change the NGINX user? - Server Fault  "
},
{
	"uri": "https://laravel5-book.kejyun.com/resource/resource-official/",
	"title": "官方",
	"tags": [],
	"description": "",
	"content": "官方學習資源 Framework  Laravel - The PHP Framework For Web Artisans Lumen - PHP Micro-Framework By Laravel  最新消息  Laravel News Laravel Weekly  文件 (Document)  Welcome! - Laravel PHP Framework Laravel wiki   API  Laravel 5 API Documentation  套件清單  Packalyst :: Packages for Laravel Packagist - tag laravel Laravel Collective Arsenal :: Cartalyst  作者  Taylor Otwell | Twitter  "
},
{
	"uri": "https://laravel5-book.kejyun.com/editor/tips/",
	"title": "小技巧",
	"tags": [],
	"description": "",
	"content": "這裡會介紹一些開發 Laravel 的編輯器小技巧\n"
},
{
	"uri": "https://laravel5-book.kejyun.com/package/html/package-html-amp-readme/",
	"title": "AMP 文章",
	"tags": [],
	"description": "",
	"content": "AMP 文章  Lullabot/amp-library: Convert HTML to AMP HTML and report HTML compliance with the AMP HTML specification  "
},
{
	"uri": "https://laravel5-book.kejyun.com/package/tool/package-tool-carbon/",
	"title": "Carbon 時間套件",
	"tags": [],
	"description": "",
	"content": "Carbon 時間套件 Carbon 是一個很方便的轉換時間的工具，可以很方便地將時間進行轉換，取得我們想要的特定日期或格式\n安裝 Laravel 5 預設就會安裝 Carbon 套件，若沒有安裝的話可以透過下列的方式進行安裝：\n# 使用 Composer 下載 Carbon $ composer require nesbot/carbon \u0026lt;?php // 載入 composer autoload 檔案 require \u0026#39;vendor/autoload.php\u0026#39;; // 使用 Carbon 類別 use Carbon\\Carbon; printf(\u0026#34;Now: %s\u0026#34;, Carbon::now()); 快速切換前後日期 \u0026lt;?php use Carbon\\Carbon; $now = Carbon::now(); echo $now; // 2015-03-26 00:36:47 $today = Carbon::today(); echo $today; // 2015-03-26 00:00:00 $tomorrow = Carbon::tomorrow(\u0026#39;Europe/London\u0026#39;); echo $tomorrow; // 2015-03-27 00:00:00 $yesterday = Carbon::yesterday(); echo $yesterday; // 2015-03-25 00:00:00  建立特定日期的時間 \u0026lt;?php use Carbon\\Carbon; $timezone = \u0026#39;Asia/Taipei\u0026#39;; // 從「年月日」建立 Carbon::createFromDate($year, $month, $day, $timezone); // 從「時分秒」建立 Carbon::createFromTime($hour, $minute, $second, $timezone); // 從完整的「年月日時分秒」建立 Carbon::create($year, $month, $day, $hour, $minute, $second, $timezone); // 從指定的格式建立 Carbon::createFromFormat($format, $time, $tz); echo Carbon::createFromFormat(\u0026#39;Y-m-d H\u0026#39;, \u0026#39;1975-05-21 22\u0026#39;)-\u0026gt;toDateTimeString(); // 1975-05-21 22:00:00  // 從時間戳記建立 echo Carbon::createFromTimeStamp(-1)-\u0026gt;toDateTimeString(); // 1969-12-31 18:59:59 echo Carbon::createFromTimeStamp(-1, \u0026#39;Europe/London\u0026#39;)-\u0026gt;toDateTimeString(); // 1970-01-01 00:59:59 echo Carbon::createFromTimeStampUTC(-1)-\u0026gt;toDateTimeString(); // 1969-12-31 23:59:59 轉換日期 \u0026lt;?php use Carbon\\Carbon; // 透過文字移動日期 $knownDate = Carbon::create(2001, 5, 21, 12); // create testing date Carbon::setTestNow($knownDate); // set the mock echo new Carbon(\u0026#39;tomorrow\u0026#39;); // 2001-05-22 00:00:00 ... notice the time ! echo new Carbon(\u0026#39;yesterday\u0026#39;); // 2001-05-20 00:00:00 echo new Carbon(\u0026#39;next wednesday\u0026#39;); // 2001-05-23 00:00:00 echo new Carbon(\u0026#39;last friday\u0026#39;); // 2001-05-18 00:00:00 echo new Carbon(\u0026#39;this thursday\u0026#39;); // 2001-05-24 00:00:00  取得日期資料 \u0026lt;?php use Carbon\\Carbon; $dt = Carbon::parse(\u0026#39;2012-9-5 23:26:11.123789\u0026#39;); // 取的指定時間資料的資訊（整數） var_dump($dt-\u0026gt;year); // int(2012) var_dump($dt-\u0026gt;month); // int(9) var_dump($dt-\u0026gt;day); // int(5) var_dump($dt-\u0026gt;hour); // int(23) var_dump($dt-\u0026gt;minute); // int(26) var_dump($dt-\u0026gt;second); // int(11) var_dump($dt-\u0026gt;micro); // int(123789) var_dump($dt-\u0026gt;dayOfWeek); // int(3) var_dump($dt-\u0026gt;dayOfYear); // int(248) var_dump($dt-\u0026gt;weekOfMonth); // int(1) var_dump($dt-\u0026gt;weekOfYear); // int(36) var_dump($dt-\u0026gt;daysInMonth); // int(30) var_dump($dt-\u0026gt;timestamp); // int(1346901971) var_dump(Carbon::createFromDate(1975, 5, 21)-\u0026gt;age); // int(39) calculated vs now in the same tz var_dump($dt-\u0026gt;quarter); // int(3)  // 回傳與 UTC 差異的秒數 var_dump(Carbon::createFromTimestampUTC(0)-\u0026gt;offset); // int(0) var_dump(Carbon::createFromTimestamp(0)-\u0026gt;offset); // int(-18000)  // 回傳與 UTC 差異的時數 var_dump(Carbon::createFromTimestamp(0)-\u0026gt;offsetHours); // int(-5)  // 找出當天日否有日光節約時間 var_dump(Carbon::createFromDate(2012, 1, 1)-\u0026gt;dst); // bool(false) var_dump(Carbon::createFromDate(2012, 9, 1)-\u0026gt;dst); // bool(true)  // 判斷指定的的時區是否與預設的時區相同 var_dump(Carbon::now()-\u0026gt;local); // bool(true) var_dump(Carbon::now(\u0026#39;America/Vancouver\u0026#39;)-\u0026gt;local); // bool(false)  // 判斷是否為 UTC 的時區時間 var_dump(Carbon::now()-\u0026gt;utc); // bool(false) var_dump(Carbon::now(\u0026#39;Europe/London\u0026#39;)-\u0026gt;utc); // bool(true) var_dump(Carbon::createFromTimestampUTC(0)-\u0026gt;utc); // bool(true)  // 取得時區實例 echo get_class(Carbon::now()-\u0026gt;timezone); // DateTimeZone echo get_class(Carbon::now()-\u0026gt;tz); // DateTimeZone  // 取得時區實例的名稱 echo Carbon::now()-\u0026gt;timezoneName; // America/Toronto echo Carbon::now()-\u0026gt;tzName; // America/Toronto  設定時間資料 \u0026lt;?php use Carbon\\Carbon; $dt = Carbon::now(); $dt-\u0026gt;year = 1975; $dt-\u0026gt;month = 13; // 年份會強制 +1，且月份變為 1 月 $dt-\u0026gt;month = 5; $dt-\u0026gt;day = 21; $dt-\u0026gt;hour = 22; $dt-\u0026gt;minute = 32; $dt-\u0026gt;second = 5; $dt-\u0026gt;timestamp = 169957925; // 這個設定不會變更時區  // 透過字串或是 DateTimeZone 實例去設定時區 $dt-\u0026gt;timezone = new DateTimeZone(\u0026#39;Europe/London\u0026#39;); $dt-\u0026gt;timezone = \u0026#39;Europe/London\u0026#39;; $dt-\u0026gt;tz = \u0026#39;Europe/London\u0026#39;; // 鏈結設定方式 $dt-\u0026gt;year(1975)-\u0026gt;month(5)-\u0026gt;day(21)-\u0026gt;hour(22)-\u0026gt;minute(32)-\u0026gt;second(5)-\u0026gt;toDateTimeString(); $dt-\u0026gt;setDate(1975, 5, 21)-\u0026gt;setTime(22, 32, 5)-\u0026gt;toDateTimeString(); $dt-\u0026gt;setDateTime(1975, 5, 21, 22, 32, 5)-\u0026gt;toDateTimeString(); $dt-\u0026gt;timestamp(169957925)-\u0026gt;timezone(\u0026#39;Europe/London\u0026#39;); $dt-\u0026gt;tz(\u0026#39;America/Toronto\u0026#39;)-\u0026gt;setTimezone(\u0026#39;America/Vancouver\u0026#39;);  格式化時間資料 \u0026lt;?php use Carbon\\Carbon; $dt = Carbon::create(1975, 12, 25, 14, 15, 16); var_dump($dt-\u0026gt;toDateTimeString() == $dt); // bool(true) =\u0026gt; uses __toString() echo $dt-\u0026gt;toDateString(); // 1975-12-25 echo $dt-\u0026gt;toFormattedDateString(); // Dec 25, 1975 echo $dt-\u0026gt;toTimeString(); // 14:15:16 echo $dt-\u0026gt;toDateTimeString(); // 1975-12-25 14:15:16 echo $dt-\u0026gt;toDayDateTimeString(); // Thu, Dec 25, 1975 2:15 PM  // 仍可以使用 format() 函式 echo $dt-\u0026gt;format(\u0026#39;l jS \\\\of F Y h:i:s A\u0026#39;); // Thursday 25th of December 1975 02:15:16 PM  // 常用的時間格式 echo $dt-\u0026gt;toAtomString(); // in 1 Jahr echo $dt-\u0026gt;toCookieString(); // Thursday, 25-Dec-1975 14:15:16 EST echo $dt-\u0026gt;toIso8601String(); // 1975-12-25T14:15:16-0500 echo $dt-\u0026gt;toRfc822String(); // Thu, 25 Dec 75 14:15:16 -0500 echo $dt-\u0026gt;toRfc850String(); // Thursday, 25-Dec-75 14:15:16 EST echo $dt-\u0026gt;toRfc1036String(); // Thu, 25 Dec 75 14:15:16 -0500 echo $dt-\u0026gt;toRfc1123String(); // Thu, 25 Dec 1975 14:15:16 -0500 echo $dt-\u0026gt;toRfc2822String(); // Thu, 25 Dec 1975 14:15:16 -0500 echo $dt-\u0026gt;toRfc3339String(); // 1975-12-25T14:15:16-05:00 echo $dt-\u0026gt;toRssString(); // Thu, 25 Dec 1975 14:15:16 -0500 echo $dt-\u0026gt;toW3cString(); // 1975-12-25T14:15:16-05:00  比較時間差異 \u0026lt;?php use Carbon\\Carbon; echo Carbon::now()-\u0026gt;tzName; // America/Toronto $first = Carbon::create(2012, 9, 5, 23, 26, 11); $second = Carbon::create(2012, 9, 5, 20, 26, 11, \u0026#39;America/Vancouver\u0026#39;); echo $first-\u0026gt;toDateTimeString(); // 2012-09-05 23:26:11 echo $first-\u0026gt;tzName; // America/Toronto echo $second-\u0026gt;toDateTimeString(); // 2012-09-05 20:26:11 echo $second-\u0026gt;tzName; // America/Vancouver  // 大於、等於、小於 var_dump($first-\u0026gt;eq($second)); // bool(true) var_dump($first-\u0026gt;ne($second)); // bool(false) var_dump($first-\u0026gt;gt($second)); // bool(false) var_dump($first-\u0026gt;gte($second)); // bool(true) var_dump($first-\u0026gt;lt($second)); // bool(false) var_dump($first-\u0026gt;lte($second)); // bool(true)  $first-\u0026gt;setDateTime(2012, 1, 1, 0, 0, 0); $second-\u0026gt;setDateTime(2012, 1, 1, 0, 0, 0); // Remember tz is \u0026#39;America/Vancouver\u0026#39;  var_dump($first-\u0026gt;eq($second)); // bool(false) var_dump($first-\u0026gt;ne($second)); // bool(true) var_dump($first-\u0026gt;gt($second)); // bool(false) var_dump($first-\u0026gt;gte($second)); // bool(false) var_dump($first-\u0026gt;lt($second)); // bool(true) var_dump($first-\u0026gt;lte($second)); // bool(true)  // 時間區間比較 $first = Carbon::create(2012, 9, 5, 1); $second = Carbon::create(2012, 9, 5, 5); var_dump(Carbon::create(2012, 9, 5, 3)-\u0026gt;between($first, $second)); // bool(true) var_dump(Carbon::create(2012, 9, 5, 5)-\u0026gt;between($first, $second)); // bool(true) var_dump(Carbon::create(2012, 9, 5, 5)-\u0026gt;between($first, $second, false)); // bool(false)  // 時間大小比較 $dt1 = Carbon::create(2012, 1, 1, 0, 0, 0); $dt2 = Carbon::create(2014, 1, 30, 0, 0, 0); echo $dt1-\u0026gt;min($dt2); // 2012-01-01 00:00:00  $dt1 = Carbon::create(2012, 1, 1, 0, 0, 0); $dt2 = Carbon::create(2014, 1, 30, 0, 0, 0); echo $dt1-\u0026gt;max($dt2); // 2014-01-30 00:00:00  // now is the default param $dt1 = Carbon::create(2000, 1, 1, 0, 0, 0); echo $dt1-\u0026gt;max(); // 時間差異運算 echo Carbon::now(\u0026#39;America/Vancouver\u0026#39;)-\u0026gt;diffInSeconds(Carbon::now(\u0026#39;Europe/London\u0026#39;)); // 0  $dtOttawa = Carbon::createFromDate(2000, 1, 1, \u0026#39;America/Toronto\u0026#39;); $dtVancouver = Carbon::createFromDate(2000, 1, 1, \u0026#39;America/Vancouver\u0026#39;); echo $dtOttawa-\u0026gt;diffInHours($dtVancouver); // 3  echo $dtOttawa-\u0026gt;diffInHours($dtVancouver, false); // 3 echo $dtVancouver-\u0026gt;diffInHours($dtOttawa, false); // -3  $dt = Carbon::create(2012, 1, 31, 0); echo $dt-\u0026gt;diffInDays($dt-\u0026gt;copy()-\u0026gt;addMonth()); // 31 echo $dt-\u0026gt;diffInDays($dt-\u0026gt;copy()-\u0026gt;subMonth(), false); // -31  $dt = Carbon::create(2012, 4, 30, 0); echo $dt-\u0026gt;diffInDays($dt-\u0026gt;copy()-\u0026gt;addMonth()); // 30 echo $dt-\u0026gt;diffInDays($dt-\u0026gt;copy()-\u0026gt;addWeek()); // 7  $dt = Carbon::create(2012, 1, 1, 0); echo $dt-\u0026gt;diffInMinutes($dt-\u0026gt;copy()-\u0026gt;addSeconds(59)); // 0 echo $dt-\u0026gt;diffInMinutes($dt-\u0026gt;copy()-\u0026gt;addSeconds(60)); // 1 echo $dt-\u0026gt;diffInMinutes($dt-\u0026gt;copy()-\u0026gt;addSeconds(119)); // 1 echo $dt-\u0026gt;diffInMinutes($dt-\u0026gt;copy()-\u0026gt;addSeconds(120)); // 2  echo $dt-\u0026gt;addSeconds(120)-\u0026gt;secondsSinceMidnight(); // 120  時間狀態 \u0026lt;?php use Carbon\\Carbon; $dt = Carbon::now(); $dt-\u0026gt;isWeekday(); $dt-\u0026gt;isWeekend(); $dt-\u0026gt;isYesterday(); $dt-\u0026gt;isToday(); $dt-\u0026gt;isTomorrow(); $dt-\u0026gt;isFuture(); $dt-\u0026gt;isPast(); $dt-\u0026gt;isLeapYear(); $dt-\u0026gt;isSameDay(Carbon::now()); $born = Carbon::createFromDate(1987, 4, 23); $noCake = Carbon::createFromDate(2014, 9, 26); $yesCake = Carbon::createFromDate(2014, 4, 23); var_dump($born-\u0026gt;isBirthday($noCake)); // bool(false) var_dump($born-\u0026gt;isBirthday($yesCake)); // bool(true)  時間運算 \u0026lt;?php use Carbon\\Carbon; $dt = Carbon::create(2012, 1, 31, 0); echo $dt-\u0026gt;toDateTimeString(); // 2012-01-31 00:00:00  echo $dt-\u0026gt;addYears(5); // 2017-01-31 00:00:00 echo $dt-\u0026gt;addYear(); // 2018-01-31 00:00:00 echo $dt-\u0026gt;subYear(); // 2017-01-31 00:00:00 echo $dt-\u0026gt;subYears(5); // 2012-01-31 00:00:00  echo $dt-\u0026gt;addMonths(60); // 2017-01-31 00:00:00 echo $dt-\u0026gt;addMonth(); // 2017-03-03 00:00:00 equivalent of $dt-\u0026gt;month($dt-\u0026gt;month + 1); so it wraps echo $dt-\u0026gt;subMonth(); // 2017-02-03 00:00:00 echo $dt-\u0026gt;subMonths(60); // 2012-02-03 00:00:00  echo $dt-\u0026gt;addDays(29); // 2012-03-03 00:00:00 echo $dt-\u0026gt;addDay(); // 2012-03-04 00:00:00 echo $dt-\u0026gt;subDay(); // 2012-03-03 00:00:00 echo $dt-\u0026gt;subDays(29); // 2012-02-03 00:00:00  echo $dt-\u0026gt;addWeekdays(4); // 2012-02-09 00:00:00 echo $dt-\u0026gt;addWeekday(); // 2012-02-10 00:00:00 echo $dt-\u0026gt;subWeekday(); // 2012-02-09 00:00:00 echo $dt-\u0026gt;subWeekdays(4); // 2012-02-03 00:00:00  echo $dt-\u0026gt;addWeeks(3); // 2012-02-24 00:00:00 echo $dt-\u0026gt;addWeek(); // 2012-03-02 00:00:00 echo $dt-\u0026gt;subWeek(); // 2012-02-24 00:00:00 echo $dt-\u0026gt;subWeeks(3); // 2012-02-03 00:00:00  echo $dt-\u0026gt;addHours(24); // 2012-02-04 00:00:00 echo $dt-\u0026gt;addHour(); // 2012-02-04 01:00:00 echo $dt-\u0026gt;subHour(); // 2012-02-04 00:00:00 echo $dt-\u0026gt;subHours(24); // 2012-02-03 00:00:00  echo $dt-\u0026gt;addMinutes(61); // 2012-02-03 01:01:00 echo $dt-\u0026gt;addMinute(); // 2012-02-03 01:02:00 echo $dt-\u0026gt;subMinute(); // 2012-02-03 01:01:00 echo $dt-\u0026gt;subMinutes(61); // 2012-02-03 00:00:00  echo $dt-\u0026gt;addSeconds(61); // 2012-02-03 00:01:01 echo $dt-\u0026gt;addSecond(); // 2012-02-03 00:01:02 echo $dt-\u0026gt;subSecond(); // 2012-02-03 00:01:01 echo $dt-\u0026gt;subSeconds(61); // 2012-02-03 00:00:00  人類閱讀時間格式 \u0026lt;?php use Carbon\\Carbon; // 通常會用在留言的時間顯示 // 該時間會比較與現在的時間的差異 echo Carbon::now()-\u0026gt;subDays(5)-\u0026gt;diffForHumans(); // 5 days ago  echo Carbon::now()-\u0026gt;diffForHumans(Carbon::now()-\u0026gt;subYear()); // 1 year after  $dt = Carbon::createFromDate(2011, 8, 1); echo $dt-\u0026gt;diffForHumans($dt-\u0026gt;copy()-\u0026gt;addMonth()); // 1 month before echo $dt-\u0026gt;diffForHumans($dt-\u0026gt;copy()-\u0026gt;subMonth()); // 1 month after  echo Carbon::now()-\u0026gt;addSeconds(5)-\u0026gt;diffForHumans(); // 5 seconds from now  echo Carbon::now()-\u0026gt;subDays(24)-\u0026gt;diffForHumans(); // 3 weeks ago echo Carbon::now()-\u0026gt;subDays(24)-\u0026gt;diffForHumans(null, true); // 3 weeks 時間常數 \u0026lt;?php use Carbon\\Carbon; var_dump(Carbon::SUNDAY); // int(0) var_dump(Carbon::MONDAY); // int(1) var_dump(Carbon::TUESDAY); // int(2) var_dump(Carbon::WEDNESDAY); // int(3) var_dump(Carbon::THURSDAY); // int(4) var_dump(Carbon::FRIDAY); // int(5) var_dump(Carbon::SATURDAY); // int(6)  var_dump(Carbon::YEARS_PER_CENTURY); // int(100) var_dump(Carbon::YEARS_PER_DECADE); // int(10) var_dump(Carbon::MONTHS_PER_YEAR); // int(12) var_dump(Carbon::WEEKS_PER_YEAR); // int(52) var_dump(Carbon::DAYS_PER_WEEK); // int(7) var_dump(Carbon::HOURS_PER_DAY); // int(24) var_dump(Carbon::MINUTES_PER_HOUR); // int(60) var_dump(Carbon::SECONDS_PER_MINUTE); // int(60) 參考資料  Carbon - A simple PHP API extension for DateTime. Carbon - docs  "
},
{
	"uri": "https://laravel5-book.kejyun.com/package/api/package-api-guzzlehttp/",
	"title": "GuzzleHttp",
	"tags": [],
	"description": "",
	"content": "GuzzleHttp 設定 API 主網址 在參數設定 base_uri 即可設定主網址，之後所有的 Request 都會依照這個主網址去做請求\nuse GuzzleHttp\\Client; $client = new Client([ // Base URI is used with relative requests \u0026#39;base_uri\u0026#39; =\u0026gt; \u0026#39;http://httpbin.org\u0026#39;, ]); 設定 Timeout 時間 API 為了避免請求時間過久影響到系統存取的效能，會設定 API 存取時間，可以在參數設定至 timeout 欄位限定 API 存取時間限制\nuse GuzzleHttp\\Client; $client = new Client([ // You can set any number of default request options. \u0026#39;timeout\u0026#39; =\u0026gt; 2.14, ]);  取得回傳資料 可以使用強制轉換 $GuzzleHttpResponse-\u0026gt;getBody() 型別為 string 去取得回傳的資料\n$repsonse_content = (string) $GuzzleHttpResponse-\u0026gt;getBody(); 也可以使用 $GuzzleHttpResponse-\u0026gt;getBody()-\u0026gt;getContents() 去取得回傳的資料\n但使用這個方法去取得資料後，下次再呼叫一次後會無法取得資料，若想要下次還能夠取得資料的話，可以用上面的，可以用上面的方式去轉成字串\n$repsonse_content = $GuzzleHttpResponse-\u0026gt;getBody()-\u0026gt;getContents(); 參考資料  Quickstart — Guzzle Documentation Request and Response Messages — Guzzle Documentation php - Guzzle 6: no more json() method for responses - Stack Overflow  "
},
{
	"uri": "https://laravel5-book.kejyun.com/package/image/intervention/",
	"title": "intervention",
	"tags": [],
	"description": "",
	"content": "Intervention Image 圖片套件 安裝 $ php composer require intervention/image 設定 config/app.php\n\u0026#39;providers\u0026#39; =\u0026gt; [ Intervention\\Image\\ImageServiceProvider::class, ], \u0026#39;aliases\u0026#39; =\u0026gt; [ \u0026#39;Image\u0026#39; =\u0026gt; Intervention\\Image\\Facades\\Image::class, ], 設定檔\nphp artisan vendor:publish --provider=\u0026#34;Intervention\\Image\\ImageServiceProviderLaravel5\u0026#34; config/image.php 設定檔 return [ // 套件支援 \u0026quot;gd\u0026quot;, \u0026quot;imagick\u0026quot; 圖片處理驅動 'driver' =\u0026gt; 'gd' ];  記憶體 圖片處理非常消耗記憶體，必須確保 PHP 能夠有權限使用較多的記憶體資源，從 3000 x 2000 像素的圖片 resize 到 300 x 200 像素，可能需要大約 32 MB 的記憶體。\n memory_limit upload_max_filesize  URL 圖片自動操作 Intervention 可以讓你自訂義對指定資料夾的圖片做 Filter 的功能，在 config/imagecache.php 設定檔中，可以設定虛擬的 route\n// config/imagecache.php return [ \u0026#39;route\u0026#39; =\u0026gt; \u0026#39;img\u0026#39;, ]; 在 path 可以指定虛擬的 route 要存取哪些資料夾的圖片資料，設定完成後，所有透過 http://yourhost.com/img/ 網址存取的圖片都會到 public/upload 及 public/images 資料夾去做圖片的存取。\n// config/imagecache.php return [ \u0026#39;paths\u0026#39; =\u0026gt; array( public_path(\u0026#39;upload\u0026#39;), public_path(\u0026#39;images\u0026#39;) ), ]; 在 templates 中可以設定圖片的 filter 種類\nreturn [ \u0026#39;templates\u0026#39; =\u0026gt; array( \u0026#39;small\u0026#39; =\u0026gt; \u0026#39;Intervention\\Image\\Templates\\Small\u0026#39;, \u0026#39;medium\u0026#39; =\u0026gt; \u0026#39;Intervention\\Image\\Templates\\Medium\u0026#39;, \u0026#39;large\u0026#39; =\u0026gt; \u0026#39;Intervention\\Image\\Templates\\Large\u0026#39;, ), ];  可以看到 Intervention\\Image\\Templates\\Small 檔案中有 Small filter 的程式，會自動將圖片 fit 到 120x90 的大小\n\u0026lt;?php namespace Intervention\\Image\\Templates; use Intervention\\Image\\Image; use Intervention\\Image\\Filters\\FilterInterface; class Small implements FilterInterface { public function applyFilter(Image $image) { return $image-\u0026gt;fit(120, 90); } } 網址的格式是\nhttp://yourhost.com/{route-name}/{template-name}/{file-name} 所以當網址輸入 http://yourhost.com/img/small/xxx.jpg 就會自動去將 public/upload 及 public/images 資料夾下的 xxx.jpg 去做 Small filter 處理，並存在快取中，快取時間可以在 lifetime 中設定。\n// config/imagecache.php return [ \u0026#39;lifetime\u0026#39; =\u0026gt; 43200, ] Intervention 有提供 original 及 download 這兩個 filter，如果用 http://yourhost.com/img/original/xxx.jpg 可以存取到原始圖片，而用 http://yourhost.com/img/download/xxx.jpg 則可以下載圖片，這是 Intervention 提供的 filter。\n 建立圖片方式 // create a new image resource from file $img = Image::make(\u0026#39;public/foo.jpg\u0026#39;); // or create a new image resource from binary data $img = Image::make(file_get_contents(\u0026#39;public/foo.jpg\u0026#39;)); // create a new image from gd resource $img = Image::make(imagecreatefromjpeg(\u0026#39;public/foo.jpg\u0026#39;)); // create a new image directly from an url $img = Image::make(\u0026#39;http://example.com/example.jpg\u0026#39;); // create a new image directly from Laravel file upload $img = Image::make(Input::file(\u0026#39;photo\u0026#39;)); 參考資料  Intervention Image - Introduction Intervention Image - Url  "
},
{
	"uri": "https://laravel5-book.kejyun.com/package/mail/package-mail-mailchimp/",
	"title": "Mailchimp",
	"tags": [],
	"description": "",
	"content": "Laravel Mailchimp 取得 API Key 登入 MailChimp 後，在右上方帳號選單中，選擇 Account\n在帳號選單頁面中，選擇 Extras 選單中的 API keys\n在 API keys 頁面中，點選 Create A Key，建立 API Key\n點選完後就可以看到你的 API Key 了\n 取得 API 網址前綴 在 API 的網址可以看到前方有 \u0026lt;dc\u0026gt; 的字樣，\u0026lt;dc\u0026gt; 是要看自己所屬的服務是哪一個區域，可以登入 MailChimp 後從網址那邊取得如下\nhttps://\u0026lt;dc\u0026gt;.api.mailchimp.com/3.0 可以看到網址是 https://us19.admin.mailchimp.com/lists/，所以 API Key 的 \u0026lt;dc\u0026gt; 就是 us19\n取得清單編號 List ID Mailchimp 可以管理許多不同的郵件清單，為了管理清單資料，需要有清單編號（List ID），到清單頁點選您要管理的清單\n在清單頁從 Settings 選單中點選 List name and defaults 選項\n在 List name and defaults 頁面中可以看到清單編號（List ID）在右上方\n 安裝套件 Laravel : ~5.1.0|~5.2.0|~5.3.0|~5.4.0\n1. Composer 下載安裝\ncomposer require \u0026#34;spatie/laravel-newsletter:3.7.*\u0026#34; 2. 設定 app.php\n// config/app.php return [ \u0026#39;providers\u0026#39; =\u0026gt; [ ... Spatie\\Newsletter\\NewsletterServiceProvider::class, ... ], // config/app.php \u0026#39;aliases\u0026#39; =\u0026gt; [ .. \u0026#39;Newsletter\u0026#39; =\u0026gt; Spatie\\Newsletter\\NewsletterFacade::class, ], ] 3. 發佈產生設定檔\nphp artisan vendor:publish --provider=\u0026#34;Spatie\\Newsletter\\NewsletterServiceProvider\u0026#34; 4. 設定 Mailchimp API Key \u0026amp; List Key\n在 config/laravel-newsletter.php 設定檔中可以設定 API Key \u0026amp; List Key\nreturn [ \u0026#39;apiKey\u0026#39; =\u0026gt; env(\u0026#39;MAILCHIMP_APIKEY\u0026#39;), \u0026#39;lists\u0026#39; =\u0026gt; [ \u0026#39;subscribers\u0026#39; =\u0026gt; [ \u0026#39;id\u0026#39; =\u0026gt; env(\u0026#39;MAILCHIMP_LIST_ID\u0026#39;), ], ], ]; 可以到 .env 檔案中加入剛剛取得的 API Key \u0026amp; List Key\n# .env MAILCHIMP_APIKEY=xxxxxxx MAILCHIMP_LIST_ID=yyyyyyy  是否有此 email // 回傳 true or false $is_member_exist = Newsletter::hasMember($email); 訂閱 $SubscribeMember = Newsletter::subscribe($email); 訂閱後，在回傳資料的 status 欄位會看到狀態為 subscribed，曾經訂閱過的使用者無法再使用 subscribe() 去做訂閱，需要用 subscribeOrUpdate() 方法去做訂閱的更新\n$SubscribeMember = [ \u0026#34;id\u0026#34; =\u0026gt; \u0026#34;b08f6000ef0269370bc6d664a0bc42ae\u0026#34;, \u0026#34;email_address\u0026#34; =\u0026gt; \u0026#34;kj@kejyun.com\u0026#34;, \u0026#34;unique_email_id\u0026#34; =\u0026gt; \u0026#34;0c5596db5d\u0026#34;, \u0026#34;email_type\u0026#34; =\u0026gt; \u0026#34;html\u0026#34;, \u0026#34;status\u0026#34; =\u0026gt; \u0026#34;subscribed\u0026#34;, \u0026#34;merge_fields\u0026#34; =\u0026gt; [ \u0026#34;FNAME\u0026#34; =\u0026gt; \u0026#34;\u0026#34;, \u0026#34;LNAME\u0026#34; =\u0026gt; \u0026#34;\u0026#34;, \u0026#34;ADDRESS\u0026#34; =\u0026gt; \u0026#34;\u0026#34;, \u0026#34;PHONE\u0026#34; =\u0026gt; \u0026#34;\u0026#34;, \u0026#34;BIRTHDAY\u0026#34; =\u0026gt; \u0026#34;\u0026#34;, ], \u0026#34;stats\u0026#34; =\u0026gt; [ \u0026#34;avg_open_rate\u0026#34; =\u0026gt; 0, \u0026#34;avg_click_rate\u0026#34; =\u0026gt; 0, ], \u0026#34;ip_signup\u0026#34; =\u0026gt; \u0026#34;\u0026#34;, \u0026#34;timestamp_signup\u0026#34; =\u0026gt; \u0026#34;\u0026#34;, \u0026#34;ip_opt\u0026#34; =\u0026gt; \u0026#34;1.1.1.1\u0026#34;, \u0026#34;timestamp_opt\u0026#34; =\u0026gt; \u0026#34;2018-08-24T08:30:44+00:00\u0026#34;, \u0026#34;member_rating\u0026#34; =\u0026gt; 2, \u0026#34;last_changed\u0026#34; =\u0026gt; \u0026#34;2018-08-24T08:30:44+00:00\u0026#34;, \u0026#34;language\u0026#34; =\u0026gt; \u0026#34;\u0026#34;, \u0026#34;vip\u0026#34; =\u0026gt; false, \u0026#34;email_client\u0026#34; =\u0026gt; \u0026#34;\u0026#34;, \u0026#34;location\u0026#34; =\u0026gt; [ \u0026#34;latitude\u0026#34; =\u0026gt; 0, \u0026#34;longitude\u0026#34; =\u0026gt; 0, \u0026#34;gmtoff\u0026#34; =\u0026gt; 0, \u0026#34;dstoff\u0026#34; =\u0026gt; 0, \u0026#34;country_code\u0026#34; =\u0026gt; \u0026#34;\u0026#34;, \u0026#34;timezone\u0026#34; =\u0026gt; \u0026#34;\u0026#34;, ], \u0026#34;tags_count\u0026#34; =\u0026gt; 0, \u0026#34;tags\u0026#34; =\u0026gt; [], \u0026#34;list_id\u0026#34; =\u0026gt; \u0026#34;9fe4ab289a\u0026#34;, ];  取得會員資料 $Member = Newsletter::getMember($email); $Member = [ \u0026#34;id\u0026#34; =\u0026gt; \u0026#34;4bd1ccfqwdqwbtrbrtc8e064b7e037b5826\u0026#34;, \u0026#34;email_address\u0026#34; =\u0026gt; \u0026#34;kj@kejyun.com\u0026#34;, \u0026#34;unique_email_id\u0026#34; =\u0026gt; \u0026#34;20bb281925\u0026#34;, \u0026#34;email_type\u0026#34; =\u0026gt; \u0026#34;html\u0026#34;, \u0026#34;status\u0026#34; =\u0026gt; \u0026#34;subscribed\u0026#34;, \u0026#34;merge_fields\u0026#34; =\u0026gt; [ \u0026#34;FNAME\u0026#34; =\u0026gt; \u0026#34;KJ\u0026#34;, \u0026#34;LNAME\u0026#34; =\u0026gt; \u0026#34;Proj\u0026#34;, \u0026#34;ADDRESS\u0026#34; =\u0026gt; [ \u0026#34;addr1\u0026#34; =\u0026gt; \u0026#34;\u0026#34;, \u0026#34;addr2\u0026#34; =\u0026gt; \u0026#34;\u0026#34;, \u0026#34;city\u0026#34; =\u0026gt; \u0026#34;\u0026#34;, \u0026#34;state\u0026#34; =\u0026gt; \u0026#34;\u0026#34;, \u0026#34;zip\u0026#34; =\u0026gt; \u0026#34;\u0026#34;, \u0026#34;country\u0026#34; =\u0026gt; \u0026#34;US\u0026#34;, ], \u0026#34;PHONE\u0026#34; =\u0026gt; \u0026#34;\u0026#34;, \u0026#34;BIRTHDAY\u0026#34; =\u0026gt; \u0026#34;\u0026#34;, ], \u0026#34;stats\u0026#34; =\u0026gt; [ \u0026#34;avg_open_rate\u0026#34; =\u0026gt; 0, \u0026#34;avg_click_rate\u0026#34; =\u0026gt; 0, ], \u0026#34;ip_signup\u0026#34; =\u0026gt; \u0026#34;\u0026#34;, \u0026#34;timestamp_signup\u0026#34; =\u0026gt; \u0026#34;\u0026#34;, \u0026#34;ip_opt\u0026#34; =\u0026gt; \u0026#34;1.1.1.1\u0026#34;, \u0026#34;timestamp_opt\u0026#34; =\u0026gt; \u0026#34;2018-08-24T07:16:30+00:00\u0026#34;, \u0026#34;member_rating\u0026#34; =\u0026gt; 2, \u0026#34;last_changed\u0026#34; =\u0026gt; \u0026#34;2018-08-24T07:16:30+00:00\u0026#34;, \u0026#34;language\u0026#34; =\u0026gt; \u0026#34;en\u0026#34;, \u0026#34;vip\u0026#34; =\u0026gt; false, \u0026#34;email_client\u0026#34; =\u0026gt; \u0026#34;\u0026#34;, \u0026#34;location\u0026#34; =\u0026gt; [ \u0026#34;latitude\u0026#34; =\u0026gt; 0, \u0026#34;longitude\u0026#34; =\u0026gt; 0, \u0026#34;gmtoff\u0026#34; =\u0026gt; 0, \u0026#34;dstoff\u0026#34; =\u0026gt; 0, \u0026#34;country_code\u0026#34; =\u0026gt; \u0026#34;\u0026#34;, \u0026#34;timezone\u0026#34; =\u0026gt; \u0026#34;\u0026#34;, ], \u0026#34;tags_count\u0026#34; =\u0026gt; 0, \u0026#34;tags\u0026#34; =\u0026gt; [], \u0026#34;list_id\u0026#34; =\u0026gt; \u0026#34;9fe4ab289a\u0026#34;, ];  解除訂閱 Newsletter::unsubscribe($email); 解除訂閱後，在回傳資料的 status 欄位會看到狀態為 unsubscribed，unsubscribe_reason 則會看到為 N/A (Unsubscribed by admin)\n$UnSubscribeMember = [ \u0026#34;id\u0026#34; =\u0026gt; \u0026#34;b08f6000ef0269370bc6d664a0bc42ae\u0026#34;, \u0026#34;email_address\u0026#34; =\u0026gt; \u0026#34;kj@kejyun.com\u0026#34;, \u0026#34;unique_email_id\u0026#34; =\u0026gt; \u0026#34;0c5596db5d\u0026#34;, \u0026#34;email_type\u0026#34; =\u0026gt; \u0026#34;html\u0026#34;, \u0026#34;status\u0026#34; =\u0026gt; \u0026#34;unsubscribed\u0026#34;, \u0026#34;unsubscribe_reason\u0026#34; =\u0026gt; \u0026#34;N/A (Unsubscribed by admin)\u0026#34;, \u0026#34;merge_fields\u0026#34; =\u0026gt; [ \u0026#34;FNAME\u0026#34; =\u0026gt; \u0026#34;\u0026#34;, \u0026#34;LNAME\u0026#34; =\u0026gt; \u0026#34;\u0026#34;, \u0026#34;ADDRESS\u0026#34; =\u0026gt; \u0026#34;\u0026#34;, \u0026#34;PHONE\u0026#34; =\u0026gt; \u0026#34;\u0026#34;, \u0026#34;BIRTHDAY\u0026#34; =\u0026gt; \u0026#34;\u0026#34;, ], \u0026#34;stats\u0026#34; =\u0026gt; [ \u0026#34;avg_open_rate\u0026#34; =\u0026gt; 0, \u0026#34;avg_click_rate\u0026#34; =\u0026gt; 0, ], \u0026#34;ip_signup\u0026#34; =\u0026gt; \u0026#34;\u0026#34;, \u0026#34;timestamp_signup\u0026#34; =\u0026gt; \u0026#34;\u0026#34;, \u0026#34;ip_opt\u0026#34; =\u0026gt; \u0026#34;1.1.1.1\u0026#34;, \u0026#34;timestamp_opt\u0026#34; =\u0026gt; \u0026#34;2018-08-24T08:30:44+00:00\u0026#34;, \u0026#34;member_rating\u0026#34; =\u0026gt; 2, \u0026#34;last_changed\u0026#34; =\u0026gt; \u0026#34;2018-08-24T08:57:21+00:00\u0026#34;, \u0026#34;language\u0026#34; =\u0026gt; \u0026#34;\u0026#34;, \u0026#34;vip\u0026#34; =\u0026gt; false, \u0026#34;email_client\u0026#34; =\u0026gt; \u0026#34;\u0026#34;, \u0026#34;location\u0026#34; =\u0026gt; [ \u0026#34;latitude\u0026#34; =\u0026gt; 0, \u0026#34;longitude\u0026#34; =\u0026gt; 0, \u0026#34;gmtoff\u0026#34; =\u0026gt; 0, \u0026#34;dstoff\u0026#34; =\u0026gt; 0, \u0026#34;country_code\u0026#34; =\u0026gt; \u0026#34;\u0026#34;, \u0026#34;timezone\u0026#34; =\u0026gt; \u0026#34;\u0026#34;, ], \u0026#34;tags_count\u0026#34; =\u0026gt; 0, \u0026#34;tags\u0026#34; =\u0026gt; [], \u0026#34;list_id\u0026#34; =\u0026gt; \u0026#34;9fe4ab289a\u0026#34;, ];  訂閱或更新使用者資料 $subscribe_member_info = [ \u0026#39;FNAME\u0026#39; =\u0026gt; \u0026#39;KJ\u0026#39;, \u0026#39;LNAME\u0026#39; =\u0026gt; \u0026#39;Hong\u0026#39;, \u0026#39;PHONE\u0026#39; =\u0026gt; \u0026#39;0900000000\u0026#39;, ]; $SubscribeMember = Newsletter::subscribeOrUpdate($email, subscribe_member_info); 訂閱後，在回傳資料的 status 欄位會看到狀態為 subscribed，也可以看到使用者的個人資料更新了\n$SubscribeMember = [ \u0026#34;id\u0026#34; =\u0026gt; \u0026#34;b08f6000ef0269370bc6d664a0bc42ae\u0026#34;, \u0026#34;email_address\u0026#34; =\u0026gt; \u0026#34;kj@kejyun.com\u0026#34;, \u0026#34;unique_email_id\u0026#34; =\u0026gt; \u0026#34;0c5596db5d\u0026#34;, \u0026#34;email_type\u0026#34; =\u0026gt; \u0026#34;html\u0026#34;, \u0026#34;status\u0026#34; =\u0026gt; \u0026#34;subscribed\u0026#34;, \u0026#34;merge_fields\u0026#34; =\u0026gt; [ \u0026#34;FNAME\u0026#34; =\u0026gt; \u0026#34;KJ\u0026#34;, \u0026#34;LNAME\u0026#34; =\u0026gt; \u0026#34;Hong\u0026#34;, \u0026#34;ADDRESS\u0026#34; =\u0026gt; \u0026#34;\u0026#34;, \u0026#34;PHONE\u0026#34; =\u0026gt; \u0026#34;0900000000\u0026#34;, \u0026#34;BIRTHDAY\u0026#34; =\u0026gt; \u0026#34;\u0026#34;, ], \u0026#34;stats\u0026#34; =\u0026gt; [ \u0026#34;avg_open_rate\u0026#34; =\u0026gt; 0, \u0026#34;avg_click_rate\u0026#34; =\u0026gt; 0, ], \u0026#34;ip_signup\u0026#34; =\u0026gt; \u0026#34;\u0026#34;, \u0026#34;timestamp_signup\u0026#34; =\u0026gt; \u0026#34;\u0026#34;, \u0026#34;ip_opt\u0026#34; =\u0026gt; \u0026#34;1.1.1.1\u0026#34;, \u0026#34;timestamp_opt\u0026#34; =\u0026gt; \u0026#34;2018-08-24T08:30:44+00:00\u0026#34;, \u0026#34;member_rating\u0026#34; =\u0026gt; 2, \u0026#34;last_changed\u0026#34; =\u0026gt; \u0026#34;2018-08-24T09:11:58+00:00\u0026#34;, \u0026#34;language\u0026#34; =\u0026gt; \u0026#34;\u0026#34;, \u0026#34;vip\u0026#34; =\u0026gt; false, \u0026#34;email_client\u0026#34; =\u0026gt; \u0026#34;\u0026#34;, \u0026#34;location\u0026#34; =\u0026gt; [ \u0026#34;latitude\u0026#34; =\u0026gt; 0, \u0026#34;longitude\u0026#34; =\u0026gt; 0, \u0026#34;gmtoff\u0026#34; =\u0026gt; 0, \u0026#34;dstoff\u0026#34; =\u0026gt; 0, \u0026#34;country_code\u0026#34; =\u0026gt; \u0026#34;\u0026#34;, \u0026#34;timezone\u0026#34; =\u0026gt; \u0026#34;\u0026#34;, ], \u0026#34;tags_count\u0026#34; =\u0026gt; 0, \u0026#34;tags\u0026#34; =\u0026gt; [], \u0026#34;list_id\u0026#34; =\u0026gt; \u0026#34;9fe4ab289a\u0026#34;, ]; 更新使用者 Email $UpdateMemberEmail = Newsletter::updateEmailAddress($old_email, $new_email); 若新的 email 已存在，則會無法更新\n$UpdateMemberEmail = [ \u0026#34;id\u0026#34; =\u0026gt; \u0026#34;11d3e8047829c996b4602f92bdfdc2f9\u0026#34;, \u0026#34;email_address\u0026#34; =\u0026gt; \u0026#34;kj.new@kejyun.com\u0026#34;, \u0026#34;unique_email_id\u0026#34; =\u0026gt; \u0026#34;21b5f58334\u0026#34;, \u0026#34;email_type\u0026#34; =\u0026gt; \u0026#34;html\u0026#34;, \u0026#34;status\u0026#34; =\u0026gt; \u0026#34;subscribed\u0026#34;, \u0026#34;merge_fields\u0026#34; =\u0026gt; [ \u0026#34;FNAME\u0026#34; =\u0026gt; \u0026#34;KJ\u0026#34;, \u0026#34;LNAME\u0026#34; =\u0026gt; \u0026#34;Hong\u0026#34;, \u0026#34;ADDRESS\u0026#34; =\u0026gt; \u0026#34;\u0026#34;, \u0026#34;PHONE\u0026#34; =\u0026gt; \u0026#34;0900000000\u0026#34;, \u0026#34;BIRTHDAY\u0026#34; =\u0026gt; \u0026#34;\u0026#34;, ], \u0026#34;stats\u0026#34; =\u0026gt; [ \u0026#34;avg_open_rate\u0026#34; =\u0026gt; 0, \u0026#34;avg_click_rate\u0026#34; =\u0026gt; 0, ], \u0026#34;ip_signup\u0026#34; =\u0026gt; \u0026#34;\u0026#34;, \u0026#34;timestamp_signup\u0026#34; =\u0026gt; \u0026#34;\u0026#34;, \u0026#34;ip_opt\u0026#34; =\u0026gt; \u0026#34;1.1.1.1\u0026#34;, \u0026#34;timestamp_opt\u0026#34; =\u0026gt; \u0026#34;2018-08-24T08:30:44+00:00\u0026#34;, \u0026#34;member_rating\u0026#34; =\u0026gt; 2, \u0026#34;last_changed\u0026#34; =\u0026gt; \u0026#34;2018-08-24T09:46:24+00:00\u0026#34;, \u0026#34;language\u0026#34; =\u0026gt; \u0026#34;\u0026#34;, \u0026#34;vip\u0026#34; =\u0026gt; false, \u0026#34;email_client\u0026#34; =\u0026gt; \u0026#34;\u0026#34;, \u0026#34;location\u0026#34; =\u0026gt; [ \u0026#34;latitude\u0026#34; =\u0026gt; 0, \u0026#34;longitude\u0026#34; =\u0026gt; 0, \u0026#34;gmtoff\u0026#34; =\u0026gt; 0, \u0026#34;dstoff\u0026#34; =\u0026gt; 0, \u0026#34;country_code\u0026#34; =\u0026gt; \u0026#34;\u0026#34;, \u0026#34;timezone\u0026#34; =\u0026gt; \u0026#34;\u0026#34;, ], \u0026#34;tags_count\u0026#34; =\u0026gt; 0, \u0026#34;tags\u0026#34; =\u0026gt; [], \u0026#34;list_id\u0026#34; =\u0026gt; \u0026#34;9fe4ab289a\u0026#34;, ];  刪除使用者 email  刪除使用者 email，是指整個 email 從此消失，再也找不回來了\n $delete_status = Newsletter::delete($email); 刪除成功會回傳 true，刪除失敗則會將失敗的原因回傳\n// 刪除失敗 $delete_status = [ \u0026#34;type\u0026#34; =\u0026gt; \u0026#34;http://developer.mailchimp.com/documentation/mailchimp/guides/error-glossary/\u0026#34;, \u0026#34;title\u0026#34; =\u0026gt; \u0026#34;Resource Not Found\u0026#34;, \u0026#34;status\u0026#34; =\u0026gt; 404, \u0026#34;detail\u0026#34; =\u0026gt; \u0026#34;The requested resource could not be found.\u0026#34;, \u0026#34;instance\u0026#34; =\u0026gt; \u0026#34;bb6db1ab-97e6-4da7-9db3-f97b5588ce3e\u0026#34;, ]; 取得使用者近期活動資訊 $MemberActivity = Newsletter::getMemberActivity($email); $MemberActivity = [ \u0026#34;activity\u0026#34; =\u0026gt; [ 0 =\u0026gt; [ \u0026#34;action\u0026#34; =\u0026gt; \u0026#34;unsub\u0026#34;, \u0026#34;timestamp\u0026#34; =\u0026gt; \u0026#34;2018-08-24T08:57:21+00:00\u0026#34;, \u0026#34;type\u0026#34; =\u0026gt; \u0026#34;A\u0026#34;, \u0026#34;campaign_id\u0026#34; =\u0026gt; \u0026#34;\u0026#34;, ], ], \u0026#34;email_id\u0026#34; =\u0026gt; \u0026#34;b08f6000ef0269370bc6d664a0bc42ae\u0026#34;, \u0026#34;list_id\u0026#34; =\u0026gt; \u0026#34;9fe4ab289a\u0026#34;, \u0026#34;total_items\u0026#34; =\u0026gt; 1, ]; 參考資料  Developer | MailChimp About API Keys | MailChimp (MailChimp API Key)[https://us10.admin.mailchimp.com/account/api-key-popup/] spatie/laravel-newsletter: Manage newsletters in Laravel Laravel 5.1~5.4：spatie/laravel-newsletter: Manage newsletters in Laravel ★ Easily integrate MailChimp in Laravel 5 - Freek Van der Herten\u0026rsquo;s blog on PHP and Laravel Guide On Laravel 5 and Mailchimp Newsletter- Helpful In Laravel Services  "
},
{
	"uri": "https://laravel5-book.kejyun.com/package/auth/oauth/",
	"title": "OAuth2",
	"tags": [],
	"description": "",
	"content": "OAuth2 認證套件 使用套件  套件名稱：lucadegasperi/oauth2-server-laravel\n  套件版本：5.0.3\n 名詞解釋    名詞 描述     Access token 存取標記，用於存取受保護資源的標記   Authorization code 授權碼，使用者授權 Client 的中介標記，Client 可以透過此授權碼去取得 Access token   Authorization server 授權伺服器，使用者授權 Client 後，用於發送 Access token 的伺服器   Client 被授權客戶，存取屬於使用者的受保護資源的應用程式（Application）， 像是 Server、手機或其他裝置   Grant 授權方法，存取 Access token 的方法   Resource server 資源伺服器，屬於使用者的受保護資源（像是文章、照片、個人隱私資料\u0026hellip;等等）   Scope 資源存取範圍，Access token 允許存取的權限     ref： lucadegasperi/oauth2-server-laravel - Terminology\n 安裝 使用 composer 安裝套件 在 composer.json 加入 \u0026quot;lucadegasperi/oauth2-server-laravel\u0026quot;: \u0026quot;5.0.*\u0026quot; 並執行 composer update 安裝套件\n/*composer.json*/ \u0026#34;require\u0026#34;: { \u0026#34;lucadegasperi/oauth2-server-laravel\u0026#34;: \u0026#34;5.0.*\u0026#34; } $ composer update 設定套件 開啟config/app.php檔案，並將系列套件資訊加入 providers 與 aliases\n\u0026#39;providers\u0026#39; =\u0026gt; [ LucaDegasperi\\OAuth2Server\\Storage\\FluentStorageServiceProvider::class, LucaDegasperi\\OAuth2Server\\OAuth2ServerServiceProvider::class, ], \u0026#39;aliases\u0026#39;=\u0026gt;[ \u0026#39;Authorizer\u0026#39; =\u0026gt; LucaDegasperi\\OAuth2Server\\Facades\\Authorizer::class, ] 設定 middleware 開啟 app/Http/Kernel.php，將系列設定加入 $middleware 與 $routeMiddleware 中\n並將原本在 $middleware 的 \\App\\Http\\Middleware\\VerifyCsrfToken::class 移至 $routeMiddleware，並命名為 csrf\n 注意，原本 Laravel 會針對每個非 Get 的 Request 做 CSRF 的過濾，因為 OAuth 已經取得授權 Access token，不需要 CSRF 驗證，所以如果你需要做 CSRF 驗證的話，您可以在 Route 加入 csrf 的 middleware 去做驗證\n \u0026lt;?php class Kernel extends HttpKernel { protected $middleware = [ \\LucaDegasperi\\OAuth2Server\\Middleware\\OAuthExceptionHandlerMiddleware::class ]; protected $routeMiddleware = [ // CSRF  \u0026#39;csrf\u0026#39; =\u0026gt; \\App\\Http\\Middleware\\VerifyCsrfToken::class, // OAuth2  \u0026#39;oauth\u0026#39; =\u0026gt; \\LucaDegasperi\\OAuth2Server\\Middleware\\OAuthMiddleware::class, \u0026#39;oauth-user\u0026#39; =\u0026gt; \\LucaDegasperi\\OAuth2Server\\Middleware\\OAuthUserOwnerMiddleware::class, \u0026#39;oauth-client\u0026#39; =\u0026gt; \\LucaDegasperi\\OAuth2Server\\Middleware\\OAuthClientOwnerMiddleware::class, \u0026#39;check-authorization-params\u0026#39; =\u0026gt; \\LucaDegasperi\\OAuth2Server\\Middleware\\CheckAuthCodeRequestMiddleware::class ]; } 產生套件設定及 Migration 執行 php artisan vendor:publish 複製套件的 migration 與 config/oauth.php 設定檔到你應用程式的目錄，並執行 migration 建立 OAuth2 需要的資料表\n$ php artisan vendor:publish $ php artisan migrate 設定檔名詞解釋    參數名稱 說明 資料類型 預設值     grant_types 授權類型設定 Array 無   token_type token 類型 String League\\OAuth2\\Server\\ TokenType\\Bearer   state_param 狀態參數，如果為 true 的話，在請求 Access token 時候則必須帶入 \u0026amp;state=隨機字串，在透過授權後 Authorization server 會回覆相同的 state 字串 Boolean false   scope_param 存取權限參數，若為 true，則在每一次的 Request 都需要帶入該資源的存取參數 Boolean false   scope_delimiter 存取權限區隔字串，在不同的存取權限使用什麼字元去區隔（scope1,scope2） String ,   default_scope 預設存取權限 String null   access_token_ttl Access token 存活時間（單位：秒） Integer 3600   limit_clients_to_grants 是否限制 Client 允許使用的 Grant Type，可以在 oauth_client_grants 資料表設定 Boolean false   limit_clients_to_scopes 限制 Client 允許的 Scope，可以在 oauth_client_scopes 資料表設定 Boolean false   limit_scopes_to_grants 限制 Scope 允許在哪個 Grant Type 存取，可以在 oauth_grant_scopes 資料表設定 Boolean false   http_headers_only 是否只使用 Header 做 Access token 的檢查 Boolean false    OAuth2 Access token 取得的方式 OAuth2 總共有下列 4 種 Access token 取得的方式\n   Access token 取得方式 說明      Client Credentials 純 Client 資料身份驗證，僅需要 client_id 與 client_secret 正確即可取得 Access token    Password 資源擁有者須登入帳號密碼，確認可以讓 Client 取得 Access token    Auth Code Grant 資源擁有者授權 Client 可以存取指定 Scope 的資源並給予授權碼，Client 透過此授權碼取得該 Scope 的 Access token    Refresh Token Grant 授權 Client 在取得 Access token 時也一併取得 Refresh token，在 Access token 過期時，Client 可以用此 Refresh token 取得新的相同權限的 Access token     設定存取 Access token 路由 不管是何種 OAuth2 Access token 取得的方式，都須透過相同的路由去取得 Access token，OAuth2 會根據每個取得方式參數的不同做不一樣的驗證，所以我們只有設定下列路由即可\nRoute::post(\u0026#39;oauth/access_token\u0026#39;, function() { return Response::json(Authorizer::issueAccessToken()); }); 設定 client_id 與 client_secret 每一個 Client 應用程式都會有自己的 client_id 與 client_secret，你可以自己設定你要核發給 Client 授權 client_id 與 client_secret 的頁面，並將資料分別存放在 oauth_clients 資料表的 id 與 secret 欄位中\nSchema::create(\u0026#39;oauth_clients\u0026#39;, function (BluePrint $table) { $table-\u0026gt;string(\u0026#39;id\u0026#39;, 40)-\u0026gt;primary(); // client_id $table-\u0026gt;string(\u0026#39;secret\u0026#39;, 40); // client_secret $table-\u0026gt;string(\u0026#39;name\u0026#39;); // Client 名稱 $table-\u0026gt;timestamps(); $table-\u0026gt;unique([\u0026#39;id\u0026#39;, \u0026#39;secret\u0026#39;]); }); Client 資料新增完成之後，之後 Client 可以透過這個 client_id 與 client_secret 去要求取得 Access token，我們這裡以新增 id 為 KeKyun 及 secret 為 KeJyunSecret 作為之後的範例\nINSERT INTO \u0026#34;oauth_clients\u0026#34; (\u0026#34;id\u0026#34;, \u0026#34;secret\u0026#34;, \u0026#34;name\u0026#34;, \u0026#34;created_at\u0026#34;, \u0026#34;updated_at\u0026#34;) VALUES (\u0026#39;KeJyun\u0026#39;, \u0026#39;KeJyunSecret\u0026#39;, \u0026#39;KeJyun Client\u0026#39;, now(), now());  client_id 與 client_secret 欄位長度皆為 40，在產生資料時請自行產生長度 40 的亂數字串，這裡僅用於示範使用非亂數的 client_id 與 client_secret\n 參考資料  lucadegasperi/oauth2-server-laravel OAuth 2.0 筆記 (1) 世界觀 OAuth 2.0 筆記 (2) Client 的註冊與認證 OAuth 2.0 筆記 (3) Endpoints 的規格 OAuth 2.0 筆記 (4.1) Authorization Code Grant Flow 細節 OAuth 2.0 筆記 (4.2) Implicit Grant Flow 細節 OAuth 2.0 筆記 (4.3) Resource Owner Password Credentials Grant Flow 細節 OAuth 2.0 筆記 (4.4) Client Credentials Grant Flow 細節 OAuth 2.0 筆記 (5) 核發與換發 Access Token OAuth 2.0 筆記 (6) Bearer Token 的使用方法 OAuth 2.0 筆記 (7) 安全性問題 各大網站 OAuth 2.0 實作差異 Introduction to authentication with OAuth2 Laravel 4 OAuth2 Testing OAuth2 in Laravel 5  "
},
{
	"uri": "https://laravel5-book.kejyun.com/package/development/package-development/",
	"title": "套件開發",
	"tags": [],
	"description": "",
	"content": "Laravel Packages Development 套件開發 建立本地端的套件資料夾 在本地端開發套件，可以在 Laravel 根目錄自行建立 packages 目錄，然後將套件放在下方路徑中\n packages \u0026gt; \u0026lt;user_name\u0026gt; \u0026gt; \u0026lt;package_name\u0026gt; \u0026gt; \u0026lt;code_folder\u0026gt;\n app packages # 套件資料夾（原本沒有此資料，需要自行建立） kejyun # \u0026lt;user_name\u0026gt; 作者名稱 larapack # \u0026lt;package_name\u0026gt; 套件名稱 src # \u0026lt;code_folder\u0026gt; 所有套件程式皆放在此目錄 所有套件相關的程式皆放在此路徑下\n 建立套件 composer.json 在建立的套件目錄下初始化此套件的 composer.json\n~/laravel_project/packages/kejyun/larapack $ composer init Package name (\u0026lt;vendor\u0026gt;/\u0026lt;name\u0026gt;) [vagrant/larapack]: kejyun/larapack Description []: KJ Larapack Author [, n to skip]: KeJyun \u0026lt;kejyun@gmail.com\u0026gt; Minimum Stability []: dev Package Type (e.g. library, project, metapackage, composer-plugin) []: License []: MIT Define your dependencies. Would you like to define your dependencies (require) interactively [yes]? no Would you like to define your dev dependencies (require-dev) interactively [yes]? no { \u0026#34;name\u0026#34;: \u0026#34;kejyun/larapack\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;KJ Larapack\u0026#34;, \u0026#34;license\u0026#34;: \u0026#34;MIT\u0026#34;, \u0026#34;authors\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;KeJyun\u0026#34;, \u0026#34;email\u0026#34;: \u0026#34;kejyun@gmail.com\u0026#34; } ], \u0026#34;minimum-stability\u0026#34;: \u0026#34;dev\u0026#34;, \u0026#34;require\u0026#34;: {} } Do you confirm generation [yes]? 建立完的套件 composer.json 會長的像這樣\n{ \u0026#34;name\u0026#34;: \u0026#34;kejyun/larapack\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;KJ Larapack\u0026#34;, \u0026#34;license\u0026#34;: \u0026#34;MIT\u0026#34;, \u0026#34;authors\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;KeJyun\u0026#34;, \u0026#34;email\u0026#34;: \u0026#34;kejyun@gmail.com\u0026#34; } ], \u0026#34;minimum-stability\u0026#34;: \u0026#34;dev\u0026#34;, \u0026#34;require\u0026#34;: {} }  設定根目錄與套件目錄的 psr-4 自動載入程式 1. 根目錄 composer.json\n在開發過程中，為了測試方便，需要能夠在本地端直接讀取到套件的資料，在根目錄的 composer.json 直接設定使用 psr-4 自動載入套件路徑的程式，並設定在此路徑下的命名空間\n 命名空間需與接下來要上傳到 Packagist 給大家使用的套件命名空間相同，若之後需要讓大家用 \u0026lt;user_name\u0026gt;\\\u0026lt;package_name\u0026gt; 使用您的套件，這邊的命名空間就需預先設定好，在開發套件過程中，也可以直接用這樣的方式去存取套件\n /* composer.json */ { \u0026#34;autoload\u0026#34;: { \u0026#34;classmap\u0026#34;: [ \u0026#34;database/seeds\u0026#34;, \u0026#34;database/factories\u0026#34; ], \u0026#34;psr-4\u0026#34;: { \u0026#34;App\\\\\u0026#34;: \u0026#34;app/\u0026#34;, \u0026#34;KeJyun\\\\Larapack\\\\\u0026#34; : \u0026#34;packages/kejyun/larapack/src\u0026#34; } }, } 2. 套件目錄 composer.json\n在套件目錄設定套件命名空間的目錄為 src 目錄，在使用 composer require 安裝套件到 vendor 目錄時，autoload 會使用此命名空間去載入套件 src 目錄的程式\n/* packages/kejyun/larapack/composer.json */ { \u0026#34;autoload\u0026#34;: { \u0026#34;psr-4\u0026#34;: { \u0026#34;KeJyun\\\\Larapack\\\\\u0026#34;: \u0026#34;src\u0026#34; } }, } 3. 產生 autoload 檔案\n因為需要載入非 vendor 目錄的套件資料，是自行設定的自動載入目錄，所以需要在專案根目錄產生新的 autoload 檔案\n~/laravel_project $ composer dump-autoload Generating optimized autoload files 建立套件類別 Larapack app packages # 套件資料夾（原本沒有此資料，需要自行建立） kejyun # \u0026lt;user_name\u0026gt; 作者名稱 larapack # \u0026lt;package_name\u0026gt; 套件名稱 src # \u0026lt;code_folder\u0026gt; 所有套件程式皆放在此目錄 Larapack.php # 套件主程式 我們套件程式的進入點為 packages/kejyun/larapack/src/Larapack.php，在裡面可以寫一個簡單的 dump 方法，等等可以測試是否可以正常呼叫\n\u0026lt;?php // packages/kejyun/larapack/src/Larapack.php namespace KeJyun\\Larapack; class Larapack { public function dump($message) { dump($message); } }  建立套件 ServiceProvider 與 Facade Packagist 是所有 PHP 相關的套件，不是只提供給 Laravel 做使用，所以若要讓套件可以支援 Laravel，則必須提供 ServiceProvider 與 Facade 讓我們能夠快速的在 Laravel 使用套件的方法\napp packages # 套件資料夾（原本沒有此資料，需要自行建立） kejyun # \u0026lt;user_name\u0026gt; 作者名稱 larapack # \u0026lt;package_name\u0026gt; 套件名稱 src # \u0026lt;code_folder\u0026gt; 所有套件程式皆放在此目錄 Larapack.php # 套件主程式 LarapackServiceProvider.php # 套件 ServiceProvider(for laravel) LarapackFacade.php # 套件 Facade(for laravel) 在 ServiceProvider 註冊一個名稱為 larapack 的類別，使用 Larapack 物件作為此類別\n\u0026lt;?php namespace KeJyun\\Larapack; use Illuminate\\Support\\ServiceProvider; class LarapackServiceProvider extends ServiceProvider { public function boot() { } // 註冊套件函式  public function register() { $this-\u0026gt;app-\u0026gt;singleton(\u0026#39;larapack\u0026#39;, function ($app) { return new Larapack(); }); } } 使用在 ServiceProvider 註冊的 larapack類別，作為 Laravel 的 Facade 物件\n\u0026lt;?php namespace KeJyun\\Larapack; use Illuminate\\Support\\Facades\\Facade; class LarapackFacade extends Facade { protected static function getFacadeAccessor() { return \u0026#39;larapack\u0026#39;; } } Laravel 套件設定 可以將剛剛建立的 ServiceProvider 及 Facade 設定到 config/app.php 檔案中，這樣 Laravel 就可以正常的存取這個套件\n// config/app.php return [ \u0026#39;providers\u0026#39; =\u0026gt; [ KeJyun\\Larapack\\LarapackServiceProvider::class, ], \u0026#39;aliases\u0026#39; =\u0026gt; [ \u0026#39;Larapack\u0026#39; =\u0026gt; \\KeJyun\\Larapack\\LarapackFacade::class, ], ];  呼叫此套件 建立一個套件控制器，可以試著呼叫剛剛建立的套件，就可以在畫面中順利的看到你的套件被正常呼叫了。\n\u0026lt;?php namespace App\\Http\\Controllers; use Larapack; class PackageController extends Controller { public function larapack() { Larapack::dump(\u0026#39;My Laravel Package\u0026#39;); } } 參考資料  如何開發自己的Package? | 點燈坊 Laravel 開發擴充套件包基本流程 - ITW01 模組化 套件 開發自己的Package - Alvin Chen Club Laravel 5 套件開發設定 Laravel 5.5 Package Development – Markus Tripp – Medium  "
},
{
	"uri": "https://laravel5-book.kejyun.com/database/redis/aws-cluster/aws-cluster/",
	"title": "AWS Redis 設定",
	"tags": [],
	"description": "",
	"content": "AWS Redis 設定  Laravel 版本：5.2\n AWS Redis Cluster Mode Enable 啟用群集模式 建立 Redis AWS Cluster Mode Enable 群集 建立 AWS Cluster Mode Enable 群集，將「Cluster Mode enabled」打勾，在下方的「Number of Shareds」設定資料分片數量，以及在「Replicas per Shared」設定每個分片數量要有幾個備援。\n 取得群集端點（Endpoint） 建立完群集之後，在列表中取得群集端點（Configuration Endpoint）\n將群集端點設定到 database.php，並將 cluster 設定為 true，在設定檔加入 options 選項為 ['cluster' =\u0026gt; 'redis']，並設定預設的 default 連線。\n// 檔案位置：config/database.php return [ \u0026#39;redis\u0026#39; =\u0026gt; [ \u0026#39;cluster\u0026#39; =\u0026gt; true, \u0026#39;options\u0026#39; =\u0026gt; [\u0026#39;cluster\u0026#39; =\u0026gt; \u0026#39;redis\u0026#39;], \u0026#39;default\u0026#39; =\u0026gt; [ \u0026#39;host\u0026#39; =\u0026gt; env(\u0026#39;REDIS_HOST\u0026#39;, \u0026#39;localhost\u0026#39;), \u0026#39;password\u0026#39; =\u0026gt; env(\u0026#39;REDIS_PASSWORD\u0026#39;, null), \u0026#39;port\u0026#39; =\u0026gt; env(\u0026#39;REDIS_PORT\u0026#39;, 6379), // \u0026#34;persistent\u0026#34; =\u0026gt; \u0026#39;cache\u0026#39;, \u0026#39;database\u0026#39; =\u0026gt; 0, ], \u0026#39;session\u0026#39; =\u0026gt; [ \u0026#39;host\u0026#39; =\u0026gt; env(\u0026#39;REDIS_HOST\u0026#39;, \u0026#39;localhost\u0026#39;), \u0026#39;password\u0026#39; =\u0026gt; env(\u0026#39;REDIS_PASSWORD\u0026#39;, null), \u0026#39;port\u0026#39; =\u0026gt; env(\u0026#39;REDIS_PORT\u0026#39;, 6379), // \u0026#34;persistent\u0026#34; =\u0026gt; \u0026#39;cache\u0026#39;, \u0026#39;database\u0026#39; =\u0026gt; 0, ], \u0026#39;queue\u0026#39; =\u0026gt; [ \u0026#39;host\u0026#39; =\u0026gt; env(\u0026#39;REDIS_HOST\u0026#39;, \u0026#39;localhost\u0026#39;), \u0026#39;password\u0026#39; =\u0026gt; env(\u0026#39;REDIS_PASSWORD\u0026#39;, null), \u0026#39;port\u0026#39; =\u0026gt; env(\u0026#39;REDIS_PORT\u0026#39;, 6379), // \u0026#34;persistent\u0026#34; =\u0026gt; \u0026#39;cache\u0026#39;, \u0026#39;database\u0026#39; =\u0026gt; 0, ], ] ]; 因為 AWS Redis Cluster Enabled 的模式，database 的數量固定只有第 0 個，所以若有用其他的 database 的話，記得要把所有的 database 改為 0。\n"
},
{
	"uri": "https://laravel5-book.kejyun.com/http/request/request/",
	"title": "HTTP 請求",
	"tags": [],
	"description": "",
	"content": "HTTP 請求 這裏會介紹如何在 Laravel 5 驗證 HTTP 請求的資料\n建立新的請求驗證 如果我們有文章（Article）的模型，我們在每次請求過程中想要驗證傳入的資料，我們可以使用系列指令建立要驗證的請求：\n$ php artisan make:request CreateArticleRequest 請求驗證的檔案會被建立在 app\\Http\\Requests 目錄下，建立的檔案內容如下\n\u0026lt;?php namespace App\\Http\\Requests; // app\\Http\\Requests\\CreateArticleRequest.php use App\\Http\\Requests\\Request; class CreateArticleRequest extends Request { /** * Determine if the user is authorized to make this request. * 驗證使用者是否要登入狀態 * * @return bool */ public function authorize() { return true; } /** * Get the validation rules that apply to the request. * 驗證請求的資料規則 * * @return array */ public function rules() { return [ // 使用 | 設定驗證規則  \u0026#39;title\u0026#39; =\u0026gt; \u0026#39;required|min:3\u0026#39;, \u0026#39;body\u0026#39; =\u0026gt; \u0026#39;required|min:30\u0026#39;, // 使用陣列設定驗證規則  \u0026#39;published_at\u0026#39; =\u0026gt; [ \u0026#39;required\u0026#39;, \u0026#39;date\u0026#39;, ], ]; } } 在驗證請求的 CreateArticleRequest 中的 rules() 函式，除了僅回傳驗證規則外，你也可以判斷不同的狀況去加入不同的規則再回傳，像是：\n\u0026lt;?php namespace App\\Http\\Requests; // app\\Http\\Requests\\CreateArticleRequest.php use App\\Http\\Requests\\Request; class CreateArticleRequest extends Request { public function rules() { $rules = [ // 使用 | 設定驗證規則  \u0026#39;title\u0026#39; =\u0026gt; \u0026#39;required|min:3\u0026#39;, \u0026#39;body\u0026#39; =\u0026gt; \u0026#39;required|min:30\u0026#39;, // 使用陣列設定驗證規則  \u0026#39;published_at\u0026#39; =\u0026gt; [ \u0026#39;required\u0026#39;, \u0026#39;date\u0026#39;, ], ]; // 其他條件判斷  if ($condition) { $rules[\u0026#39;something_else\u0026#39;] = \u0026#39;required\u0026#39;; } return $rules; } }  指定 Controller 函式處理指定的請求驗證 在我們使用 Controller 去處理請求時，我們可以再傳入變數內設定要怎麼處理請求：\nclass ArticleController extends Controller { // 新增文章 public function store(App\\Http\\Requests\\CreateArticleRequest $request) { Article::create(Request:all()); // OR // Article::create($request-\u0026gt;all()); return redirect(\u0026#39;articles\u0026#39;); } } 這樣設定之後，所有的 HTTP 請求的 Input 資料都會經過 App\\Http\\Requests\\CreateArticleRequest 驗證，如果有經過驗證才會繼續執行後面的新增文章動作，否則的話則會丟出驗證錯誤的物件到原頁面。\n驗證錯誤訊息 這裏要注意到，視圖（View）的每一頁 Laravel 都會將驗證錯誤物件（Illuminate\\Support\\ViewErrorBag）包成 $errors 變數，所以你可以在每一頁去印出 $errors 值，$errors 變數儲存的是任何資料驗證錯誤的結果\n判斷是否有任何的錯誤並顯示錯誤訊息\n// 任一 blade 視圖（View）皆可以接收此錯誤變數 @if($errors-\u0026gt;any()) // 有錯誤訊息 \u0026lt;ul\u0026gt; $foreach ($errors-\u0026gt;all() as $error) \u0026lt;li\u0026gt;{{ $error }}\u0026lt;/li\u0026gt; @endforeach \u0026lt;/ul\u0026gt; @endif  使用 Controller 內建的 validate 驗證請求的資料 除了建立驗證 Request 物件，也可以直接使用 Controller 內建的 validate 去驗證請求\n如果不想要使用內建處理 HttpResponseException 的例外，你也可以自己 try catch 並自己處理例外狀況\nclass ArticleController extends Controller { // 新增文章 public function store(Requests $request) { try { $this-\u0026gt;validate($request, [ \u0026#39;title\u0026#39; =\u0026gt; \u0026#39;required|min:3\u0026#39;, \u0026#39;body\u0026#39; =\u0026gt; \u0026#39;required|min:30\u0026#39;, \u0026#39;published_at\u0026#39; =\u0026gt; \u0026#39;required|date\u0026#39;, ]); } catch (Exception $e) { // 自己處理例外狀況 } Article::create(Request:all()); // OR // Article::create($request-\u0026gt;all()); return redirect(\u0026#39;articles\u0026#39;); } } 使用者資料 取得 User Agent、Referrer\n\u0026lt;?php // User Agent request()-\u0026gt;server(\u0026#39;HTTP_USER_AGENT\u0026#39;); // Referrer request()-\u0026gt;server(\u0026#39;HTTP_REFERER\u0026#39;) 參考資料  Form Requests and Controller Validation - Laracasts  !INCLUDE \u0026ldquo;../../kejyun/book/laravel-5-for-beginner.md\u0026rdquo;\n"
},
{
	"uri": "https://laravel5-book.kejyun.com/database/postgresql/install-odbc-driver/",
	"title": "安裝 PostgreSQL ODBC driver",
	"tags": [],
	"description": "",
	"content": " 環境：OS X\n  日期：2015-03-29\n  PHP：5.6\n 在我們在 Laravel 使用 PostgreSQL 去做 Migration 的時候，我們會看到像下面這樣的錯誤訊息：\n$ php artisan migrate [PDOException] could not find driver $ 這表示我們沒有相關的連線驅動程式去連線到 PostgreSQL，所以我們需要安裝我們所需要的驅動程式\n在 OS X 的 PHP 相關環境我是用 brew 去安裝的，如果你也是用 brew 去安裝，可以先看看自己的套件是用哪一個版本的 PHP\n$ brew list autoconf git libpng mhash php56 readline zlib freetype icu4c libtool nvm php56-mcrypt unixodbc gettext jpeg mcrypt openssl postgresql wget 然後搜尋現在 brew 支援的 PostgreSQL 驅動程式\n$ brew search pgsql osm2pgsql\tphp54-pdo-pgsql php55-pdo-pgsql php56-pdo-pgsql  我們找到我們 php 5.6 版本的驅動程式了，可以用下面的指令去安裝\n$ brew install php56-pdo-pgsql 安裝完成後就可以正常的使用 Migration 或相關的 DB 指令去存取 PostgreSQL 了～～！！\n參考資料  Laravel: Error [PDOException]: Could not Find Driver in PostgreSQL  "
},
{
	"uri": "https://laravel5-book.kejyun.com/structure/service-repository-structure-principle/",
	"title": "Service &amp; Repository 架構設計準則（2017 年版本）",
	"tags": [],
	"description": "",
	"content": "Service \u0026amp; Repository 架構設計準則（2017 年版本） 傳統的 MVC（Model, View, Controller） 框架，當 Controller 收到請求之後，我們會在 Controller 內直接透過 Model 去撈取資料庫的資料，並在 Controller 做資料驗證、整合、快取、商業邏輯判斷\u0026hellip;等等的工作。\n當系統越來越大，會發現很多類似的商業邏輯的程式都散在各地，沒有辦法重複再利用，當程式需要異動或修改的時候，就要去搜尋所有程式碼，把許多相同商業邏輯的程式碼去做異動，但需要修改的地方若太多，往往會東漏西漏，導致系統出現錯誤，並造成往後開發的時間成本增加。\n所以我們會想要做到 減少重複的程式碼、提高維護開發的效率，所以將程式碼依照分類及分層抽出獨立控管，讓不同類型的程式專心處理自己相關的商業邏輯，讓開發維護更容易。\n隨著程式架構的演進會發展出更多不同的架構，所以這個設計架構準則也是會隨著時間做演進的。\n 資料層級需求分析 Service (服務)\n我們原本在 Controller 處理請求時，會針對使用者的請求，做不同商業邏輯的處理，而同樣的商業邏輯可能會被不同的 Controller 存取，為了讓同個商業邏輯程式能夠重複使用，所以我會分出一層 Service (服務) ，將這些商業邏輯放在裡面，供不同的 Controller 存取。\n在 Service 方法中，會針對目前商業邏輯的資料進行蒐集與彙整，處理過後再回傳給 Controller\nRepository (資源庫)\n在不同 Service 可能會需要對資料庫撈取同樣的資料，為了避免撈取資料的邏輯重複出現在不同的地方，我們會分出一層 Repository (資源庫)，將同樣撈取 Model (模型) 資料的邏輯都寫在一起，供不同的 Service 存取。\n在 Repository 中，會在 function 名稱中指出這個方法是要撈什麼樣的資料，這樣方法可以重用，也可以讓程式有可讀性，不需要再去看 Model sql 條件的邏輯，判斷是在做什麼樣的處理\n e.g. PostRepository-\u0026gt;getWeekTopPosts(); // 取得本週熱門文章\n Model (模型)\n在 Model 中我們僅會寫對資料表對 Eloquent 相關的設定，像是 primaryKey (主鍵名稱) 或 table (資料表名稱)，讓 Model 能夠越乾淨越好，將一些撈取資料的邏輯都往 Repository 集中整理。\nPresenter (資料呈現)\n在 Model 我們有一些資料可能會想要有不同的呈現方式，像是文章發布時間 created_at 我們可能會想要呈現出像是 5 秒前、15 分鐘前、6 小時前 這樣的資料，這些資料因為是隨著時間不同而去動態變化，所以需要用程式去計算與 created_at 的時間差，再去看要如何呈現這筆資料。\n為了能夠讓這些不同資料呈現方式的邏輯能夠重複使用，且不污染 Model 的程式，所以我會分出一層 Presenter (資料呈現)  去輔助 Model 資料的呈現\n e.g. Post-\u0026gt;presenter()-\u0026gt;created_at_human_time;\n  laracasts/Presenter  Cache (快取)\n在使用 Repositoy 去對 Model 做存取得時候，如果我們資料沒有做異動，我們會將資料存放在快取中，直接讀取快取的資料，而減少對資料庫的存取，提高資料的存取效率\n而我們需要對 資料快取的設定、清除 及 快取鍵值 去做管理，快取像是協助 Repository 做資料的存取，所以我會分出一層 Cache (快取)  去輔助 Repository 做快取的處理\nChecker (檢查器)\n而每個商業邏輯需要驗證的資料不同，有些欄位在不同商業邏輯會有必填與非必填不同的差異，像是在做使用者身份驗證時，若有 Email 驗證及手機驗證，在 Email 驗證時，手機欄位為非必填欄位，在做手機驗證時， Email 為非必填欄位，但兩者皆為使用者的資料，無法強制使用者兩個欄位資料皆為必填，但在某些商業頁邏輯是必要的，但基本的資料驗證規則還是一樣，像是資料最長長度、email 格式\u0026hellip;等等。\n所以為了能夠重複使用共用的驗證器規則，所以建構了一個 Checker（檢查器） 的結構，去呼叫不同的 Validator 去檢查資料，像是同一個 Controller 處理的資料可能含有「會員」、「商品」資料，所以同時需要呼叫 會員驗證器（UserValidator） 及 商品驗證器（GoodsValidator） 的驗證規則去驗證資料，所以就透過 Checker（檢查器） 去呼叫不同的驗證器，來達到驗證不同資料的功能，輔助 Controller 做資料驗證。\n Validator (驗證器)\n為了讓資料驗證方法能夠重複使用，不需要在不同的地方去驗證相同的東西，這樣會造成驗證邏輯重複出現，若有需要異動驗證規則時，會難以維護。\n所以我沒有選擇將這些驗證的邏輯寫在 Services、Repository 或 Model 中。\n所以我會分出一層 Validator (驗證器) 輔助 Checker（檢查器） 做資料驗證。\nConcrete (服務組合)\n我們會在 Controller 去呼叫各個不同的 Service 去做資料的判斷處理，有時候不同的 Controller 會有相同呼叫 Service 的邏輯順序及組合的資料，為了減少重複程式，所以我會分出一層 Concrete (服務組合) 去協助 Controller 去做不同 Service 資料的整合撈取\n像是我們在許多 Controller 方法中，我們都要使用 $PostService-\u0026gt;find($post_id); 去找文章資料，並用 $UserService-\u0026gt;find($post_user_id); 去找文章作者相關資訊，這些在 Controller 重複出現的呼叫 Service 邏輯我們就可以寫在 Concrete 中去做呼叫\nConstant (常數)\n我們在做 Model 資料的撈取或是條件判斷時，可能會需要用 Post::where('status', 1)-\u0026gt;get() 或 $Post-\u0026gt;status == 1 去做資料的存取，但像 status 為 1 這種資料對我們是難以做閱讀的，需要知道 1 代表是什麼意思才知道此段程式的邏輯。\n所以我會分出一層 Constant (常數) 輔助做資料的識別，我會將狀態設為可識別的靜態變數，像是 PostConstant::STATUS_PUBLISH = 1;，所以在做程式判斷時，可以用 Post::where('status', PostConstant::STATUS_PUBLISH)-\u0026gt;get() 或 $Post-\u0026gt;status == PostConstant::STATUS_PUBLISH 去做判斷。\n 在 Constant 的變數皆為靜態變數，所以可以供任何類別去做存取。\n  Support (支援)\n我可能會對一資源的資料做簡單的邏輯判斷，不需要依賴任何的 資料控制結構，像是 Service、Repository 或 Model，所以我會分出一層 Support (常數) 去做共用的輔助方法。\n像是我們可以用 PostSupport::getAllPostStatus() 去撈取文章的所有狀態，或者用 GoogleAnalyticSupport::api() 去對 GA 的 API 做存取。\n 在 Support 的方法皆為靜態方法，所以可以供任何類別去做存取。\n ExceptionCode (例外代碼)\n我們在做 API 的資料存取時，會針對不同的例外狀況回傳不同的 錯誤代碼 (error_code)，而同一個錯誤代碼可能在不同的 Controller 或 Service 被回傳，像是文章找不到我們會回傳錯誤代碼 10000001，為了管理及閱讀性方便，我會分出一層 ExceptionCode (例外代碼) 去做共用的例外代碼管理。\n像是找不到文章的代碼我會設為 PostExceptionCode::POST_NOT_FOUND = 10000001;，所以在程式中只要看到 PostExceptionCode::POST_NOT_FOUND 就可以馬上知道這個是找不到文章的錯誤代碼。\n 在 ExceptionCode 的變數皆為靜態變數，所以可以供任何類別去做存取。\n  資料層級結構 資料控制結構  Controller (控制器)  Concrete (服務組合)  Service (服務)  Repository (資源庫)  Model (模型) Presenter (資料呈現)   Cache (快取)     Checker (檢查器)  Validator (驗證器)      獨立結構  Constant (常數) Support (支援) ExceptionCode (例外代碼)   架構圖 結構說明 資料控制結構\n   結構名稱 說明     Controller (控制器) 控制要使用哪些 Service 或 Concrete 的商業邏輯，去組合出使用者請求需要的資料，並做資料的資料交易控制 (transaction) ，並使用 Checker 去檢查任何使用者傳進來的資料，確保資料的正確性   Service (服務) 做資料的驗證，並組合不同的 Repository 資料成商業邏輯，供 Controller 或 Concrete 存取   Repository (資源庫) 撈取屬於自己 Model 不同條件下的資料，並做快取控制，供 Service 存取   Model (模型) 資料表存取相關設定   Presenter (資料呈現) 協助 Model 做資料呈現處理   Cache (快取) 協助 Repository 做快取資料的控制   Checker (檢查器) 協助 Controller 做資料驗證   Validator (驗證器) 協助 Checker 做資料驗證   Concrete (服務組合) 協助 Controller 組合不同 Service 的資料成商業邏輯    獨立結構\n   結構名稱 說明     Constant (常數) 共用變數名稱設定   Support (支援) 共用方法   ExceptionCode (例外代碼) 共用例外代碼設定     架構使用原則 資料控制結構 存取限制 不能跨 2 階層以上存取\n Controller 不能存取 Repository Controller 不能存取 Validator Service 不能存取 Model  低階層的不能存取高階層的資料\n Model 不能存取 Repository Repository 不能存取 Service Validator 不能存取 Checker  同一個資料類型，不能互相呼叫\n避免同一類型類別呼叫，造成 new 物件的時候有無窮迴圈\nPostService 存取 UserService，UserService 存取 PostsService 造成無窮迴圈\n Concrete 不能呼叫 Concrete Service 不能呼叫 Service Checker 不能呼叫 Checker Validator 不能呼叫 Validator Repository 不能呼叫 Repository Cache 不能呼叫 Cache     結構名稱 可存取 可被存取     Controller (控制器) Checker、Concrete、Service、DB transaction -   Concrete (服務組合) Service Controller   Service (服務) Repository、Validator Controller、Concrete   Checker (檢查器) Validator Controller   Validator (驗證器) - Checker   Repository (資源庫) 自己的 Model、自己的 Cache Service   Cache (服務) - Repository   Model (模型) 自己的 Presenter Repository   Presenter (資料呈現) - Model    View (視圖) 使用限制 View 的職責是負責顯示資料，所有的資料應由 Controller 準備好再傳給 View，所以不要在 View 內有複雜的程式判斷邏輯，在 View 裡面只有 if, for, foreach 跟 echo 列印 的程式，僅需要將資料呈現在對的 HTML 裡面，不要再對資料重複處理過。\n像是文章的網址可能會因為類型不同會有不同的網址，像是一般文章網址可能為 http://kejyun.com/post/1，而影音文章網址可能為 http://kejyun.com/video/2，兩者的資料皆為 Post 資料表的資料，在 View 中要顯示網址應為 echo $Post-\u0026gt;post_url; 將網址印出，post_url 則是在傳給 View 之前就經過邏輯判斷的資料，而不是在 View 中判斷不同文章類型（PostConstant::POST_TYPE_NORMAL, PostConstant::POST_TYPE_VIDEO）在 View 中顯示不同的網址資料。\n之後若文章網址邏輯需要修改，則需要到各個 View 中去修改，很容易漏改道造成系統程式出錯\n\u0026lt;a href=\u0026#34;{{ $Post-\u0026gt;post_url }}\u0026#34;\u0026gt; {{ $Post-\u0026gt;Title }}\u0026lt;/a\u0026gt;  結構範例說明 Controller (控制器)  可以存取結構：Checker、Concrete、Service、DB transaction\n  可以被存取結構：無\n 處理 HTTP 請求的入口，依照需求呼叫 Concrete 或 Service 去做資料的存取，大部分情況呼叫 Service 去組合需要的資料就好，若相同的組合邏輯在不同的 Controller 都有用到，那就使用 Concrete 去組合不同的 Service\n要確保所有 Service 商業邏輯都正確跑完才允許對資料做異動，並避免 Transaction 在 Controller 及 Service 被重複呼叫，導致無法正確鎖定資料狀態，所以使用 Controller 當作資料交易（Transaction）的控制點\n\u0026lt;?php class PostController extends Controller { public function __construct( PostConcrete $PostConcrete, PostService $PostService, CommentService $CommentService, PostChecker $PostChecker ) { $this-\u0026gt;PostConcrete = $PostConcrete; $this-\u0026gt;PostService = $PostService; $this-\u0026gt;CommentService = $CommentService; $this-\u0026gt;PostChecker = $PostChecker; } // 顯示文章  public function show($post_id) { try { // 驗證資料  $input = [ \u0026#39;post_id\u0026#39; =\u0026gt; $post_id ]; $this-\u0026gt;PostChecker-\u0026gt;checkShow($input); // 撈取文章  $Post = $this-\u0026gt;PostConcrete-\u0026gt;findPost($post_id); // 撈取文章留言  $Comment = $this-\u0026gt;CommentService-\u0026gt;getCommentByPostId(post_id); } catch (Exception $exception) { throw $exception } } // 更新文章  public function update($post_id) { try { // 驗證資料  $input = request()-\u0026gt;all(); $input[\u0026#39;post_id\u0026#39;] = $post_id; $this-\u0026gt;PostChecker-\u0026gt;checkUpdate($input); // 交易開始  DB::beginTransaction(); // 更新文章  $Post = $this-\u0026gt;PostService-\u0026gt;update($post_id, $input); // 交易結束  DB::commit(); } catch (Exception $exception) { // 交易失敗  DB::rollBack(); throw $exception } } } Concrete (服務組合)  可以存取結構：Service\n  可以被存取結構：Controller\n 使用不同 Service 撈取資料，將不同資料組合成商業邏輯，供 Controller 做存取\n\u0026lt;?php class PostConcrete { public function __construct( PostService $PostService, UserService $UserService ) { $this-\u0026gt;PostService = $PostService; $this-\u0026gt;UserService = $UserService; } // 撈取文章資料  public function findPost($post_id){ try { // 撈取文章  $Post = $this-\u0026gt;PostService-\u0026gt;findPost($post_id); // 撈取文章作者資料  $user_id = $Post-\u0026gt;user_id; $Post-\u0026gt;user = $this-\u0026gt;UserService-\u0026gt;findUser($user_id); return $Post; } catch (Exception $exception) { throw $exception } } }  Service (服務)  可以存取結構：Repository\n  可以被存取結構：Controller、Concrete\n 透過 Validator 驗證傳入的資料，並使用不同的 Repository 撈取資料，將不同資料組合成商業邏輯 使用 Repository 的 Cache 清除 Service 中撈取資料的快取\n\u0026lt;?php class PostService { public function __construct( PostRepository $PostRepository, PostTagRepository $PostTagRepository ) { $this-\u0026gt;PostRepository = $PostRepository; $this-\u0026gt;PostTagRepository = $PostTagRepository; } // 撈取文章  public function findPost($post_id) { try { // 撈取文章  $Post = $this-\u0026gt;PostRepository-\u0026gt;find($post_id); // 撈取文章標籤  $Post-\u0026gt;tag = $this-\u0026gt;PostTagRepository-\u0026gt;getByPostId($post_id); return $Post; } catch (Exception $exception) { throw $exception } } public function clearPostCache($post_id) { try { $Post = $this-\u0026gt;findPost($post_id); // 清除文章快取  $this-\u0026gt;PostRepository-\u0026gt;cache()-\u0026gt;clearPostCache($Post); // 清除文章標籤快取  $this-\u0026gt;PostTagCache-\u0026gt;clearPostTagCache($Post-\u0026gt;tag); } catch (Exception $exception) { throw $exception } } } Checker (檢查器)  可以存取結構：Validator\n  可以被存取結構：Controller\n 協助 Controller 驗證資料的正確性，若驗證錯誤則丟處例外，Controller 根據例外代碼去做處理\n\u0026lt;?php class PostValidator { public function checkFindPost($input){ // 驗證文章資料  $this-\u0026gt;PostValidator-\u0026gt;validatePostId($input); $this-\u0026gt;PostValidator-\u0026gt;validatePostContent($input); // 驗證會員資料  $this-\u0026gt;MemberValidator-\u0026gt;validateMemberId($input); } } Validator (驗證器)  可以存取結構：無\n  可以被存取結構：Checker\n 協助 Checker 驗證資料的正確性，若驗證錯誤則丟處例外，Checker 根據例外代碼去做處理\n\u0026lt;?php class PostValidator { public function validatePostId($input){ // 設定驗證規則  $rules = [ \u0026#39;post_id\u0026#39; =\u0026gt; [ \u0026#39;required\u0026#39;, \u0026#39;max:20\u0026#39;, ], ]; // 開始驗證  $this-\u0026gt;validator = Validator::make($input, $rules); if ($this-\u0026gt;validator-\u0026gt;fails()) { throw new Exception( \u0026#39;文章編號格式錯誤\u0026#39;, PostExceptionCode::POST_ID_FORMAT_ERROR ); } } }  Repository (資源庫)  可以存取結構：自己的 Model、自己的 Cache\n  可以被存取結構：Service\n 僅能撈取屬於自己的 Model 資料，像 PostRepository 僅能存取 Post Model (模型) 的資料，並使用不同條件撈取 Model 的資料，供 Service 做存取\n\u0026lt;?php class PostRepository { public function __construct( Post $Post, PostCache $PostCache ) { $this-\u0026gt;Post = $Post; $this-\u0026gt;PostCache = $PostCache; } public function cache() { return $this-\u0026gt;PostCache; } public function find($post_id) { try { $cache_key = $this-\u0026gt;cache()-\u0026gt;getPostCacheKey($post_id); if (Cache::has($cache_key)) { // 有快取資料  $Post = Cache::get($cache_key); return $Post; } // 撈取資料庫文章資料  $Post = $this-\u0026gt;Post-\u0026gt;find($post_id); if(!is_null($Post)) { // 紀錄快取  $this-\u0026gt;cache()-\u0026gt;putPost($Post); } return $Post; } catch (Exception $exception) { throw $exception } } public function findLatestPost() { try { $cache_key = $this-\u0026gt;cache()-\u0026gt;getLatestPostCacheKey($post_id); if (Cache::has($cache_key)) { // 有快取資料  $$Posts = Cache::get($cache_key); return $Post; } // 撈取資料庫文章資料  $Post = $this-\u0026gt;Post -\u0026gt;order(\u0026#39;created_at\u0026#39;, \u0026#39;desc\u0026#39;) -\u0026gt;first(); if(!is_null($Post)) { // 紀錄快取  $this-\u0026gt;cache()-\u0026gt;putLatestPost($Post); } return $Post; } catch (Exception $exception) { throw $exception } } } Cache (快取)  可以存取結構：無\n  可以被存取結構：Repository\n 協助 Repository 做快取資料的控制，快取鍵值的管理、資料讀取及清除\n\u0026lt;?php class PostCache { public function getPostCacheKey($post_id) { // 撈取文章快取鍵值  } public function putPost(Post $Post) { // 紀錄文章快取  } public function clearPostCache(Post $Post) { // 清除文章快取  } }  Model (模型)  可以存取結構：無\n  可以被存取結構：Repository\n Eloquent 存取資料表相關設定，使用 Eloquent 直接存取資料表資料\n\u0026lt;?php class Post extends Model { protected $table = \u0026#39;post\u0026#39;; protected $fillable = []; protected $primaryKey = \u0026#39;id\u0026#39;; protected $dates = [\u0026#39;created_at\u0026#39;, \u0026#39;updated_at\u0026#39;]; protected $presenter = \u0026#39;PostPresenter\u0026#39;; } Presenter (資料呈現)  可以存取結構：無\n  可以被存取結構：Model\n 提供 Model 的資料用其他方式呈現\n\u0026lt;?php class PostPresenter extends Presenter { public function created_at_human_time() { return $this-\u0026gt;created_at-\u0026gt;diffForHumans(); } } Constant (常數)  可以存取結構：無\n  可以被存取結構：無限制\n 資料皆為靜態變數，可以供所有資料層級 (e.g. Controller、Service、Repository) 做存取\n\u0026lt;?php class PostConstant { const POST_TYPE_PUBLIC = \u0026#39;P\u0026#39;; const POST_TYPE_DELETE = \u0026#39;D\u0026#39;; }  Support (支援)  可以存取結構：無\n  可以被存取結構：無限制\n 方法皆為靜態變數，可以供所有資料層級 (e.g. Controller、Service、Repository) 做存取\n若有其他可供全域共用的方法皆寫在 Support 靜態方法供大家存取\n\u0026lt;?php class PostSupport { // 撈取所有文章類型  public static function getAllPostType() { $all_post_type = [ PostConstant::POST_TYPE_PUBLIC, PostConstant::POST_TYPE_DELETE, ]; return $all_post_type; } } ExceptionCode (例外代碼)  可以存取結構：無\n  可以被存取結構：無限制\n 資料皆為靜態變數，可以供所有資料層級 (e.g. Controller、Service、Repository) 做存取\n\u0026lt;?php class PostExceptionCode { const POST_ID_FORMAT_ERROR = 10000001; const POST_NOT_FOUND = 10000002; const POST_TAG_NOT_FOUND = 10000003; } "
},
{
	"uri": "https://laravel5-book.kejyun.com/services/laravel-mix/laravel-mix-intro/",
	"title": "Laravel Mix 介紹",
	"tags": [],
	"description": "",
	"content": "Laravel Mix 介紹 安裝 確認系統有安裝 node 及 npm\nnode -v npm -v 套件安裝除錯 在安裝過程中出現 node_modules/pngquant-bin/vendor/pngquant binary doesn't seem to work correctly 的訊息，如下：\n$ npm install \u0026gt; pngquant-bin@4.0.0 postinstall /home/web-laravel55/node_modules/pngquant-bin \u0026gt; node lib/install.js ⚠ The `/home/web-laravel55/node_modules/pngquant-bin/vendor/pngquant` binary doesn't seem to work correctly ⚠ pngquant pre-build test failed ℹ compiling from source ✔ pngquant pre-build test passed successfully ✖ Error: pngquant failed to build, make sure that libpng-dev is installed at Promise.all.then.arr (/home/web-laravel55/node_modules/pngquant-bin/node_modules/bin-build/node_modules/execa/index.js:231:11) at process._tickCallback (internal/process/next_tick.js:68:7) npm WARN ajv-keywords@3.4.1 requires a peer of ajv@^6.9.1 but none is installed. You must install peer dependencies yourself. npm WARN optional SKIPPING OPTIONAL DEPENDENCY: fsevents@1.2.9 (node_modules/fsevents): npm WARN notsup SKIPPING OPTIONAL DEPENDENCY: Unsupported platform for fsevents@1.2.9: wanted {\u0026quot;os\u0026quot;:\u0026quot;darwin\u0026quot;,\u0026quot;arch\u0026quot;:\u0026quot;any\u0026quot;} (current: {\u0026quot;os\u0026quot;:\u0026quot;linux\u0026quot;,\u0026quot;arch\u0026quot;:\u0026quot;x64\u0026quot;}) npm ERR! code ELIFECYCLE npm ERR! errno 1 npm ERR! pngquant-bin@4.0.0 postinstall: `node lib/install.js` npm ERR! Exit status 1 npm ERR! npm ERR! Failed at the pngquant-bin@4.0.0 postinstall script. npm ERR! This is probably not a problem with npm. There is likely additional logging output above. npm ERR! A complete log of this run can be found in: npm ERR! /home/kejyun/.npm/_logs/2019-07-30T04_22_17_230Z-debug.log 可以在 Ubuntu 安裝 libpng-dev 套件，即可正常安裝此套件\nsudo apt-get install libpng-dev npm install -g pngquant-bin npm run dev 參考資料  Compiling Assets (Laravel Mix) - Laravel - The PHP Framework For Web Artisans node_modules/pngquant-bin/vendor/pngquant` binary doesn\u0026rsquo;t seem to work correctly · Issue #78 · imagemin/pngquant-bin · GitHub  "
},
{
	"uri": "https://laravel5-book.kejyun.com/services/errors-logs/packages/errors-log-packages-log-viewer/",
	"title": "Log Viewer",
	"tags": [],
	"description": "",
	"content": "Log Viewer 參考資料  ARCANEDEV/LogViewer: Provides a log viewer for Laravel 5 Laravel Log Viewer using LogViewer Package in Laravel 5.6 - Learn Infinity - YouTube [Package] LogViewer (For Laravel 5)  "
},
{
	"uri": "https://laravel5-book.kejyun.com/services/unit-test/unit-test-post-csrf/",
	"title": "POST CSRF 錯誤",
	"tags": [],
	"description": "",
	"content": "POST CSRF 錯誤 當我們在使用 Unit test 做 POST 測試時，測試的程式可能像：\n\u0026lt;?php class UserTest extends TestCase { /** * 測試註冊 */ public function testSignup() { $parameters = [ \u0026#39;email\u0026#39;=\u0026gt;\u0026#39;kejyun@gmail.com\u0026#39;, \u0026#39;name\u0026#39;=\u0026gt;\u0026#39;KeJyun\u0026#39; ]; // 傳送參數  $response = $this-\u0026gt;call(\u0026#39;POST\u0026#39;, \u0026#39;/signup\u0026#39;, $parameters); $this-\u0026gt;assertEquals(200, $response-\u0026gt;getStatusCode()); } }  在執行單元測試後，你會收到一個 TokenMismatchException 的例外錯誤，這個部分是 Middleware VerifyCsrfToken 的驗證錯誤\n這是因為 Laravel 5 在所有的 POST、PUT、DELETE 的路由方法中，都會預設加入 CSRF Token 的檢查，他會檢查 POST 過來的資料中 _token 的資料值與 Session 中的 token 是否相符，或是驗證標頭中的 X-CSRF-TOKEN 是否相符。\n所以在我們每一次做 POST、PUT、DELETE 的請求時，我們都必須要將 CSRF Token 帶入檢查，才能執行後面的程式動作，我們可以用這樣的方式帶入 CSRF Token：\n\u0026lt;?php class UserTest extends TestCase { /** * 測試註冊 */ public function testSignup() { // 開啟 Session  Session::start(); // 參數加入 CSRF token  $parameters = [ \u0026#39;_token\u0026#39;=\u0026gt;csrf_token(), \u0026#39;email\u0026#39;=\u0026gt;\u0026#39;kejyun@gmail.com\u0026#39;, \u0026#39;name\u0026#39;=\u0026gt;\u0026#39;KeJyun\u0026#39; ]; // 傳送參數  $response = $this-\u0026gt;call(\u0026#39;POST\u0026#39;, \u0026#39;/signup\u0026#39;, $parameters); $this-\u0026gt;assertEquals(200, $response-\u0026gt;getStatusCode()); } } 在使用 csrf_token() 方法時，都必須要先使用 Session::start(); 將 Session 開啟，以紀錄當時的 CSRF Token 做驗證，並將 _token 當作參數傳送到 POST、PUT、DELETE 的路由當中，就可以正常執行單元測試了！\n參考資料  HTTP 路由 - Laravel.tw Testing Laravel 5 Routes with CSRF Protection Using PHPUnit  "
},
{
	"uri": "https://laravel5-book.kejyun.com/http/request/",
	"title": "Request 請求",
	"tags": [],
	"description": "",
	"content": "這裏會介紹如何在 Laravel 5 處理 HTTP Request 請求。\n"
},
{
	"uri": "https://laravel5-book.kejyun.com/services/errors-logs/packages/errors-log-packages-slack-log/",
	"title": "Slack Log",
	"tags": [],
	"description": "",
	"content": "Slack Log Slack Logging  版本：Laravel 5.6 內建 Slack Logging\n 1. 加入 Slack App\n加入新的 App 到 Slack\n2. 搜尋 Slack App Incoming Webhook\n搜尋 Incoming Webhook，讓 Laravel 可以發送訊息到 Slack\n3. Slack App Incoming Webhook 加入設定\n4. 取得 Slack App Incoming Webhook 網址\n5. 設定 log 方式\n在 config/logging.php 檔案中的 stack 加入 slack 設定，這樣 Log 資料會記錄到 Log File 及 Slack\n // config/logging.php return [ \u0026#39;default\u0026#39; =\u0026gt; env(\u0026#39;LOG_CHANNEL\u0026#39;, \u0026#39;stack\u0026#39;), \u0026#39;channels\u0026#39; =\u0026gt; [ \u0026#39;stack\u0026#39; =\u0026gt; [ \u0026#39;driver\u0026#39; =\u0026gt; \u0026#39;stack\u0026#39;, \u0026#39;channels\u0026#39; =\u0026gt; [\u0026#39;single\u0026#39;, \u0026#39;slack\u0026#39;], ], \u0026#39;slack\u0026#39; =\u0026gt; [ \u0026#39;driver\u0026#39; =\u0026gt; \u0026#39;slack\u0026#39;, \u0026#39;url\u0026#39; =\u0026gt; env(\u0026#39;LOG_SLACK_WEBHOOK_URL\u0026#39;), \u0026#39;username\u0026#39; =\u0026gt; \u0026#39;Laravel Log\u0026#39;, \u0026#39;emoji\u0026#39; =\u0026gt; \u0026#39;:boom:\u0026#39;, \u0026#39;level\u0026#39; =\u0026gt; \u0026#39;debug\u0026#39;, ], ], ]; 設定 .env 檔案，將 Slack Incoming Webhook 網址 設定到 LOG_SLACK_WEBHOOK_URL\nLOG_SLACK_WEBHOOK_URL=https://hooks.slack.com/services/XXXXXXXXXX 6. 檢視 Slack Laravel Log\n當程式使用 Log::error('WFT Error Log'); 去紀錄 Log 或有任何的 Exception 就可以在 Slack 看到了\nLaravel Slack Log  版本：Laravel 5.5 套件 cr0wst/laravel-slack-log: Utilizes Laravel\u0026rsquo;s notifications to provide logging to slack at various levels. Inspired by Log4j.\n 1. 安裝套件\ncomposer require smcrow/laravel-slack-log 2. 設定 config/app.php\n\u0026lt;?php // config/app.php return [ \u0026#39;aliases\u0026#39; =\u0026gt; [ \u0026#39;SlackLog\u0026#39; =\u0026gt; \\Smcrow\\SlackLog\\Facades\\SlackLog::class ], ]; 3. 建立設定檔\nphp artisan vendor:publish 4. 丟出例外 Slack Log\n\u0026lt;?php try { throw new Exception(\u0026#39;Hello Error Message\u0026#39;); } catch (Exception $exception) { SlackLog::debug($exception); SlackLog::debug($exception); SlackLog::trace($exception); SlackLog::info($exception); SlackLog::warn($exception); SlackLog::error($exception); } 5. Log 等級及顯示方式\n DEBUG TRACE INFO WARN ERROR  1. DEBUG\n2. TRACE\n3. INFO\n4. WARN\n5. ERROR\n參考資料 Laravel 5.3\n Sending Slack Notifications from Your Laravel App – Olayinka Omole – Medium  Laravel 5.5\n gpressutto5/laravel-slack: Slack notification for Laravel as it should be. Easy, fast, simple and highly testable. cr0wst/laravel-slack-log: Utilizes Laravel\u0026rsquo;s notifications to provide logging to slack at various levels. Inspired by Log4j.  Laravel 5.6\n Enviando logs para o Slack no Laravel - YouTube Logging - Laravel - The PHP Framework For Web Artisans Notifications - Laravel - The PHP Framework For Web Artisans  不限 Laravel 版本\n maknz/slack: A simple PHP package for sending messages to Slack, with a focus on ease of use and elegant syntax. Laravel Slack - Laravel Tips \u0026lsquo;N Tricks  Slack\n Slack Imcoming webhooks  CloudWatch Slack\n jamesfairhurst/laravel-cloudwatch-logs-lambda-slack: Use AWS CloudWatch Logs \u0026amp; Lambda to post Laravel Log messages to Slack Using AWS CloudWatch for Laravel Logs on Forge – James Fairhurst – Medium  討論文章\n L5 Monolog with Slack integration  "
},
{
	"uri": "https://laravel5-book.kejyun.com/services/errors-logs/service/errors-log-service-understand-io/",
	"title": "Understand.io",
	"tags": [],
	"description": "",
	"content": "Understand.io  紀錄 Laravel Log\n 在 understand/understand-laravel5 套件 github，依照步驟安裝 Understand.io\n1.安裝套件\ncomposer require understand/understand-laravel5 2.加入套件設定\n在 config/app.php 檔案中加入設定\n\u0026lt;?php // config/app.php return [ \u0026#39;providers\u0026#39; =\u0026gt; [ Understand\\UnderstandLaravel5\\UnderstandLaravel5ServiceProvider::class, ], ]  3.設定 .env 檔案\nUNDERSTAND_ENABLED=true UNDERSTAND_TOKEN=\u0026lt;API TOKEN 放這裡\u0026gt; 4.紀錄 Log\n\u0026lt;?php \\Log::error(\u0026#39;Understand.io test error\u0026#39;); 參考資料  Understand.io - Online Event and Log Management understand/understand-laravel5  "
},
{
	"uri": "https://laravel5-book.kejyun.com/services/mail/mail-gmail/",
	"title": "使用 Gmail 寄信",
	"tags": [],
	"description": "",
	"content": "使用 Gmail 寄信 在測試機測試的時候，為了節省郵件服務的開銷，我們可以使用 Gmail 當作我們測試的郵件服務，所以我們來介紹如何使用 Gmail 寄信\n設定 config/mail.php  driver 設為 smtp\n  host 設為 smtp.gmail.com\n  port 設為 587\n  username 設為你要用來寄信的 Gmail 帳號 kejyun@gmail.com\n  password 設為 Gmail 帳號的密碼\n  pretend 設為 true，這樣才可以正常使用 Gmail 寄送\n 設定完後會像這樣：\n// config/mail.php return [ \u0026#39;driver\u0026#39; =\u0026gt; \u0026#39;smtp\u0026#39;, \u0026#39;host\u0026#39; =\u0026gt; \u0026#39;smtp.gmail.com\u0026#39;, \u0026#39;port\u0026#39; =\u0026gt; 587, \u0026#39;from\u0026#39; =\u0026gt; [\u0026#39;address\u0026#39; =\u0026gt; \u0026#39;kejyun@gmail.com\u0026#39;, \u0026#39;name\u0026#39; =\u0026gt; \u0026#39;KeJyun\u0026#39;], \u0026#39;encryption\u0026#39; =\u0026gt; \u0026#39;tls\u0026#39;, \u0026#39;username\u0026#39; =\u0026gt;\u0026#39;kejyun@example.com\u0026#39;, \u0026#39;password\u0026#39; =\u0026gt; \u0026#39;abcdefghijklmnopqrstuvwxyz123456\u0026#39;, \u0026#39;sendmail\u0026#39; =\u0026gt; \u0026#39;/usr/sbin/sendmail -bs\u0026#39;, \u0026#39;pretend\u0026#39; =\u0026gt; false, ];  測試使用 Gmail 寄信 Mail::raw(\u0026#39;測試使用 Laravel 5 的 Gmail 寄信服務\u0026#39;, function($message) { $message-\u0026gt;to(\u0026#39;kejyun@example.com\u0026#39;); }); 這樣我們就可以使用 Gmail 去當作我們的郵件寄送服務了！！！\n參考資料  Attempting to get Email to work in Laravel 5 郵件 - Laravel.tw  "
},
{
	"uri": "https://laravel5-book.kejyun.com/services/errors-logs/errors-show-exception-in-cli/",
	"title": "在單元測試顯示例外",
	"tags": [],
	"description": "",
	"content": "在單元測試顯示例外（Show Exception in CLI） 在 Laravel 5 做單元測試時，使用 try catch 丟出例外時，Laravel 5 會自動地將例外的錯誤訊息處理成網頁的樣式呈現，這樣的好處是在網頁中做操作發生例外狀況時，可以直接看到例外的錯誤訊息，但是在寫單元測試 (Unit test) 時，他只會將這些錯誤先記錄在 log 檔案裡面（storage/log/laravel-yyyy-mm-dd.log），我們要看到這些錯誤的狀況必須要再另開終端機去執行 php artisan tail 去觀看這些 例外 Log 的狀況，這樣在做測試的時候是相當麻煩的。\n在 Laravel 5 中所有的例外（Exception）都會被丟到 app/Exceptions/Handler.php 中的 render() 去處理\n\u0026lt;?php // app/Exceptions/Handler.php  class Handler extends ExceptionHandler { /** * Render an exception into an HTTP response. * 將例外錯誤轉為 HTTP 回應 * * @param \\Illuminate\\Http\\Request $request * @param \\Exception $e * @return \\Illuminate\\Http\\Response */ public function render($request, Exception $e) { return parent::render($request, $e); } }  我們如果需要在 CLI 就顯示例外錯誤訊息的話，必須修改 render() 函式，而我想要保有原本在網頁做除錯的彈性，所以我在環境變數 .env 檔案中加入例外處理（Exception）顯示的開關，當有設定開啟時，才直接顯示例外訊息。\n\u0026lt;!-- .env --\u0026gt; EXCEPTION_DISPLAY_SWITCH=true .env 設定好後，就將 render() 函式修改為這樣\n\u0026lt;?php // app/Exceptions/Handler.php  class Handler extends ExceptionHandler { /** * Render an exception into an HTTP response. * 將例外錯誤轉為 HTTP 回應 * * @param \\Illuminate\\Http\\Request $request * @param \\Exception $e * @return \\Illuminate\\Http\\Response */ public function render($request, Exception $e) { // 預設不直接顯示例外訊息  $exception_display_switch = env(\u0026#39;EXCEPTION_DISPLAY_SWITCH\u0026#39;, false); if ($exception_display_switch) { throw $e; } return parent::render($request, $e); } } 這樣設定完後，也保留原本系統處理例外狀況的彈性，也可以讓我在單元測試（Unit test）中可以正常的去顯示例外訊息了！！\n參考資料  錯誤與日誌 - laravel.tw how do I create custom error page in laravel 5 Laravel 5.0 - Custom Error Pages  "
},
{
	"uri": "https://laravel5-book.kejyun.com/services/helpers/custom-helpers/",
	"title": "自定義輔助方法",
	"tags": [],
	"description": "",
	"content": "自定義輔助方法 Laravel 中有提供許多的輔助方法（Helpers），但有時候我們會想要自訂自己的輔助方法，我們可以這樣做\n加入自定義引用的 Helpers.php 檔案到 /app/Support/Helpers/Helpers.php 路徑下 \u0026lt;?php // /app/Support/Helpers/Helpers.php  // Helper 檔案路徑 $helpers = [ \u0026#39;CustomHelper.php\u0026#39; ]; // 載入 Helper 檔案 foreach ($helpers as $helperFileName) { include __DIR__ . \u0026#39;/\u0026#39; .$helperFileName; } 以後若有其他的 Helper 需要加入，僅需要加到 Helpers.php 檔案中的 $helpers 變數當中即可\n在 composer.json 中自動載入加入該 Helper.php /*composer.json*/ { \u0026#34;autoload\u0026#34;: { \u0026#34;classmap\u0026#34;: [ \u0026#34;database\u0026#34; ], \u0026#34;psr-4\u0026#34;: { \u0026#34;App\\\\\u0026#34;: \u0026#34;app/\u0026#34; }, \u0026#34;files\u0026#34;: [ \u0026#34;app/Support/Helpers/helpers.php\u0026#34; ] } }  重新編譯 autoload.php $ composer dump-autoload Generating autoload files 這樣我們就可以自動的載入我們自定義的 Helper 函式了！！\n Best practices for custom helpers on Laravel 5  "
},
{
	"uri": "https://laravel5-book.kejyun.com/view/view-intro/",
	"title": "視圖介紹",
	"tags": [],
	"description": "",
	"content": "視圖介紹 這裏會介紹如何在 Laravel 5 處理視圖（View）\nLaravel 的視圖是放在 resource/views 目錄內\n建立共用的視圖 我們網頁常常會出現 header 跟 footer 在不同的視圖中為相同的狀況，唯一有變的只有中間的內容隨著不同的請求而有變動，如果有這樣的設計需求，我們可以替所有視圖建立共用的視圖，假設我們把這個共用的視圖放在 resource/view/app.blade.php 下，其內容可能是：\n\u0026lt;!-- resource/view/app.blade.php --\u0026gt; \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;zh-TW\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;我的網站\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#34;container\u0026#34;\u0026gt; @yield(\u0026#39;content\u0026#39;) \u0026lt;/div\u0026gt; @yield(\u0026#39;other_info\u0026#39;) \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 如果我們要顯示文章的資訊在 content 中，文章的說明在 other_info 中，我們可以在 blade 中這樣設定：\n\u0026lt;!-- resource/view/article.blade.php --\u0026gt; @extend(\u0026#39;app\u0026#39;) @section(\u0026#39;content\u0026#39;) \u0026lt;h1\u0026gt;文章標題\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt; Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. \u0026lt;/p\u0026gt; @stop @section(\u0026#39;other_info\u0026#39;) 其他資訊 @stop 這樣 Laravel 就會幫我們把相對應的資訊塞到 app.blade.php 當中相對應的位置\n 引入共用的視圖 假如我們要在特定的某幾頁使用 Facebook 留言板，像是：\n\u0026lt;div id=\u0026#34;fb-root\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;script\u0026gt;(function(d, s, id) { var js, fjs = d.getElementsByTagName(s)[0]; if (d.getElementById(id)) return; js = d.createElement(s); js.id = id; js.src = \u0026#34;//connect.facebook.net/zh_TW/sdk.js#xfbml=1\u0026amp;version=v2.3\u0026amp;appId=12345566\u0026#34;; fjs.parentNode.insertBefore(js, fjs); }(document, \u0026#39;script\u0026#39;, \u0026#39;facebook-jssdk\u0026#39;));\u0026lt;/script\u0026gt; \u0026lt;div class=\u0026#34;fb-comments\u0026#34; data-href=\u0026#34;http://laravel5-book.kejyun.com/\u0026#34; data-numposts=\u0026#34;5\u0026#34; data-colorscheme=\u0026#34;light\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; 但我們不想要這些相同的程式碼片段散落在各個不同的視圖中，我們可以把它整理在 resource/views/vendor/_fbcomment.blade.php 當中\n然後在文章視圖當中我們就可以這樣去引入 Facebook 留言板：\n\u0026lt;!-- resource/view/article.blade.php --\u0026gt; @extend(\u0026#39;app\u0026#39;) @section(\u0026#39;content\u0026#39;) \u0026lt;h1\u0026gt;文章標題\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt; Lorem ipsum dolor sit amet \u0026lt;/p\u0026gt; @include(\u0026#39;vendor/_fbcomment\u0026#39;) @include(\u0026#39;vendor._fbcomment\u0026#39;) @stop @section(\u0026#39;other_info\u0026#39;) 其他資訊 @stop  傳入變數到引用的視圖當中 在我們新增與編輯文章的視圖當中，幾乎所有的視圖都是一樣的，不一樣的地方可能只有「表單處理的 action 不同（create \u0026amp; edit）」、「送出的按鈕文字不同（新增違章 \u0026amp; 編輯文章）」\n但我們還是希望兩個視圖能夠一起被引用，把其他不同的地方當作變數傳入，就可以達到視圖重構的效果，避免類似的視圖重複出現在不同地方，像是：\n\u0026lt;!-- resource/view/partials/articles/_form.blade.php --\u0026gt; {!! Form::label(\u0026#39;title\u0026#39;,\u0026#39;標題\u0026#39;) !!} {!! Form::text(\u0026#39;title\u0026#39;, null) !!} {!! Form::label(\u0026#39;content\u0026#39;,\u0026#39;內文\u0026#39;) !!} {!! Form::text(\u0026#39;content\u0026#39;, null) !!} {!! Form::submit($submitButtonText) !!} 當我們要引用表單的視圖，則必須把按鈕的文字傳送給表單，像是：\n\u0026lt;!-- resource/view/article.blade.php --\u0026gt; @extend(\u0026#39;app\u0026#39;) @section(\u0026#39;content\u0026#39;) @include(\u0026#39;partials/articles/_form\u0026#39;, [\u0026#39;submitButtonText\u0026#39; =\u0026gt; \u0026#39;新增文章\u0026#39;]) @include(\u0026#39;partials/articles/_form\u0026#39;, [\u0026#39;submitButtonText\u0026#39; =\u0026gt; \u0026#39;編輯文章\u0026#39;]) @stop @section(\u0026#39;other_info\u0026#39;) 其他資訊 @stop 備註 引用或載入視圖路徑 在使用 blade 中的 @extend() 或 @include() 函數，他所參照的視圖相對位置是從 resource/views/ 開始的\n所以如果你的視圖是放在 resource/views/partials/other.blade.php 中，你要引用或載入的話則可以用 . 或 / 去指定相對的視圖位置，像是：\n\u0026lt;!-- 引用 --\u0026gt; @extend(\u0026#39;partials._other\u0026#39;) @extend(\u0026#39;partials/_other\u0026#39;) \u0026lt;!-- 載入 --\u0026gt; @include(\u0026#39;partials._other\u0026#39;) @include(\u0026#39;partials/_other\u0026#39;)  設計模式 樣板檔案名稱 通常若不是完整的視圖，僅是部分的視圖，通常會將檔案名稱最前面加上底線 _，用來告知團隊程式設計師這個 blade 視圖不是完整的視圖\n參考資訊  View Partials and Form Reuse - Laracasts  "
},
{
	"uri": "https://laravel5-book.kejyun.com/services/auth/auth-login/",
	"title": "認證登入",
	"tags": [],
	"description": "",
	"content": "認證登入（Auth） 設定 Laravel 內建認證的設定檔案放在 config/auth.php 中，預設會使用 App\\User 的類別當作驗證的 Eloquent 模型\n[ \u0026#39;model\u0026#39; =\u0026gt; App\\User::class, ] 如果我們用Model 模型設計模式去設計我們的程式架構，我們 User 實體模型的程式可能會放在 App\\KeJyunApp\\User\\Entities\\User.php 中，這時候我們的認證模型設定可以設定成像這樣（依照命名空間去設定）：\n[ \u0026#39;model\u0026#39; =\u0026gt; App\\KeJyunApp\\User\\Entities\\User::class, ] 這樣 Laravel 內建的認證就可以用我們指定的實體模型去進行認證了！！\n 手動登入認證 Laravel 內建的認證使用 Auth 去進行身份認證，如果我們要用使用者的「email」及「密碼」做登入，我們的登入程式可能會像：\n$email = \u0026#39;kejyun@gmail.com\u0026#39;; $password = \u0026#39;1234\u0026#39;; if (Auth::attempt([\u0026#39;email\u0026#39; =\u0026gt; $email, \u0026#39;password\u0026#39; =\u0026gt; $password])) { // 已登入成功！！！ } 使用 Auth:attempt() 的方式去驗證使用者時，Laravel 會先到 User 資料表透過 Email 抓取使用者的資料，產生出來的 SQL 會像：\nSELECT * FROM \u0026#34;users\u0026#34; WHERE \u0026#34;email\u0026#34; = \u0026#39;kejyun@gmail.com\u0026#39; LIMIT 1; 抓取完使用者之料後再將 password 欄位用雜湊的 Hash::check() 方式去比對驗證密碼是否正確，再記錄使用者的 SESSION 資料\n如果我們的使用者有限制啟用帳號的人才可以登入，所以我們要用使用者的「email」、「密碼」及「啟用狀態」做登入，我們的登入程式可能會像：\n$email = \u0026#39;kejyun@gmail.com\u0026#39;; $password = \u0026#39;1234\u0026#39;; $status = \u0026#39;active\u0026#39;; if (Auth::attempt([\u0026#39;email\u0026#39; =\u0026gt; $email, \u0026#39;password\u0026#39; =\u0026gt; $password, \u0026#39;status\u0026#39; =\u0026gt; $status])) { // 已登入成功！！！ } 產生出來的 SQL 會像：\nSELECT * FROM \u0026#34;users\u0026#34; WHERE \u0026#34;email\u0026#34; = \u0026#39;kejyun@gmail.com\u0026#39; AND \u0026#34;status\u0026#34; = \u0026#39;active\u0026#39; LIMIT 1; Laravel 一樣是先抓取使用者資料後，再做密碼驗證的動作！\n使用記住我的方式登入 $email = \u0026#39;kejyun@gmail.com\u0026#39;; $password = \u0026#39;1234\u0026#39;; $remember_me = true; if (Auth::attempt([\u0026#39;email\u0026#39; =\u0026gt; $email, \u0026#39;password\u0026#39; =\u0026gt; $password], $remember_me)) { // 已使用記住我登入成功！！！ }  如果你是自己建立自己 User 資料表的 Migration，記得在自己的 Migration 中加入 $table-\u0026gt;rememberToken(); 的設定，加入 remember_token 欄位，這個欄位可以讓 Laravel 使用 記住我 的方式去記住使用者的 session token\n 判斷使用者是否已登入 我們可以使用 Auth::check() 的方式，判斷使用者是否已登入\nif (Auth::check()) { // 已登入 }  取得登入使用者的物件 $user = Auth::user(); // KeJyun var_dump($user-\u0026gt;name); 使用特定使用者的 ID 登入 $user_id = \u0026#39;1\u0026#39;; Auth::loginUsingId($user_id); 登出 Auth::logout();  登出其他裝置使用者  Laravel 5.6 or higher\n Auth::logoutOtherDevices($password); 參考資料  認證 - Laravel.tw Authentication - Laravel - The PHP Framework For Web Artisans  "
},
{
	"uri": "https://laravel5-book.kejyun.com/services/auth/",
	"title": "認證（Auth）",
	"tags": [],
	"description": "",
	"content": "這裏介紹一些 Laravel 提供的認證（Auth）功能\n"
},
{
	"uri": "https://laravel5-book.kejyun.com/services/queue/queue-intro/",
	"title": "隊列介紹",
	"tags": [],
	"description": "",
	"content": "隊列介紹 Laravel 隊列的設定檔在 config/queue.php，在這裡你可以設定你想要用什麼樣的隊列（Queue）服務去執行你的隊列，而 Laravel 預設有支援 database、Beanstalkd、IronMQ、Amazon SQS、Redis 這幾種隊列的服務。\n我們通常會將一些需要花比較久時間處理的工作丟給隊列去背景執行，讓使用者能夠快速的的到網站的回應，像是我們在寄送帳號認證信件時，因為透過郵件伺服器去寄送可能會花費比較久的時間，所以我們會將這類的工作丟到隊列去執行，所以使用者的認證信件就會延遲的發送到他們的信箱，但是使用者在瀏覽網站時卻可以有更好的體驗！\n 指令 在使用 Queue 去幫我們做工作的時候，我們在系統背景需要執行傾聽 Queue 是否有工作的指令，像是 php artisan queue:listen，這樣 Queue 中有新工作需要做，才能夠正常的去執行。\n$ php artisan queue:listen 執行 Queue 指令有一些相關的參數，可以依照自己的環境去調校\n$php artisan queue:listen [--queue[=\u0026quot;...\u0026quot;]] [--delay[=\u0026quot;...\u0026quot;]] [--memory[=\u0026quot;...\u0026quot;]] [--timeout[=\u0026quot;...\u0026quot;]] [--sleep[=\u0026quot;...\u0026quot;]] [--tries[=\u0026quot;...”]]    參數 說明 指令     queue 設定優先執行的工作順序 php artisan queue:listen --queue=high,low   delay 在執行的工作發生錯誤時，要延遲多久重新執行（單位：秒），預設 0 秒 php artisan queue:listen --delay=10   memory 執行工作最多能夠使用的記憶體上限（單位：MB），預設 128 MB php artisan queue:listen --memory=1024   timeout 執行的工作做長執行的時間是多長（單位：秒），預設 60 秒 php artisan queue:listen --timeout=3600   sleep 在沒有找到可以做的工作時，需要間隔多少秒再去檢查有無新的工作（單位：秒），預設 3 秒 php artisan queue:listen --sleep=10   tries 工作執行失敗時，最多重新嘗試執行幾次（單位：次數），預設 0，不重新嘗試 php artisan queue:listen --tries=3    "
},
{
	"uri": "https://laravel5-book.kejyun.com/environment/dot-env-file/",
	"title": ".env 檔案",
	"tags": [],
	"description": "",
	"content": ".env 檔案 Laravel 4 .env 檔案 在 Laravel 4 的時候，我們通常會在 /bootstrap/start.php 中，去設定我們的 hostname 是屬於哪一種開發環境，再針對不同的開發環境有不同的設定檔（.env.*.php）\n\u0026lt;?php $env = $app-\u0026gt;detectEnvironment(array( \u0026#39;local\u0026#39; =\u0026gt; array( \u0026#39;KeJyun-Macbook\u0026#39; ), \u0026#39;dev\u0026#39; =\u0026gt; [], \u0026#39;testing\u0026#39; =\u0026gt; [], \u0026#39;staging\u0026#39; =\u0026gt; [], )); .env.*.php 設定檔通常放在根目錄下，這些檔案不會在版本控制當中\napp/ bootstrap/ public/ vendor/ .env.php .env.local.php .env.dev.php .env.testing.php .env.staging.php 在 Laravel 4 .env 設定檔案長的會像是這樣：\n\u0026lt;?php return [ \u0026#39;DB_USERNAME\u0026#39; =\u0026gt; \u0026#39;root\u0026#39;, \u0026#39;DB_PASSWORD\u0026#39; =\u0026gt; \u0026#39;password\u0026#39;, ]; 我們的 config 檔案就可以使用 $_ENV 去讀取當前環境的設定檔資料\n\u0026lt;?php $_ENV[\u0026#39;DB_USERNAME\u0026#39;] $_ENV[\u0026#39;DB_PASSWORD\u0026#39;]  Laravel 5 .env 檔案 在 Laravel 5 使用 .env 檔案的方式跟 Laravel 4 有很大的不同，在 Laravel 5 中就只有 .env 與 .env.example 這兩個檔案而已，.env 檔案不會在版本控制中，.env.example 則會在版本控制中\n自己可以根據自己的環境設定目前的 .env 狀況，而 .env.example 則是可以讓大家參考 .env 的範例用的，自己根據自己目前的環境設定是什麼樣到開發還境（local、dev、stage、production\u0026hellip;etc）。\n在 Laravel 5 .env 設定檔案長的會像是這樣：\nAPP_ENV=local APP_DEBUG=true APP_KEY=VDqhX1LiHKEReHH16YNEzxUZziOdZVtT DB_HOST=localhost DB_DATABASE=homestead DB_USERNAME=homestead DB_PASSWORD=secret CACHE_DRIVER=file SESSION_DRIVER=file 然後我們在設定檔中，我們可以使用 env() 函式去取得我們設定檔案中的設定，會設定像是這樣的設定\n// config/app.php [ \u0026#39;debug\u0026#39; =\u0026gt; env(\u0026#39;APP_DEBUG\u0026#39;, false), ] // config/database.php [ \u0026#39;pgsql\u0026#39; =\u0026gt; [ \u0026#39;driver\u0026#39; =\u0026gt; \u0026#39;pgsql\u0026#39;, \u0026#39;host\u0026#39; =\u0026gt; env(\u0026#39;DB_HOST\u0026#39;, \u0026#39;localhost\u0026#39;), \u0026#39;database\u0026#39; =\u0026gt; env(\u0026#39;DB_DATABASE\u0026#39;, \u0026#39;forge\u0026#39;), \u0026#39;username\u0026#39; =\u0026gt; env(\u0026#39;DB_USERNAME\u0026#39;, \u0026#39;forge\u0026#39;), \u0026#39;password\u0026#39; =\u0026gt; env(\u0026#39;DB_PASSWORD\u0026#39;, \u0026#39;\u0026#39;), \u0026#39;charset\u0026#39; =\u0026gt; \u0026#39;utf8\u0026#39;, \u0026#39;prefix\u0026#39; =\u0026gt; \u0026#39;\u0026#39;, \u0026#39;schema\u0026#39; =\u0026gt; \u0026#39;public\u0026#39;, ], ] env() 中第一個參數是 .env 檔案中的設定鍵值名稱，第二個參數是預設值，若讀取不到環境設定鍵值則會使用預設值\n這樣在每個人的開發環境只要去管理自己的 .env 檔案就好，不需要像 Laravel 4 需要在 config 資料夾中建立各種環境變數設定的資料夾，像是 config/local/database.php 或 config/stage/database.php。\n參考資料  Environments and Configuration - Laravel 5 Fundamentals  "
},
{
	"uri": "https://laravel5-book.kejyun.com/api/api-intro/",
	"title": "API throttle middleware",
	"tags": [],
	"description": "",
	"content": "API throttle middleware 在 app/Http/Kernel.php 檔案中會看到 api 的 $middlewareGroups 有一個 'throttle:60,1'，這邊的意思是 每 1 分鐘同個 ip 可以請求 60 次，可以針對你的 API 請求需求，去限制 API 請求次數，已保護你的 API 不會被隨意無限制的存取\n\u0026lt;?php namespace App\\Http; use Illuminate\\Foundation\\Http\\Kernel as HttpKernel; class Kernel extends HttpKernel { /** * The application\u0026#39;s route middleware groups. * * @var array */ protected $middlewareGroups = [ \u0026#39;web\u0026#39; =\u0026gt; [ \\App\\Http\\Middleware\\EncryptCookies::class, \\Illuminate\\Cookie\\Middleware\\AddQueuedCookiesToResponse::class, \\Illuminate\\Session\\Middleware\\StartSession::class, // \\Illuminate\\Session\\Middleware\\AuthenticateSession::class,  \\Illuminate\\View\\Middleware\\ShareErrorsFromSession::class, \\App\\Http\\Middleware\\VerifyCsrfToken::class, \\Illuminate\\Routing\\Middleware\\SubstituteBindings::class, ], \u0026#39;api\u0026#39; =\u0026gt; [ \u0026#39;throttle:60,1\u0026#39;, \u0026#39;bindings\u0026#39;, ], ]; } 詳情可以參考 Illuminate\\Routing\\Middleware\\ThrottleRequests 檔案\n Laravel 5.6 throttle middleware 在 Laravel 5.6 的 throttle middleware 提供動態的限制使用者存取數量，在 Middleware 可以設定 throttle:rate_limit,1\nRoute:middleware(\u0026#39;throttle:rate_limit,1\u0026#39;)-\u0026gt;get(\u0026#39;/\u0026#39;, function(){ return \u0026#39;Test Rate Limit\u0026#39;; }); 然後在使用者 Model 加入 public $rate_limit 屬性，限制使用者最多可以存取多少次\n\u0026lt;?php namespace App; use Illuminate\\Notifications\\Notifiable; use Illuminate\\Contracts\\Auth\\MustVerifyEmail; use Illuminate\\Foundation\\Auth\\User as Authenticatable; class User extends Authenticatable { use Notifiable; public $rate_limit = 3; } 這樣登入的使用者就可以按照設定的次數限制去限制請求次數了\n 沒有登入的使用者，將限制只能存取一次\n "
},
{
	"uri": "https://laravel5-book.kejyun.com/database/model/eloquent-config/",
	"title": "Eloquent 設定",
	"tags": [],
	"description": "",
	"content": "Eloquent 設定 設定可以大量新增的欄位 Eloquent 為了避免特定欄位（像是 id, created_at \u0026hellip;）被使用者故意傳入大量（Mass）資料去進行修改，所以 Eloquent 會自動保護欄位不被大量異動（Mass Assignment），像是：\n// 新增 App\\User::Create([ \u0026#39;first_name\u0026#39;=\u0026gt; \u0026#39;KeJyun\u0026#39;, \u0026#39;last_name\u0026#39; =\u0026gt; \u0026#39;Hong\u0026#39;, \u0026#39;email\u0026#39; =\u0026gt; \u0026#39;kejyun@gmail.com\u0026#39;, ]); // 更新 $user = App\\User::find(\u0026#39;1\u0026#39;); $user-\u0026gt;update([ \u0026#39;email\u0026#39; =\u0026gt; \u0026#39;hello@gmail.com\u0026#39;, ]); 如果我們需要異動這些欄位，需要在 Model 裡面設定 $fillable 的欄位，這樣就可以使用大量資料的方式，去新增或異動資料表欄位資料。\nclass User extends Model { protected $fillable = [\u0026#39;first_name\u0026#39;, \u0026#39;last_name\u0026#39;, \u0026#39;email\u0026#39;]; }  設定需要被保護的欄位 我們也可以使用 $guarded 指定某些欄位需要被保護，能被大量新增或異動\nclass User extends Model { protected $guarded = [\u0026#39;id\u0026#39;, \u0026#39;password\u0026#39;]; } 我們也可以設定所有欄位都不能被大量新增或異動\nclass User extends Model { protected $guarded = [\u0026#39;*\u0026#39;]; } 設定欄位為時間資料欄位 我們可以很簡單的使用 Carbon 去做時間的資料處理，預設的 created_at 與 updated_at 是使用 Carbon 當作儲存的資料格式\n$article = \\App\\Article::find(1); // created_at = \u0026#39;2014-03-18 23:59:59\u0026#39; // 取得 created_at 年份 // 2014 dd($article-\u0026gt;created_at-\u0026gt;year); // 取得 created_at 月份 // 03 dd($article-\u0026gt;created_at-\u0026gt;month); // 取得 created_at 6 天後的時間 // 2014-03-24 23:59:59 dd($article-\u0026gt;created_at-\u0026gt;addDays(6)); // 取得 created_at 格式化為 Y-m 的時間 // 2014-03 dd($article-\u0026gt;created_at-\u0026gt;format(\u0026#39;Y-m\u0026#39;)); // 取得 created_at 格式化為人可閱讀的時間 // 1 year ago dd($article-\u0026gt;created_at-\u0026gt;diffForHumans()); 若我們自己新增了時間的欄位像是 published_at，則 Model 沒有自動將此欄位的資料設為 Carbon 的資料格式\n我們可以在 Model 中設定 $dates 欄位中的資料，可以指定欄位資料格式為 Carbon 的資料格式\nclass Article extends Model { protected $dates = [\u0026#39;published_at\u0026#39;]; }  設定資料庫的連線 我們也可以使用 $connection 指定模型需要用哪個資料庫連線去做查詢\nclass User extends Model { protected $connection = \u0026#39;custom_connection_name\u0026#39;; } 設定主鍵不要自動新增 使用 Eloquent 去建立模型（Model）時，預設主鍵會使用自動新增（Auto-increment）的方式去新增，若要自行定義主鍵時，則要設定 $incrementing 為 false，將自動新增的功能關閉～\nclass User extends Model { public $incrementing = false; } 設定主鍵欄位名稱 使用 Eloquent 去建立模型（Model）時，預設會將主鍵欄位名稱設為 id，若有需要異動主鍵欄位名稱的話，則要設定 $primaryKey 變數，設為自行定義的欄位名稱\nclass User extends Model { protected $primaryKey = \u0026#39;my_primary_column_name\u0026#39;; } 參考資料  Eloquent 101 - Laracast Dates, Mutators, and Scopes - Laracast Eloquent ORM - Laravel.tw  "
},
{
	"uri": "https://laravel5-book.kejyun.com/database/migration/",
	"title": "Migration (遷移)",
	"tags": [],
	"description": "",
	"content": "Migration 這裏會介紹如何在 Laravel 5 使用 Migration 管理資料庫\nMigration 指令 建立 Migration $ php artisan make:migration create_users_table --create=\u0026#34;users\u0026#34; Migration 建立之後的檔案會放在 database/migrations/2015_04_11_134630_create_users_table.php\n Migration 檔案最前面的日期會依照你建立 Migration 的時間自動產生，所以每個人看到的檔名皆會不同 在後面加了 --create 的參數可以告訴 Migration，我們要做建立 user 資料表的動作，檔案內容會像這樣：\n \u0026lt;?php // database/migrations/2015_04_11_134630_create_users_table.php  use Illuminate\\Database\\Schema\\Blueprint; use Illuminate\\Database\\Migrations\\Migration; class CreateUsersTable extends Migration { /** * Run the migrations. * * @return void */ㄒ public function up() { Schema::create(\u0026#39;users\u0026#39;, function(Blueprint $table) { $table-\u0026gt;increments(\u0026#39;id\u0026#39;); $table-\u0026gt;timestamp(); }); } /** * Reverse the migrations. * * @return void */ public function down() { Schema::drop(\u0026#39;users\u0026#39;); } }  異動資料表欄位資料 如果我們要在 users 資料表中加欄位（或是其他改變資料表結構），我們可以用這樣的指令去建立 Migration\n$ php artisan make:migration add_email_to_users_table --table=\u0026#34;users\u0026#34;  在後面加了 --table 的參數可以告訴 Migration，我們要做異動 user 資料表的動作，檔案內容會像這樣：\n \u0026lt;?php // database/migrations/2015_04_12_154720_add_email_to_users_table.php  use Illuminate\\Database\\Schema\\Blueprint; use Illuminate\\Database\\Migrations\\Migration; class AddEmailToUsersTable extends Migration { /** * Run the migrations. * * @return void */ public function up() { Schema::table(\u0026#39;users\u0026#39;, function(Blueprint $table) { $table-\u0026gt;string(\u0026#39;email\u0026#39;, 180); }); } /** * Reverse the migrations. * * @return void */ public function down() { Schema::table(\u0026#39;users\u0026#39;, function(Blueprint $table) { $table-\u0026gt;dropColumn(\u0026#39;email\u0026#39;); }); } }  原先的建立資料表會用 Schema::create()，而異動資料表則會用 Schema::table() 去做異動\n  列出目前所有 Migration 狀態 $ php artisan migrate:status 執行 Migration $ php artisan migrate 恢復上一版本的 Migration $ php artisan migrate:rollback 清除所有版本的 Migration $ php artisan migrate:reset 清除所有版本的 Migration 並重新執行 $ php artisan migrate:refresh  備註 欄位異動 若做欄位異動 Migration 後需要 rollback，若丟出例外錯誤時，則使用 composer 安裝 doctrine/dbal 後即可解決 rollback 的問題\n$ composer require doctrine/dbal 安全性 在剛開始開發產品的時候，有時候資料表有做小小的修改或異動，為了圖方便，我們常常會使用 migrate:reset 或 migrate:refresh 去清空我們的資料，重建資料表。\n但如果產品已經上線了，這個指令就會是一個非常危險的指令，企業產品最重要的資產就是資料，這個指令會導致所有的資料都被清除，所以請上線後小心謹慎去使用。\n參考資料  遷移和資料填充 - Laravel.tw Migrations - Laracasts  "
},
{
	"uri": "https://laravel5-book.kejyun.com/design-pattern/service-container/",
	"title": "服務容器（Service Container）",
	"tags": [],
	"description": "",
	"content": "服務容器（Service Container） Laravel 的服務容器就像 IoC 容器一樣，可以讓你很容易的反轉控制物件\n假如我們沒有注入類別去進行反轉控制，則我們每次使用 Mail 類別去寄送郵件時都要去 new 它，如果這個 Mail 類別在裡面是會被很頻繁的使用時，這樣會讓我們很惱人。\n// 通知類別 class Notification { // 通知會員有新訊息 public function noticeNewMessage() { $mail = new Mail(); $mail-\u0026gt;send(); } // 通知會員有新文章 public function noticeNewArticle() { $mail = new Mail(); $mail-\u0026gt;send(); } } 為了能夠讓通知類別 Notification 能夠隨時取用 Mail 類別，我們會希望將此類別直接注入，讓通知類別可以直接去進行反轉控制。\n在我們使用反轉控制（IoC）時，我們時常需要在建構子 __construct() 或方法 function() 中注入需要反轉控制的類別，讓被注入的類別可以直接控制其物件，就像：\n// 通知類別 class Notification { public $mail; public function __construct (Mail $mail) { $this-\u0026gt;mail = $mail; } // 通知會員有新訊息 public function noticeNewMessage() { $this-\u0026gt;mail-\u0026gt;send(); } // 通知會員有新文章 public function noticeNewArticle() { $this-\u0026gt;mail-\u0026gt;send(); } } 我們在通知類別 Notification 建構子中注入 Mail 類別給內部 mail 變數，之後要使用此 Mail 類別時，就直接使用傳送信件 send() 的功能即可。\n我們也可以在個別的函式中分別注入需要反轉控制的類別，就像：\n // 通知類別 class Notification { // 通知會員有新訊息 public function noticeNewMessage(Mail $mail) { $mail-\u0026gt;send(); } // 通知會員有新文章 public function noticeNewArticle(Mail $mail) { $mail-\u0026gt;send(); } } 但是在 Laravel 4 要注入類別之前，必須先對類別名稱對 app 進行綁定，讓 Laravel 4 認得這個要注入的類別是什麼物件\nApp::bind(\u0026#39;Mail\u0026#39;, function($app) { return new SomeEmailService; }); 但是在 Laravel 5 除了可以用這樣手動綁定類別的方式，也有提供強大的自動綁定功能，你不需要在 app 內事先定義所有的類別，當 Laravel 5 在 app 內找不到該類別的時候，就會自動找所有引入（include）的類別中有沒有此類別，自動進行注入綁定！\n參考資料  The Service Container - Laracast 服務容器 - Laravel.tw IoC 容器 Dependency Injection with Laravel’s IoC  "
},
{
	"uri": "https://laravel5-book.kejyun.com/environment/",
	"title": "環境",
	"tags": [],
	"description": "",
	"content": "這裏會介紹一些 Laravel 會用到的機器環境相關問題\n"
},
{
	"uri": "https://laravel5-book.kejyun.com/database/qa/cannot-get-querylog/",
	"title": "資料庫常見問題：無法取得查詢 Log",
	"tags": [],
	"description": "",
	"content": "資料庫常見問題：無法取得查詢 Log 在 Laravel 4 為了要確定下的 SQL 語法有符合我們預期，我們常常在做完資料庫查詢後，使用 DB::getQueryLog(); 去取得做資料庫查詢的 Qeury Log，但因為 Laravel 會把這些 Log 都記錄在記憶體中，如果做了大量的新增的查詢，記憶體會使用過多可能會造成系統 Crash。\n所以 Laravel 5 預設把記錄 Query Log 的機制關閉，若需要做 Query Debug，需要自行打開 Qeury Log 功能\n\u0026lt;?php // 啟用 Query Log 功能 DB::connection()-\u0026gt;enableQueryLog(); 這樣我們就可以使用 DB::getQueryLog(); 去取得做資料庫查詢的 Qeury Log 摟！！ 要得到執行過的查詢紀錄陣列，你可以使用 getQueryLog 方法：\n\u0026lt;?php // 取得資料庫查詢的 Qeury Log $queries = DB::getQueryLog(); var_dump($queries); 參考資料  資料庫使用基礎 查詢日誌記錄 - Laravel.tw How to get the query executed in Laravel 5 ? DB::getQueryLog returning empty array  "
},
{
	"uri": "https://laravel5-book.kejyun.com/hosting/php/hosting-install-php7/",
	"title": "安裝 php 7",
	"tags": [],
	"description": "",
	"content": "安裝 php 7 加入 php 7 套件資源庫 目前（2016/03） php7 沒有在 Ubuntu 的預設套件庫中，所以若要使用 php7 的話，則必須要自行加入此套件庫，這樣我們才能在 Ubuntu 安裝 php7\nsudo add-apt-repository ppa:ondrej/php 更新套件資源庫 加入新的套件資源庫後，必須進行系統套件清單更新，才能夠讀取到新的套件設定\nsudo apt-get update  安裝 php7 套件  php7.0-fpm ： Nginx 解析 php 檔案的工具 php7.0-mysql ： 連線 mysql php7.0-mcrypt ： Laravel 加解密工具   其他套件是我在 Laravel 專案中需要的套件，可以依照自己需求去進行安裝\n sudo apt-get install php7.0-fpm php7.0-mysql php7.0-mcrypt php7.0-gd php7.0-cli php7.0-curl php7.0-imap 設定 php7.0-fpm 若有需要變更任何 php7.0-fpm 的任何設定，可以修改下列設定檔案\nsudo vim /etc/php/7.0/fpm/pool.d/www.conf 像是您如果想要把異動傾聽 php 的執行擁有者變更為 kejyun，您可以做以下的設定\nuser = kejyun group = kejyun listen.owner = kejyun listen.group = kejyun listen.mode = 0660  設定 Nginx php 檔案處理方式 設定虛擬主機 Virtualhost 設定檔 sudo vim /etc/nginx/sites-available/kejyun.dev 設定 php 檔案處理方式 server { # ... # 設定 php 檔案處理方式 location ~ \\.php$ { fastcgi_split_path_info ^(.+\\.php)(/.+)$; fastcgi_pass unix:/var/run/php/php7.0-fpm.sock; fastcgi_index index.php; include fastcgi_params; fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; fastcgi_intercept_errors off; fastcgi_buffer_size 16k; fastcgi_buffers 4 16k; fastcgi_connect_timeout 300; fastcgi_send_timeout 300; fastcgi_read_timeout 300; } # ... } 重新啟動 php 如果有異動任何 php7.0-fpm 的任何設定的話，必須要將 php7.0-fpm 服務重新啟動，才能夠讀取到新的設定\nsudo service php7.0-fpm restart 這樣我們就完成 php7 的設定了！\n參考資料  Install PHP 7 on Ubuntu 14.04 | Enrico Zimuel kasparsd/php-7-debian: Install PHP 7 on Debian/Ubuntu Installing php7-fpm with phpredis extension on Ubuntu 14.04  "
},
{
	"uri": "https://laravel5-book.kejyun.com/resource/resource-community/",
	"title": "社群",
	"tags": [],
	"description": "",
	"content": "社群 Facebook  PHP 台灣 Laravel 台灣 PHP 也有 Day Laravel (@laravelphp) | Twitter Laravel - 社群 - Google+ Laravel - Reddit Laravel - Quora Laravel - Facebook Laravel - LinkedIn  共享文件  歡迎來到 Laravel 台灣 - laraveltw.hackpad.com  活動  Laravel 台灣 - KKTIX   論壇  SitePoint PHP Scotch - Laravel http://www.codetutorial.io/tag/laravel/ Forum - Laravel.IO Laravel Forum - Laracssts The Laravel Podcast Laravel Slack laravel/laravel - Gitter  Blog  MattStauffer.co CodeHeaps Vluzrmos Graham Campbell  "
},
{
	"uri": "https://laravel5-book.kejyun.com/qa/qa-change-app-directory-name-cause-view-can-not-readable/",
	"title": "變更專案目錄名稱導致 View 無法讀取",
	"tags": [],
	"description": "",
	"content": "變更專案目錄名稱導致 View 無法讀取 在想要變更原先 Laravel 5 的專案目錄時，Laravel 5 會告訴你你沒辦法讀取到 view 的目錄，看了錯誤的訊息發現這個 view 的目錄是在原先舊專案的目錄名稱下\n錯誤訊息長得像這樣：\nInvalidArgumentException in FileViewFinder.php line 137: View [welcome] not found.  這個原因是 Laravel 5 會將設定檔作快取存下來到 bootstrap/cache/config.php 目錄下面，而這個快取的檔案是原本舊專案的設定，所以我們必須要清除這個快取，才可以讓 Laravel 5 可以讀取到新的設定，這時候我們可以在 artisan 下這些指令，清除原先專案的快取設定：\n$ php artisan config:clear $ php artisan view:clear 執行清除這些快取資料後，我們就可以正常的的獨到新專案目錄下的 view 資料摟！\n"
},
{
	"uri": "https://laravel5-book.kejyun.com/editor/tips/editor-tips-recognize-facade-class/",
	"title": "讓編輯器識別 Facade 類別",
	"tags": [],
	"description": "",
	"content": "Call to undefined method getCachedCompilePath() 我在使用 Laravel 5.0.x 時，使用 composer update 去更新目前的套件時，跳出了這樣的訊息：\n（PS:也有人在執行 php artisan clear-compiled 出現這樣的狀況）\n PHP Fatal error: Call to undefined method Illuminate\\Foundation\\Application::getCachedCompilePath()\n 這個是因為 Laravel 5 在執行時會把整個 Framework 編譯到 storage/framework/compiled.php，若這個檔案已產生，Laravel 5 在更新套件時執行一些相關 Laravel 的功能時，會預設執行 compiled.php 檔案中的類別函式，而更新的檔案中有 getCachedCompilePath() 這個方法，所以呼叫時 Laravel 會在舊的 compiled.php 找不到這個方法\n解決方式\n直接把 storage/framework/compiled.php 刪除即可，Laravel 5 會自動重新產生這個 compiled.php 檔案！\n 參考資料  RuntimeException on fresh install  "
},
{
	"uri": "https://laravel5-book.kejyun.com/package/debug/package-debug-artisan-tail/",
	"title": "Artisan tail",
	"tags": [],
	"description": "",
	"content": "Artisan tail 在 Laravel 4 我們常常用 php artisan tail 去即時顯示系統的 Log，以便我們進行除錯，但在 Laravel 5 預設是將這個套件拿到的，所以如果我們要繼續使用的話，必須要手動的將套件加回去。\n安裝 Laravel tail 套件 首先在命令列執行 composer require spatie/laravel-tail 安裝 tail 套件\n$ composer require spatie/laravel-tail 接著在 config/app.php 檔案中的 providers 加入 tail ServiceProvider\n// config/app.php \u0026#39;providers\u0026#39; =\u0026gt; [ ... \u0026#39;Spatie\\Tail\\TailServiceProvider\u0026#39;, ... ]; 安裝完畢之後就可以繼續使用 php artisan tail 去觀看你的 Log 了！\n$ php artisan tail  tail 遠端主機 Log 檔 tail 命令可以讓我們即時觀看遠端的 Log 檔案，我們只要將遠端主機的相關設定加入即可，可以使用下列指令建立 config/tail.php 檔案\n$ php artisan vendor:publish --provider=\u0026#34;Spatie\\Tail\\TailServiceProvider\u0026#34; 之後只要在 tail 指令後面加入要觀看的主機名稱，即可立即觀看該主機的 Log 檔摟\n$ php artisan tail production 參考資料  The missing tail command for Laravel 5  "
},
{
	"uri": "https://laravel5-book.kejyun.com/package/auth/oauth/package-auth-oauth2-client-credentials/",
	"title": "Client Credentials",
	"tags": [],
	"description": "",
	"content": "OAuth2 Client Credentials 設定 config 在 config/oauth2.php 檔案中加入下列設定，並設定你的 token 存活時間(access_token_ttl)，單位時間為秒\nreturn [ \u0026#39;grant_types\u0026#39; =\u0026gt; [ \u0026#39;client_credentials\u0026#39; =\u0026gt; [ \u0026#39;class\u0026#39; =\u0026gt; \u0026#39;\\League\\OAuth2\\Server\\Grant\\ClientCredentialsGrant\u0026#39;, \u0026#39;access_token_ttl\u0026#39; =\u0026gt; 3600 ] ] ]; 取得 Access token 在我們取得 Access token 的資料欄位中填入下列欄位\n   欄位名稱 資料     grant_types client_credentials   client_id KeJyun   client_secret KeJyunSecret     client_id 與 client_secret 為在 OAuth 套件說明頁 建立的\n 送出到我們設定的 /oauth/access_token 路由後，我們就可以直接取得 access_token，並回傳此 token 失效的時間 expires_in 為我們設定的 access_token_ttl\n 相關資料表 OAuth2 會將 token 記錄在 oauth_access_tokens 資料表，並將關聯的使用者記錄在 oauth_sessions 資料表，在 oauth_sessions 中的 owner_id 則為 oauth_clients 資料表中 Client 的 id\n參考資料  Client Credentials  "
},
{
	"uri": "https://laravel5-book.kejyun.com/package/auth/jwt/",
	"title": "JWT",
	"tags": [],
	"description": "",
	"content": "JWT（JSON Web Token）Authentication 使用套件  套件名稱：tymondesigns/jwt-auth\n  套件版本：0.5.*\n 安裝 使用 composer 安裝套件 在 composer.json 加入 \u0026quot;\u0026quot;tymon/jwt-auth\u0026quot;: \u0026quot;0.5.*\u0026quot; 並執行 composer update 安裝套件\n/*composer.json*/ \u0026#34;require\u0026#34;: { \u0026#34;tymon/jwt-auth\u0026#34;: \u0026#34;0.5.*\u0026#34; } $ composer update 設定套件 開啟config/app.php檔案，並將系列套件資訊加入 providers 與 aliases\n\u0026#39;providers\u0026#39; =\u0026gt; [ Tymon\\JWTAuth\\Providers\\JWTAuthServiceProvider::class, ], \u0026#39;aliases\u0026#39;=\u0026gt;[ \u0026#39;JWTAuth\u0026#39; =\u0026gt; Tymon\\JWTAuth\\Facades\\JWTAuth::class, \u0026#39;JWTFactory\u0026#39; =\u0026gt; Tymon\\JWTAuth\\Facades\\JWTFactory::class, ] 產生套件設定 執行 php artisan vendor:publish --provider=\u0026quot;Tymon\\JWTAuth\\Providers\\JWTAuthServiceProvider\u0026quot; 複製套件的 config/jwt.php 設定檔到你應用程式的設定檔目錄\n$ php artisan vendor:publish --provider=\u0026#34;Tymon\\JWTAuth\\Providers\\JWTAuthServiceProvider\u0026#34;  產生 JWT Secret Key 每個應用應該有屬於自己的 JWT Secret Key 用於加密並驗證你的資料\n$ php artisan jwt:generate 產生的 JWT Secret Key 會設定在 config/jwt.php 中的 secret 中\n// config/jwt.php [ \u0026#39;secret\u0026#39; =\u0026gt; env(\u0026#39;JWT_SECRET\u0026#39;, \u0026#39;your_personal_jwt_secret_key\u0026#39;) ] 設定檔說明    參數名稱 說明 資料類型 預設值     secret 密鑰 String 無   ttl JWT token 有效時間（單位：分鐘） Integer 60   refresh_ttl token 允許重新更新時間（單位：分鐘） Integer 20160（2 週）   algo 加密演算法 String HS256   user 使用者模型類別位置 String App\\User   identifier 使用者資料主鍵欄位 String id   required_claims 必須包含在 token payload 的資料，若驗證時無這些資料則會拋出 TokenInvalidException 例外 Array [\u0026lsquo;iss\u0026rsquo;, \u0026lsquo;iat\u0026rsquo;, \u0026lsquo;exp\u0026rsquo;, \u0026lsquo;nbf\u0026rsquo;, \u0026lsquo;sub\u0026rsquo;, \u0026lsquo;jti\u0026rsquo;]   blacklist_enabled 開啟黑名單清單 Boolean true   providers.user 找尋使用者類別物件 String Tymon\\JWTAuth\\Providers\\ User\\EloquentUserAdapter   providers.jwt 用於加解密 JWT Token 的類別物件 String Tymon\\JWTAuth\\Providers\\ JWT\\NamshiAdapter   providers.auth 取得受驗證使用者的類別物件 Closure Function Tymon\\JWTAuth\\Providers\\ Auth\\IlluminateAuthAdapter   providers.storage 儲存黑名單 token 的快取物件，token 將會儲存到它過期為止 Closure Function Tymon\\JWTAuth\\Providers\\ Storage\\IlluminateCacheAdapter     JWT Claims Registered Claims\n   參數名稱 說明     iss 發行 JWT token 的人   sub 主題 JWT token   iat 發行 JWT token 的時間，可以判斷這個 token 產生出來多久了   exp 有效期限，一定要大於現在時間   nbf 生效時間，在這個時間以前，無法處理此 JWT token   jti JWT 唯一識別值，防止 JWT 被重複使用    Public Claims\n我們公開放到 JWT token 的資訊\n參考資料  tymondesigns/jwt-auth - Installation tymondesigns/jwt-auth - Configuration Node 實作 jwt 驗證 API | DEVLOG of andyyou Json Web Tokens: Introduction Where to Store Your JWTs - Cookies vs HTML5 Web Storage UniSharp/laravel-jwt: Auth guard and middleware for jwt refesh in a concurrency use case, e.g. single page web applications.  "
},
{
	"uri": "https://laravel5-book.kejyun.com/package/image/package-image-screenshot-other/",
	"title": "screenshot 截圖",
	"tags": [],
	"description": "",
	"content": "screenshot 截圖  PHP PhantomJS  Website Screenshots with Laravel - YouTube GitHub - thedevdojo/website-screenshot-with-laravel: Learn how to create a screenshot of a website with Laravel   GitHub - spatie/browsershot: Convert html to an image, pdf or string  spatie/browsershot - Packagist   GitHub - stefanzweifel/screeenly: 📸 Screenshot as a Service  screeenly Use the API · stefanzweifel/screeenly Wiki · GitHub 中文會 GG    "
},
{
	"uri": "https://laravel5-book.kejyun.com/package/image/",
	"title": "圖片",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://laravel5-book.kejyun.com/package/image/intervention/package-image-intervention-process/",
	"title": "圖片處理",
	"tags": [],
	"description": "",
	"content": "Intervention Image 圖片處理 原始圖片 resize() 圖片縮放 // 建立圖片實例 $img = Image::make(\u0026#39;public/foo.jpg\u0026#39;); // 重新調整圖片寬高至 300x200 $img-\u0026gt;resize(300, 100); resize to 300x100\n// 寬度調整至 300px，高度不變 $img-\u0026gt;resize(300, null); resize to 300xnull\n// 高度調整至 200px，寬度不變 $img-\u0026gt;resize(null, 100); resize to nullx100\n// 固定寬 300px，高度等比例縮放 $img-\u0026gt;resize(300, null, function ($constraint) { $constraint-\u0026gt;aspectRatio(); }); resize to 300xnull aspectRatio\n// 固定高 100px，寬度等比例縮放 width) $img-\u0026gt;resize(null, 100, function ($constraint) { // 等比例縮放 $constraint-\u0026gt;aspectRatio(); }); resize to nullx100 aspectRatio\n// 固定寬 300px, 高 100px，寬度等比例縮放 $img-\u0026gt;resize(300, 100, function ($constraint) { // 等比例縮放：若兩個寬高比例與原圖不符的話，會以最短邊去做等比例縮放 $constraint-\u0026gt;aspectRatio(); }); resize to 300x100 aspectRatio\n$img-\u0026gt;resize(null, 1000, function ($constraint) { // 等比例縮放 $constraint-\u0026gt;aspectRatio(); // 若圖片較小，不需要將圖片放大 $constraint-\u0026gt;upsize(); }); resize to nullx1000 aspectRatio \u0026amp; upsize\n crop() 圖片裁切 // 建立圖片實例 $img = Image::make(\u0026#39;public/foo.jpg\u0026#39;); // 裁切圖片寬度 100px，高度 300px，從圖片中間為中心點開始裁切 $img-\u0026gt;crop(100, 300); crop(100, 300);\"\n$img-\u0026gt;crop(100, 300);\n// 從圖片左上角為原點 0,0，然後裁切圖片寬度 100px，高度 300px $img-\u0026gt;crop(100, 300, 0, 0); crop(100, 300);\"\n$img-\u0026gt;crop(100, 300);\n// 從圖片左上角為原點，往右位移 35px，往下位移 75px，然後裁切圖片寬度 100px，高度 300px $img-\u0026gt;crop(100, 300, 35, 75); crop(100, 300, 35, 75);\"\n$img-\u0026gt;crop(100, 300, 35, 75);\nblur() 模糊 可以指定模糊的強度，數字介於 0~100 之間，預設為 1\n// 建立圖片實例 $img = Image::make(\u0026#39;public/foo.jpg\u0026#39;); // 輕微的模糊圖片（預設強度 1） $img-\u0026gt;blur(); blur();\"\n$img-\u0026gt;blur();\n// 指定模糊的強度 $img-\u0026gt;blur(15); blur(15);\"\n$img-\u0026gt;blur(15);\n brightness() 亮度 可以指定增加或減少圖片的亮度多少，亮度數值介於 -100 ~ 100 之間\n// 建立圖片實例 $img = Image::make(\u0026#39;public/foo.jpg\u0026#39;); // 增加圖片亮度 35 $img-\u0026gt;brightness(35); brightness(35);\"\n$img-\u0026gt;brightness(35);\n// 減低圖片亮度 -5，再減低亮度 -25 $img-\u0026gt;brightness(-5)-\u0026gt;brightness(-25); brightness(-5)-brightness(-25);\"\n$img-\u0026gt;brightness(-5)-\u0026gt;brightness(-25);\ncolorize() 顏色增減 顏色可以帶入 red, green, blue 三種顏色增減的量，範圍為 -100~100，0 則為不變\n// 建立圖片實例 $img = Image::make(\u0026#39;public/foo.jpg\u0026#39;); // 紅色 -100 $img-\u0026gt;colorize(-100, 0, 0); colorize(-100, 0, 0);\"\n$img-\u0026gt;colorize(-100, 0, 0);\n// 紅色 100 $img-\u0026gt;colorize(100, 0, 0); colorize(100, 0, 0);\"\n$img-\u0026gt;colorize(100, 0, 0);\n// 綠色 30 $img-\u0026gt;colorize(0, 30, 0); colorize(0, 30, 0);\"\n$img-\u0026gt;colorize(0, 30, 0);\n contrast() 對比 對比的數字介於 -100~100\n// 建立圖片實例 $img = Image::make(\u0026#39;public/foo.jpg\u0026#39;); // 增加對比 65 $img-\u0026gt;contrast(65); contrast(65);\"\n$img-\u0026gt;contrast(65);\n// 增加對比 100 $img-\u0026gt;contrast(100); contrast(100);\"\n$img-\u0026gt;contrast(100);\n// 減少對比 35 $img-\u0026gt;contrast(-35); contrast(-35);\"\n$img-\u0026gt;contrast(-35);\nencode() 編碼  jpg — return JPEG encoded image data png — return Portable Network Graphics (PNG) encoded image data gif — return Graphics Interchange Format (GIF) encoded image data tif — return Tagged Image File Format (TIFF) encoded image data bmp — return Bitmap (BMP) encoded image data ico — return ICO encoded image data psd — return Photoshop Document (PSD) encoded image data webp — return WebP encoded image data data-url — encode current image data in data URI scheme (RFC 2397)  // 將 png 圖片轉為 jpg，並使用 quality 75 的圖片 $jpg = (string) Image::make(\u0026#39;public/foo.png\u0026#39;)-\u0026gt;encode(\u0026#39;jpg\u0026#39;, 75); // 將 png 圖片轉為網址 base64 的圖片 $data = (string) Image::make(\u0026#39;public/bar.png\u0026#39;)-\u0026gt;encode(\u0026#39;data-url\u0026#39;);  flip() 翻轉 // 建立圖片實例 $img = Image::make(\u0026#39;public/foo.jpg\u0026#39;); // 垂直翻轉 $img-\u0026gt;flip(\u0026#39;v\u0026#39;); flip(\u0026lsquo;v\u0026rsquo;);\"\n$img-\u0026gt;flip(\u0026lsquo;v\u0026rsquo;);\n// 水平翻轉 $img-\u0026gt;flip(\u0026#39;h\u0026#39;); flip(\u0026lsquo;h\u0026rsquo;);\"\n$img-\u0026gt;flip(\u0026lsquo;h\u0026rsquo;);\n// 水平+垂直翻轉 $img-\u0026gt;flip(\u0026#39;h\u0026#39;)-\u0026gt;flip(\u0026#39;v\u0026#39;); flip(\u0026lsquo;h\u0026rsquo;)-flip(\u0026lsquo;v\u0026rsquo;);\"\n$img-\u0026gt;flip(\u0026lsquo;h\u0026rsquo;)-\u0026gt;flip(\u0026lsquo;v\u0026rsquo;);\nfit() 裁切(crop) + 圖片縮放(resize) // 建立圖片實例 $img = Image::make(\u0026#39;public/foo.jpg\u0026#39;); // 圖片固定圖片比例，縮放至 300x100，並將將超過 300x100 的部分裁切掉 $img-\u0026gt;fit(300,100); fit(300,100);\"\n$img-\u0026gt;fit(300,100);\n// 圖片使用 300x300 的 1:1 比例，將圖片填滿 $img-\u0026gt;fit(300); $img-\u0026gt;fit(300,300); fit(300);\"\n$img-\u0026gt;fit(300);\n// 圖片固定圖片比例，縮放至 1200x1000，並將將超過 1200x1000 的部分裁切掉，且避免圖片放大超過原本圖片尺寸 $img-\u0026gt;fit(1200, 1000, function ($constraint) { // 避免圖片放大超過原本尺寸 $constraint-\u0026gt;upsize(); }); fit(1200, 1000); upsize()\"\n$img-\u0026gt;fit(1200, 1000); upsize()\n gamma() Gamma 校正 // 建立圖片實例 $img = Image::make(\u0026#39;public/foo.jpg\u0026#39;); // Gamma 校正 1.6 $img-\u0026gt;gamma(1.6); gamma(1.6);\"\n$img-\u0026gt;gamma(1.6);\n// Gamma 校正 1/2.2 $img-\u0026gt;gamma(1 / 2.2); gamma(1 / 2.2);\"\n$img-\u0026gt;gamma(1 / 2.2);\ngreyscale() 灰階 // 建立圖片實例 $img = Image::make(\u0026#39;public/foo.jpg\u0026#39;); // 灰階 $img-\u0026gt;greyscale(); greyscale();\"\n$img-\u0026gt;greyscale();\n heighten() 重新縮放圖片，以圖片高度為主，等比例縮放 // 圖片高度縮放至 100px，並依照原本圖片比例縮放 $img = Image::make(\u0026#39;public/foo.jpg\u0026#39;)-\u0026gt;heighten(100); heighten(100);\"\n$img-\u0026gt;heighten(100);\n// 圖片高度縮放至 1000px，並依照原本圖片比例縮放，不將原本圖片放大 $img = Image::make(\u0026#39;public/foo.jpg\u0026#39;)-\u0026gt;heighten(1000, function ($constraint) { // 若圖片較小，不需要將圖片放大 $constraint-\u0026gt;upsize(); }); heighten(1000); upsize()\"\n$img-\u0026gt;heighten(1000); upsize()\nwiden() 重新縮放圖片，以圖片寬度為主，等比例縮放 // 圖片寬度縮放至 100px，並依照原本圖片比例縮放 $img = Image::make(\u0026#39;public/foo.jpg\u0026#39;)-\u0026gt;widen(100); widen(100);\"\n$img-\u0026gt;widen(100);\n// 圖片寬度縮放至 1000px，並依照原本圖片比例縮放，不將原本圖片放大 $img = Image::make(\u0026#39;public/foo.jpg\u0026#39;)-\u0026gt;widen(1000, function ($constraint) { $constraint-\u0026gt;upsize(); }); widen(1000); upsize()\"\n$img-\u0026gt;widen(1000); upsize()\n insert() 插入浮水印圖片 // 建立圖片實例 $img = Image::make(\u0026#39;public/foo.jpg\u0026#39;); // 直接插入圖片，以左上角為起點開始插入圖片 $img-\u0026gt;insert(\u0026#39;public/copyright.png\u0026#39;); insert(\u0026lsquo;public/copyright.png\u0026rsquo;);\"\n$img-\u0026gt;insert(\u0026lsquo;public/copyright.png\u0026rsquo;);\n// 插入圖片至中央 $watermark = Image::make(\u0026#39;public/watermark.png\u0026#39;); $img-\u0026gt;insert($watermark, \u0026#39;center\u0026#39;); insert($watermark, \u0026lsquo;center\u0026rsquo;);\"\n$img-\u0026gt;insert($watermark, \u0026lsquo;center\u0026rsquo;);\n// 插入圖片，從右下角起點，往左 10px，往上 50px $watermark = Image::make(\u0026#39;public/watermark.png\u0026#39;); $img-\u0026gt;insert(\u0026#39;public/watermark.png\u0026#39;, \u0026#39;bottom-right\u0026#39;, 10, 50); insert(\u0026lsquo;public/watermark.png\u0026rsquo;, \u0026lsquo;bottom-right\u0026rsquo;, 10, 50);\"\n$img-\u0026gt;insert(\u0026lsquo;public/watermark.png\u0026rsquo;, \u0026lsquo;bottom-right\u0026rsquo;, 10, 50);\ninvert() 反轉顏色 // 反轉圖片顏色 $img = Image::make(\u0026#39;public/foo.jpg\u0026#39;)-\u0026gt;invert(); invert();\"\n$img-\u0026gt;invert();\n limitColors() 限制顯示顏色數量 // 建立圖片實例 $img = Image::make(\u0026#39;public/foo.png\u0026#39;); // 限制顏色數量為 100 $img-\u0026gt;limitColors(100); limitColors(100);\"\n$img-\u0026gt;limitColors(100);\n// 限制顏色數量為 30 $img-\u0026gt;limitColors(30); limitColors(30);\"\n$img-\u0026gt;limitColors(30);\nline() 畫線  必須要使用 Imagick 函式庫\n // 建立圖片實例 $img = Image::make(\u0026#39;public/foo.png\u0026#39;); // 畫一條 5px 的紅線，從座標 (10,10) 到 (195, 195) $img-\u0026gt;line(10, 10, 195, 195, function ($draw) { $draw-\u0026gt;color(\u0026#39;#f00\u0026#39;); $draw-\u0026gt;width(5); }); line(10, 10, 195, 195) color #f00 width5\"\n$img-\u0026gt;line(10, 10, 195, 195) color #f00 width5\n mask() 遮罩 // 建立圖片實例 $img = Image::make(\u0026#39;public/foo.jpg\u0026#39;); // 建立圖片遮罩，有顏色的部分會為遮罩 $img-\u0026gt;mask(\u0026#39;public/mask.png\u0026#39;); mask(\u0026lsquo;public/mask.png\u0026rsquo;);\"\n$img-\u0026gt;mask(\u0026lsquo;public/mask.png\u0026rsquo;);\n// 建立圖片遮罩，有顏色且不為透明的部分會為遮罩 $img-\u0026gt;mask(\u0026#39;public/alpha.png\u0026#39;, true); mask(\u0026lsquo;public/alpha.png\u0026rsquo;, true);\"\n$img-\u0026gt;mask(\u0026lsquo;public/alpha.png\u0026rsquo;, true);\npixelate() 將圖片指定像素寬度像素化 // 建立圖片實例 $img = Image::make(\u0026#39;public/foo.jpg\u0026#39;); // 像素化效果:5px $img-\u0026gt;pixelate(5); pixelate(5);\"\n$img-\u0026gt;pixelate(5);\n// 像素化效果:12px $img-\u0026gt;pixelate(12); pixelate(12);\"\n$img-\u0026gt;pixelate(12);\n// 像素化效果:30px $img-\u0026gt;pixelate(30); pixelate(30);\"\n$img-\u0026gt;pixelate(30);\n rotate() 旋轉圖片 // 建立圖片實例 $img = Image::make(\u0026#39;public/foo.jpg\u0026#39;); // 順時針旋轉圖圖片 45\u0026#39; $img-\u0026gt;rotate(-45); rotate(-45);\"\n$img-\u0026gt;rotate(-45);\nsave() 儲存圖片 第一個參數是檔案路徑，第二個參數是圖片品質，數值介於 0~100\n// 建立圖片實例 $img = Image::make(\u0026#39;public/foo.jpg\u0026#39;); // 儲存圖片，使用 60 品質的分數去儲存 $img-\u0026gt;save(\u0026#39;public/bar.jpg\u0026#39;, 60); // 儲存相同的圖片 $img-\u0026gt;save(\u0026#39;public/baz.jpg\u0026#39;); // 儲存 png 格式的圖片 $img-\u0026gt;save(\u0026#39;public/bar.png\u0026#39;); sharpen() 銳利度 銳利度數值介於 0~100\n// 建立圖片實例 $img = Image::make(\u0026#39;public/foo.jpg\u0026#39;); // 銳利度 15 $img-\u0026gt;sharpen(15); sharpen(15);\"\n$img-\u0026gt;sharpen(15);\n// 銳利度 70 $img-\u0026gt;sharpen(70); sharpen(70);\"\n$img-\u0026gt;sharpen(70);\n"
},
{
	"uri": "https://laravel5-book.kejyun.com/http/request/request-cookie/",
	"title": "Cookie",
	"tags": [],
	"description": "",
	"content": "Cookie 這裏會介紹如何在 Laravel 5 驗證 HTTP 請求的資料\n建立新的請求驗證 如果我們有文章（Article）的模型，我們在每次請求過程中想要驗證傳入的資料，我們可以使用系列指令建立要驗證的請求：\n$ php artisan make:request CreateArticleRequest 請求驗證的檔案會被建立在 app\\Http\\Requests 目錄下，建立的檔案內容如下\n\u0026lt;?php namespace App\\Http\\Requests; // app\\Http\\Requests\\CreateArticleRequest.php use App\\Http\\Requests\\Request; class CreateArticleRequest extends Request { /** * Determine if the user is authorized to make this request. * 驗證使用者是否要登入狀態 * * @return bool */ public function authorize() { return true; } /** * Get the validation rules that apply to the request. * 驗證請求的資料規則 * * @return array */ public function rules() { return [ // 使用 | 設定驗證規則  \u0026#39;title\u0026#39; =\u0026gt; \u0026#39;required|min:3\u0026#39;, \u0026#39;body\u0026#39; =\u0026gt; \u0026#39;required|min:30\u0026#39;, // 使用陣列設定驗證規則  \u0026#39;published_at\u0026#39; =\u0026gt; [ \u0026#39;required\u0026#39;, \u0026#39;date\u0026#39;, ], ]; } } 在驗證請求的 CreateArticleRequest 中的 rules() 函式，除了僅回傳驗證規則外，你也可以判斷不同的狀況去加入不同的規則再回傳，像是：\n\u0026lt;?php namespace App\\Http\\Requests; // app\\Http\\Requests\\CreateArticleRequest.php use App\\Http\\Requests\\Request; class CreateArticleRequest extends Request { public function rules() { $rules = [ // 使用 | 設定驗證規則  \u0026#39;title\u0026#39; =\u0026gt; \u0026#39;required|min:3\u0026#39;, \u0026#39;body\u0026#39; =\u0026gt; \u0026#39;required|min:30\u0026#39;, // 使用陣列設定驗證規則  \u0026#39;published_at\u0026#39; =\u0026gt; [ \u0026#39;required\u0026#39;, \u0026#39;date\u0026#39;, ], ]; // 其他條件判斷  if ($condition) { $rules[\u0026#39;something_else\u0026#39;] = \u0026#39;required\u0026#39;; } return $rules; } }  指定 Controller 函式處理指定的請求驗證 在我們使用 Controller 去處理請求時，我們可以再傳入變數內設定要怎麼處理請求：\nclass ArticleController extends Controller { // 新增文章 public function store(App\\Http\\Requests\\CreateArticleRequest $request) { Article::create(Request:all()); // OR // Article::create($request-\u0026gt;all()); return redirect(\u0026#39;articles\u0026#39;); } } 這樣設定之後，所有的 HTTP 請求的 Input 資料都會經過 App\\Http\\Requests\\CreateArticleRequest 驗證，如果有經過驗證才會繼續執行後面的新增文章動作，否則的話則會丟出驗證錯誤的物件到原頁面。\n驗證錯誤訊息 這裏要注意到，視圖（View）的每一頁 Laravel 都會將驗證錯誤物件（Illuminate\\Support\\ViewErrorBag）包成 $errors 變數，所以你可以在每一頁去印出 $errors 值，$errors 變數儲存的是任何資料驗證錯誤的結果\n判斷是否有任何的錯誤並顯示錯誤訊息\n// 任一 blade 視圖（View）皆可以接收此錯誤變數 @if($errors-\u0026gt;any()) // 有錯誤訊息 \u0026lt;ul\u0026gt; $foreach ($errors-\u0026gt;all() as $error) \u0026lt;li\u0026gt;{{ $error }}\u0026lt;/li\u0026gt; @endforeach \u0026lt;/ul\u0026gt; @endif  使用 Controller 內建的 validate 驗證請求的資料 除了建立驗證 Request 物件，也可以直接使用 Controller 內建的 validate 去驗證請求\n如果不想要使用內建處理 HttpResponseException 的例外，你也可以自己 try catch 並自己處理例外狀況\nclass ArticleController extends Controller { // 新增文章 public function store(Requests $request) { try { $this-\u0026gt;validate($request, [ \u0026#39;title\u0026#39; =\u0026gt; \u0026#39;required|min:3\u0026#39;, \u0026#39;body\u0026#39; =\u0026gt; \u0026#39;required|min:30\u0026#39;, \u0026#39;published_at\u0026#39; =\u0026gt; \u0026#39;required|date\u0026#39;, ]); } catch (Exception $e) { // 自己處理例外狀況 } Article::create(Request:all()); // OR // Article::create($request-\u0026gt;all()); return redirect(\u0026#39;articles\u0026#39;); } }  使用者資料 取得 User Agent、Referrer\n\u0026lt;?php // User Agent request()-\u0026gt;server(\u0026#39;HTTP_USER_AGENT\u0026#39;); // Referrer request()-\u0026gt;server(\u0026#39;HTTP_REFERER\u0026#39;) 參考資料  Form Requests and Controller Validation - Laracasts  !INCLUDE \u0026ldquo;../../kejyun/book/laravel-5-for-beginner.md\u0026rdquo;\n"
},
{
	"uri": "https://laravel5-book.kejyun.com/services/unit-test/unit-test-ajax-request-json-response/",
	"title": "Ajax Request &amp; JSON Response",
	"tags": [],
	"description": "",
	"content": "Ajax Request \u0026amp; JSON Response 在 Unit test 需要模擬 Ajax 請求時，可以在 $server 參數設定下列設定\n$server = [ 'HTTP_X-Requested-With' =\u0026gt; 'XMLHttpRequest', // Ajax Request 'HTTP_ACCEPT'=\u0026gt; 'application/json', // 請求 JSON Response ]; \u0026lt;?php class ServerTest { public function testAjaxRequestAndJsonResponse() { $uri = \u0026#39;/test/ajax\u0026#39;; $server = [ \u0026#39;HTTP_X-Requested-With\u0026#39; =\u0026gt; \u0026#39;XMLHttpRequest\u0026#39;, // Ajax Request  \u0026#39;HTTP_ACCEPT\u0026#39;=\u0026gt; \u0026#39;application/json\u0026#39;, // 請求 JSON Response  ]; $res = $this-\u0026gt;call(\u0026#39;POST\u0026#39;, $uri, $parameters, $cookies, $files, $server); } }  當設定完 HTTP_X-Requested-With 為 XMLHttpRequest 時，Laravel 會把這個請求視為 Ajax 請求，所以在呼叫 request()-\u0026gt;ajax() 方法時會回傳 true\nrequest()-\u0026gt;ajax(); // true 當設定完 HTTP_ACCEPT 為 application/json 時，Laravel 會把這個請求需要回傳的資訊視為需要 JSON 格式資料，所以在呼叫 request()-\u0026gt;wantsJson() 方法時會回傳 true\nrequest()-\u0026gt;wantsJson(); // true 參考資料  How to simulate xmlHttpRequests in a laravel testcase? - Stack Overflow  "
},
{
	"uri": "https://laravel5-book.kejyun.com/services/queue/queue-database/",
	"title": "Database Queue",
	"tags": [],
	"description": "",
	"content": "資料庫隊列（Database Queue） 我們可以使用 database 的隊列設定，在自己的資料庫建立隊列資料表\n產生隊列資料表 我們可以使用 php artisan queue:table 指令去產生隊列的 Migration\n$ php artisan queue:table 所以執行命令後，你可以找到像是 database/migrations/2015_05_26_225627_create_queue_jobs_table.php 這樣的隊列 Migration 檔案\n Migration 檔名日期 2015_05_26_225627 每個人皆不同，會依照你建立當時的時間去產生\n 產生的隊列 Migration 會長的像這樣：\n\u0026lt;?php use Illuminate\\Database\\Schema\\Blueprint; use Illuminate\\Database\\Migrations\\Migration; class CreateQueueJobsTable extends Migration { /** * Run the migrations. * * @return void */ public function up() { Schema::create(\u0026#39;jobs\u0026#39;, function(Blueprint $table) { $table-\u0026gt;bigIncrements(\u0026#39;id\u0026#39;); $table-\u0026gt;string(\u0026#39;queue\u0026#39;); $table-\u0026gt;text(\u0026#39;payload\u0026#39;); $table-\u0026gt;tinyInteger(\u0026#39;attempts\u0026#39;)-\u0026gt;unsigned(); $table-\u0026gt;tinyInteger(\u0026#39;reserved\u0026#39;)-\u0026gt;unsigned(); $table-\u0026gt;unsignedInteger(\u0026#39;reserved_at\u0026#39;)-\u0026gt;nullable(); $table-\u0026gt;unsignedInteger(\u0026#39;available_at\u0026#39;); $table-\u0026gt;unsignedInteger(\u0026#39;created_at\u0026#39;); }); } /** * Reverse the migrations. * * @return void */ public function down() { Schema::drop(\u0026#39;jobs\u0026#39;); } }  建立隊列資料表 執行 php artisan migrate 將隊列資料表新增至資料庫\n設定隊列驅動 在 config/queue.php 檔案中設定資料庫隊列驅動設定，設定如下：\n// config/queue.php return [ \u0026#39;default\u0026#39; =\u0026gt; \u0026#39;database\u0026#39;, \u0026#39;connections\u0026#39; =\u0026gt; [ \u0026#39;database\u0026#39; =\u0026gt; [ \u0026#39;driver\u0026#39; =\u0026gt; \u0026#39;database\u0026#39;, \u0026#39;table\u0026#39; =\u0026gt; \u0026#39;jobs\u0026#39;, \u0026#39;queue\u0026#39; =\u0026gt; \u0026#39;default\u0026#39;, \u0026#39;expire\u0026#39; =\u0026gt; 60, \u0026#39;connection_name\u0026#39;=\u0026gt;\u0026#39;\u0026#39;, ], ], ]; 建立隊列工作 我們可以使用 \\Queue::push('App\\Commands\\SendEmail@fire', $queue_data); 的方法去新增要執行的隊列\n第一個參數是執行隊列需要呼叫的類別名稱位置（App\\Commands\\SendEmail）及方法（fire）\n類別名稱需要正確的指定類別的命名空間（namespace），可以指定這個隊列要執行的類別方法，只要將方法使用 @ 加在後方即可（@customMethod）\n若沒有指定用哪個方法，Laravel 預設會執行 fire 的類別方法（@fire）\n我們使用隊列來寄送 Email，設定隊列的方式大概像這樣：\n// 需要傳送給隊列處理的資料 $queue_data = [ \u0026#39;email\u0026#39; =\u0026gt; \u0026#39;kejyun@gmail.com\u0026#39;, \u0026#39;name\u0026#39; =\u0026gt; \u0026#39;KeJyun\u0026#39;, ]; // 建立隊列 $queue_id = \\Queue::push(\u0026#39;App\\Commands\\SendEmail@fire\u0026#39;, $queue_data); 在 App\\Commands\\Sendmail.php 檔案大概會像這樣：\n\u0026lt;?php namespace App\\Commands; class SendEmail { /** * 執行隊列 * * @return void */ public function fire($job, $data) { // 寄送 Email  \\Mail::send(\u0026#39;emails.welcome\u0026#39;, [], function($message) use ($data) { $message-\u0026gt;to($data[\u0026#39;email\u0026#39;], $data[\u0026#39;name\u0026#39;])-\u0026gt;subject(\u0026#39;歡迎使用 Laravel 5 資料庫隊列寄送 Email!!!\u0026#39;); }); // 執行成功，刪除隊列  $job-\u0026gt;delete(); } } fire 方法中的 $job 變數會接受該隊列的實例，$data 變數會接收建立隊列時傳入的資料\n像我要使用隊列寄送 Email，則會將使用者的相關資訊傳送到這個隊列來，讓隊列能正確的發送正確的 Email 資訊給使用者！\n在隊列執行完成無誤後，我們必須要使用 $job-\u0026gt;delete(); 將隊列資料刪除，若沒有刪除 Laravel 下次再出理到該資料時，則會視為隊列處理失敗，進而嘗試重新處理\n 監聽隊列工作 我們會在 shell 中執行 php artisan queue:listen 去持續的監聽隊列資料的狀況，若有新增隊列到資料表時，Laravel 則會開始處理隊列的資料\n$ php artisan queue:listen 也可以針對 queue 去設定相關參數及優先權\n$ php artisan artisan queue:work --queue=instant,high,medium,default,low --delay=1 --memory=512 --sleep=15 --tries=1 --env=dev --daemon 這樣我們就可以正常的使用隊列去幫我們寄信摟！！\n參考資料  隊列 - Laravel.tw Queues in Laravel with Redis  "
},
{
	"uri": "https://laravel5-book.kejyun.com/services/laravel-mix/laravel-mix-live-reload/",
	"title": "LiveReload",
	"tags": [],
	"description": "",
	"content": "LiveReload 使用 Live Reload 可以在我們異動 css 的時候，自動幫我們重新在瀏覽器重新刷新頁面，這樣我們在做畫面設計的時候，就可以更快的設計除錯\n 安裝 webpack-livereload-plugin  npm install webpack-livereload-plugin@1 --save-dev 設定 webpack.mix.js  var LiveReloadPlugin = require(\u0026#39;webpack-livereload-plugin\u0026#39;); // LiveReload 設定 mix.webpackConfig({ plugins: [ new LiveReloadPlugin() ] }); // 產生 sass 檔案 mix.sass(\u0026#39;public/assets/scss/app.scss\u0026#39;, \u0026#39;public/assets/css/\u0026#39;); 安裝 Chrome LiveReload 套件  在 LiveReload - Chrome 線上應用程式商店 安裝此套件\n設定 LiveReload 至 blade 樣板  @if(config('app.env') == 'local') \u0026lt;script src=\u0026quot;http://localhost:35729/livereload.js\u0026quot;\u0026gt;\u0026lt;/script\u0026gt; @endif 監控 LiveReload 運作  npm run watch 參考資料  LiveReload | Laravel Mix Documentation LiveReload - Chrome 線上應用程式商店 webpack-livereload-plugin/README.md at master · statianzo/webpack-livereload-plugin  "
},
{
	"uri": "https://laravel5-book.kejyun.com/http/route/",
	"title": "Route 路由",
	"tags": [],
	"description": "",
	"content": "這裏會介紹如何在 Laravel 處理 Route 路由。\n"
},
{
	"uri": "https://laravel5-book.kejyun.com/services/errors-logs/service/errors-log-service-sentry-io/",
	"title": "Sentry.io",
	"tags": [],
	"description": "",
	"content": "Sentry.io  紀錄 Laravel Exception\n 1.安裝套件\ncomposer require sentry/sentry-laravel 2.加入套件設定\n在 config/app.php 檔案中加入設定\n\u0026lt;?php // config/app.php return [ \u0026#39;providers\u0026#39; =\u0026gt; [ Sentry\\SentryLaravel\\SentryLaravelServiceProvider::class, ], \u0026#39;aliases\u0026#39; =\u0026gt; [ \u0026#39;Sentry\u0026#39; =\u0026gt; Sentry\\SentryLaravel\\SentryFacade::class, ], ] 3.錯誤處理加入 Sentry 設定\n在 config/app.php 檔案中加入設定\n\u0026lt;?php class Handler extends ExceptionHandler { public function report(Exception $e) { if (app()-\u0026gt;bound(\u0026#39;sentry\u0026#39;) \u0026amp;\u0026amp; $this-\u0026gt;shouldReport($e)) { app(\u0026#39;sentry\u0026#39;)-\u0026gt;captureException($e); } return parent::report($e); } }  4.發佈設定\nphp artisan vendor:publish --provider=\u0026#34;Sentry\\SentryLaravel\\SentryLaravelServiceProvider\u0026#34; 5.設定 .env 檔案\nSENTRY_LARAVEL_DSN=https://\u0026lt;SENTRY_DSN_URL\u0026gt; 參考資料  Sentry | Error Tracking Software — JavaScript, Python, PHP, Ruby, more  "
},
{
	"uri": "https://laravel5-book.kejyun.com/services/mail/mail-mailgun/",
	"title": "使用 Mailgun 寄信",
	"tags": [],
	"description": "",
	"content": "使用 Mailgun 寄信 Mailgun 對於初期的產品是一個不錯的郵件服務，每個月可以免費寄送 10000 封信，對於初期的應用應該是綽綽有餘，而且 Laravel 5 預設有支援 Mailgun 的服務，所以我們來介紹如何使用 Mailgun 寄信\n設定 config/mail.php  driver 設為 mailgun\n  host 設為 smtp.mailgun.org\n  port 設為 587\n  username 設為 postmaster@mailgun.kejyun.com，這個帳號可以登入後到 Domains 頁選擇你設定的 Domains，找到 Default SMTP Login 就可以看到這個帳號\n  password 設為你自己的密碼，Mailgun 顯次的欄位為 Default Password，密碼長度為 32 碼\n  pretend 設為 true，這樣才可以正常使用 Mailgun 寄送\n 設定完後會像這樣：\n// config/mail.php return [ \u0026#39;driver\u0026#39; =\u0026gt; \u0026#39;mailgun\u0026#39;, \u0026#39;host\u0026#39; =\u0026gt; \u0026#39;smtp.mailgun.org\u0026#39;, \u0026#39;port\u0026#39; =\u0026gt; 587, \u0026#39;from\u0026#39; =\u0026gt; [\u0026#39;address\u0026#39; =\u0026gt; \u0026#39;kejyun@example.com\u0026#39;, \u0026#39;name\u0026#39; =\u0026gt; \u0026#39;KeJyun\u0026#39;], \u0026#39;encryption\u0026#39; =\u0026gt; \u0026#39;tls\u0026#39;, \u0026#39;username\u0026#39; =\u0026gt;\u0026#39;postmaster@mailgun.kejyun.com\u0026#39;, \u0026#39;password\u0026#39; =\u0026gt; \u0026#39;abcdefghijklmnopqrstuvwxyz123456\u0026#39;, \u0026#39;sendmail\u0026#39; =\u0026gt; \u0026#39;/usr/sbin/sendmail -bs\u0026#39;, \u0026#39;pretend\u0026#39; =\u0026gt; false, ];  設定 config/services.php  domain 設定為你自己定義的 domain，若沒有自己定義 domain 的話，可以使用 Mailgun 替你產生的 domain，可以看看 Default SMTP Login 後面的 sandboxXXXXXX.mailgun.org，這個為 Mailgun 產生的 domain\n  secret 設為 Mailgun 提供的 API Key，會長的像 key-abcdefghijklmnopqrstuvwxyz123456\n 設定完後會像這樣：\n// config/services.php [ \u0026#39;mailgun\u0026#39; =\u0026gt; [ \u0026#39;domain\u0026#39; =\u0026gt; \u0026#39;mailgun.kejyun.com\u0026#39;, \u0026#39;secret\u0026#39; =\u0026gt; \u0026#39;key-abcdefghijklmnopqrstuvwxyz123456\u0026#39;, ], ]  測試使用 Mailgun 寄信 Mail::raw(\u0026#39;測試使用 Laravel 5 的 Mailgun 寄信服務\u0026#39;, function($message) { $message-\u0026gt;to(\u0026#39;kejyun@example.com\u0026#39;); }); 這樣我們就可以使用 Mailgun 去當作我們的郵件寄送服務了！！！\n參考資料  Mailgun Setting up Mailgun with Laravel 5 郵件 - Laravel.tw  "
},
{
	"uri": "https://laravel5-book.kejyun.com/view/view-inject-class/",
	"title": "將 Class 綁定到視圖",
	"tags": [],
	"description": "",
	"content": "將 Class 綁定到視圖 \u0026lt;?php namespace App; class Shop { // 顯示商店名稱  public function name() { return \u0026#39;KJ Shop\u0026#39;; } } View Composer View::composer(\u0026#39;shop\u0026#39;, function($view){ $view-\u0026gt;with(\u0026#39;shop\u0026#39;, app(\\App\\Shop::class)); }); Blade Inject @inject(\u0026#39;shop\u0026#39;, \\App\\Shop::class) \u0026lt;h1\u0026gt;{{ $shop-\u0026gt;name() }}\u0026lt;/h1\u0026gt; "
},
{
	"uri": "https://laravel5-book.kejyun.com/services/errors-logs/errors-log-level/",
	"title": "日誌記錄層級",
	"tags": [],
	"description": "",
	"content": "日誌記錄層級 在系統發生例外錯誤時，我們會希望紀錄當時的例外訊息，以便之後我我們好進行除錯，而 Log 紀錄的訊息會依照日期被放到像 storage/logs/laravel-2015-06-06.log 的地方\nLog 記錄在 Laravel 有七個級別：debug、info、notice、warning、error、critical 和 alert，紀錄的方式會像這樣：\nLog::debug(\u0026#39;=== Log 訊息 ===\u0026#39;); Log::info(\u0026#39;=== Log 訊息 ===\u0026#39;); Log::notice(\u0026#39;=== Log 訊息 ===\u0026#39;); Log::warning(\u0026#39;=== Log 訊息 ===\u0026#39;); Log::error(\u0026#39;=== Log 訊息 ===\u0026#39;); Log::critical(\u0026#39;=== Log 訊息 ===\u0026#39;); Log::alert(\u0026#39;=== Log 訊息 ===\u0026#39;); 他們在 Log 檔紀錄的樣子會像:\n[2015-06-06 16:22:00] testing.DEBUG: === Log 訊息 === [2015-06-06 16:22:00] testing.INFO: === Log 訊息 === [2015-06-06 16:22:00] testing.NOTICE: === Log 訊息 === [2015-06-06 16:22:00] testing.WARNING: === Log 訊息 === [2015-06-06 16:22:00] testing.ERROR: === Log 訊息 === [2015-06-06 16:22:00] testing.CRITICAL: === Log 訊息 === [2015-06-06 16:22:00] testing.ALERT: === Log 訊息 === 我們透過不同的記錄層級，讓我們容易找到層級比較嚴重的 Bug 先進行修復\n參考資料  錯誤與日誌 - Laravel.tw  "
},
{
	"uri": "https://laravel5-book.kejyun.com/services/auth/auth-support-laravel-4/",
	"title": "認證支援 Laravel 4 Session",
	"tags": [],
	"description": "",
	"content": "Laravel 5 認證支援 Laravel 4 Session Step1. Laravel 4 加密方式支援 AES Laravel 4 因為加密方式支援 rijndael-128，不支援 AES，所以無法使用 php 7.1 執行 Laravel 4 專案，在 Laravel 4 中的 app/config/app.php 檔案可以看到金鑰及加密方式的設定：\n\u0026lt;?php // Laravel 4 // app/config/app.php return [ \u0026#39;key\u0026#39; =\u0026gt; \u0026#39;randomStringLength32xxxxxxxxxxxx\u0026#39; \u0026#39;cipher\u0026#39; =\u0026gt; MCRYPT_RIJNDAEL_128, ]; Laravel 4 安裝 tomgrohl/laravel4-php71-encrypter 套件支援 AES 加密\ncomposer require tomgrohl/laravel4-php71-encrypter 修改 Nginx 設定使用 PHP 7.1\nserver { root \u0026quot;/home/kejyun/web/laravel-4-project/public\u0026quot;; location ~ [^/]\\.php(/|$) { fastcgi_pass unix:/run/php/php7.1-fpm.sock; } } 修改 Laravel 4 加密方式支援 AES-256\nAES-256 金鑰需要長度 32 的字串，AES-128 需要長度 16 的字串，我們支援 AES-256 所以需要將金鑰長度設定為 32\n\u0026lt;?php // Laravel 4 // app/config/app.php return [ \u0026#39;key\u0026#39; =\u0026gt; \u0026#39;randomStringLength32xxxxxxxxxxxx\u0026#39; \u0026#39;cipher\u0026#39; =\u0026gt; \u0026#39;AES-256-CBC\u0026#39;, ]; Step2. 修改 Laravel 5 金鑰格式 在使用 php artisan key:generate 產生 APP_KEY 時會產生 base64 的金鑰，但這樣格式的金鑰在 Laravel 4 是不支援的\n# .env APP_KEY=base64:z+ldCPR/vzxMBzZ6k+mptblu82qbeSM+kK5ZVKOUdFg= 所以需要將 Laravel 4 的金鑰直接貼到 .env 檔案，不要經過 base64 的加密\n# .env APP_KEY=randomStringLength32xxxxxxxxxxxx  Step3. 修改 Laravel 5 Cookie 加密方式 由於 Laravel 4 會將 Cookie 的資料經過 serialize，但 Laravel 5 不會將 Cookie serialize，所以為了讓 Laravel 5 可以正常讀取 Laravel 4 的 Cookie，需要將 Laravel 5 serialize 的功能打開。\n在 app/Http/Middleware/EncryptCookies.php 檔案中可以設定靜態變數 $serialize 為 true 即可。\n\u0026lt;?php // app/Http/Middleware/EncryptCookies.php namespace App\\Http\\Middleware; use Illuminate\\Cookie\\Middleware\\EncryptCookies as Middleware; class EncryptCookies extends Middleware { protected static $serialize = true; } Step4. 修改 Laravel 5 Auth 驗證方式 Laravel 4的驗證 Auth 方法與 Laravel 5 有些許不同，主要是在取得 session 名稱 的方法有點不同，在 Laravel 4 的 vendor/laravel/framework/src/Illuminate/Auth/Guard.php 可以看到 getName() 與 getRecallerName() 函式與 Laravel 5 不同\nLaravel 4 Guard\n vendor/laravel/framework/src/Illuminate/Auth/Guard.php\n \u0026lt;?php namespace Illuminate\\Auth; // Laravel 4 // vendor/laravel/framework/src/Illuminate/Auth/Guard.php  use Illuminate\\Cookie\\CookieJar; use Illuminate\\Events\\Dispatcher; use Symfony\\Component\\HttpFoundation\\Request; use Illuminate\\Session\\Store as SessionStore; use Symfony\\Component\\HttpFoundation\\Response; class Guard { /** * Get a unique identifier for the auth session value. * * @return string */ public function getName() { return \u0026#39;login_\u0026#39;.md5(get_class($this)); } /** * Get the name of the cookie used to store the \u0026#34;recaller\u0026#34;. * * @return string */ public function getRecallerName() { return \u0026#39;remember_\u0026#39;.md5(get_class($this)); } } Laravel 5 Session Guard\n vendor/laravel/framework/src/Illuminate/Auth/SessionGuard.php\n \u0026lt;?php // Laravel 5 // vendor/laravel/framework/src/Illuminate/Auth/SessionGuard.php  namespace Illuminate\\Auth; class SessionGuard implements StatefulGuard, SupportsBasicAuth { /** * Get a unique identifier for the auth session value. * * @return string */ public function getName() { return \u0026#39;login_\u0026#39;.$this-\u0026gt;name.\u0026#39;_\u0026#39;.sha1(static::class); } /** * Get the name of the cookie used to store the \u0026#34;recaller\u0026#34;. * * @return string */ public function getRecallerName() { return \u0026#39;remember_\u0026#39;.$this-\u0026gt;name.\u0026#39;_\u0026#39;.sha1(static::class); } } 為了讓 Laravel 5 支援 Laravel 4 的 Session，則必須要將取得 Session 名稱 方法修改為 Laravel 4 的方式\nLaravel 5 目錄建立 app/Auth/Laravel4SessionGuard.php 檔案，繼承原本 Illuminate\\Auth\\SessionGuard 的方法，並加入 getName() 及 getRecallerName() 方法修改為 Laravel 4 的方法\n\u0026lt;?php namespace App\\Auth; use Auth; use Illuminate\\Auth\\SessionGuard; use Illuminate\\Contracts\\Auth\\Guard; class Laravel4SessionGuard extends SessionGuard implements Guard { protected $laravel4_guard_class_name = \u0026#39;Illuminate\\Auth\\Guard\u0026#39;; /** * Get a unique identifier for the auth session value. * * @return string */ public function getName() { return \u0026#39;login_\u0026#39;.md5($this-\u0026gt;laravel4_guard_class_name); } /** * Get the name of the cookie used to store the \u0026#34;recaller\u0026#34;. * * @return string */ public function getRecallerName() { return \u0026#39;remember_\u0026#39;.md5($this-\u0026gt;laravel4_guard_class_name); } /** * Extend Auth for Laravel 4 */ public static function AuthExtend() { // vendor/laravel/framework/src/Illuminate/Auth/AuthManager.php  // - createSessionDriver  Auth::extend(\u0026#39;laravel4Session\u0026#39;, function ($app, $name, array $config) { $provider = Auth::createUserProvider($config[\u0026#39;provider\u0026#39;]); $guard = new Laravel4SessionGuard($name, $provider, $app[\u0026#39;session.store\u0026#39;]); // When using the remember me functionality of the authentication services we  // will need to be set the encryption instance of the guard, which allows  // secure, encrypted cookie values to get generated for those cookies.  if (method_exists($guard, \u0026#39;setCookieJar\u0026#39;)) { $guard-\u0026gt;setCookieJar($app[\u0026#39;cookie\u0026#39;]); } if (method_exists($guard, \u0026#39;setDispatcher\u0026#39;)) { $guard-\u0026gt;setDispatcher($app[\u0026#39;events\u0026#39;]); } if (method_exists($guard, \u0026#39;setRequest\u0026#39;)) { $guard-\u0026gt;setRequest($app-\u0026gt;refresh(\u0026#39;request\u0026#39;, $guard, \u0026#39;setRequest\u0026#39;)); } return $guard; }); } }  修改 config/auth.php 設定檔案\n\u0026lt;?php return [ \u0026#39;defaults\u0026#39; =\u0026gt; [ // \u0026#39;guard\u0026#39; =\u0026gt; \u0026#39;web\u0026#39;,  \u0026#39;guard\u0026#39; =\u0026gt; \u0026#39;laravel4_web\u0026#39;, \u0026#39;passwords\u0026#39; =\u0026gt; \u0026#39;users\u0026#39;, ], \u0026#39;guards\u0026#39; =\u0026gt; [ \u0026#39;laravel4_web\u0026#39; =\u0026gt; [ \u0026#39;driver\u0026#39; =\u0026gt; \u0026#39;laravel4Session\u0026#39;, \u0026#39;provider\u0026#39; =\u0026gt; \u0026#39;users\u0026#39;, ], ], ]; Laravel 5 使用自訂驗證方法\n在 Laravel 5 中的 app/Providers/AuthServiceProvider.php 檔案中呼叫 Laravel4SessionGuard::AuthExtend(); 方法，之後即可讀取到 Laravel 4 產生的 Session 驗證資料\n\u0026lt;?php // Laravel 5 // app/Providers/AuthServiceProvider.php  namespace App\\Providers; use App\\Auth\\Laravel4SessionGuard; use Illuminate\\Support\\Facades\\Gate; use Illuminate\\Foundation\\Support\\Providers\\AuthServiceProvider as ServiceProvider; class AuthServiceProvider extends ServiceProvider { /** * Register any authentication / authorization services. * * @return void */ public function boot() { $this-\u0026gt;registerPolicies(); // 設定 Laravel 4 Auth  Laravel4SessionGuard::AuthExtend(); } } 參考資料  tomgrohl/laravel4-php71-encrypter: Laravel 4.2 Encrypter for PHP 7.1+ The only supported ciphers are AES-128-CBC and AES-256-CBC · Issue #9080 · laravel/framework Laravel 5.6.30 breaks passport · Issue #795 · laravel/passport Authentication - Laravel - The PHP Framework For Web Artisans How to Create a Custom Authentication Guard in Laravel  "
},
{
	"uri": "https://laravel5-book.kejyun.com/services/helpers/request-helpers/",
	"title": "請求資訊",
	"tags": [],
	"description": "",
	"content": "請求資訊輔助方法 取得目前網域 // www.kejyun.com $domain_host = request()-\u0026gt;getHttpHost(); "
},
{
	"uri": "https://laravel5-book.kejyun.com/services/mail/",
	"title": "郵件（Mail）",
	"tags": [],
	"description": "",
	"content": "這裏介紹一些 Laravel 提供的一些郵件（Mail）功能\n"
},
{
	"uri": "https://laravel5-book.kejyun.com/structure/combination-cache-manager-structure-principle/",
	"title": "Combination &amp; Cache 架構設計準則（2019 年版本）",
	"tags": [],
	"description": "",
	"content": "Combination \u0026amp; Cache 架構設計準則（2019 年版本） 傳統的 MVC（Model, View, Controller） 框架，當 Controller 收到請求之後，我們會在 Controller 內直接透過 Model 去撈取資料庫的資料，並在 Controller 做資料驗證、資料整合、快取、商業邏輯判斷\u0026hellip;等等的工作。\n當系統越來越大，會發現很多類似的商業邏輯的程式都散在各地，沒有辦法重複再利用，當程式需要異動或修改的時候，就要去搜尋所有程式碼，把許多相同商業邏輯的程式碼去做異動，但需要修改的地方若太多，往往會東漏西漏，導致系統出現錯誤，並造成往後開發的時間成本增加。\n所以我們會想要做到 減少重複的程式碼、提高維護開發的效率，所以將程式碼依照分類及分層抽出獨立控管，讓不同類型的程式專心處理自己相關的商業邏輯，讓開發維護更容易。\n隨著程式架構的演進會發展出更多不同的架構，所以這個設計架構準則也是會隨著時間做演進的。\n 資料處理邏輯分層 架構圖 架構說明 A. 資料控制結構 * Controller (控制器：控制資料流程) * ServiceManager (服務整合管理：組合管理不同 Service 的商業邏輯) * Service (服務：處理商業邏輯) * Repository (資源庫：資料表資料撈取邏輯) * Model (資料庫模型：資料表設定) * Presenter (資料呈現：資料表資料格式呈現轉換) * Combination（資料整合：整理 Repository 資料成資訊） * CombinationManager（複合資料整合管理：整理多個 Service 的資料成資訊） * Checker (檢查器：根據 Controller 所需商業邏輯，驗證不同資料表欄位資料) * Validator (驗證器：資料表欄位資料驗證)    結構名稱 說明     Controller (控制器) 控制資料流程，控制要使用哪些 Service 或 ServiceManager 的商業邏輯，去組合出使用者請求需要的資料，並做資料的資料交易控制 (transaction) ，並使用 Checker 去檢查任何使用者傳進來的資料，確保資料的正確性   ServiceManager (服務整合管理) 協助 Controller 組合不同 Service 的資料成商業邏輯   Service (服務) 處理商業邏輯，組合不同的 Repository 資料成商業邏輯，提供 Controller 或 ServiceManager 存取   Repository (資源庫) 資料表資料撈取邏輯，撈取屬於自己 Model 不同條件下的資料，提供 Service 存取   Model (資料庫模型) 資料庫模型，資料表存取相關設定   Presenter (資料呈現) 資料呈現，協助 Model 做資料呈現轉換   Checker (檢查器) 協助 Controller 做資料驗證，在資料進入到程式邏輯前，都需要經過 Checker 將資料格式做驗證   Validator (驗證器) 協助 Checker 做資料驗證，Validator 只能驗證單一 Model 資料   CombinationManager (複合資料整合管理) 協助整理不同 Service 的複合式資料，若有資料的邏輯判斷需要不同的資料來源，則由 CombinationManager 負責整合處理   Combination （資料整合） 協助整理 Repository 資料成資訊    B.獨立結構 * CacheManager (快取：管理資源快取鍵值及清除快取) * Constant (常數：定義資料狀態名稱) * Support (支援：協助處理獨立邏輯資料處理) * ExceptionCode (例外代碼：例外錯誤代碼定義)    結構名稱 說明     CacheManager (快取) 協助專案資料做快取資料的控制，可以在任何程式邏輯複雜的地方做快取存取控制，並統一清除快取   Constant (常數) 定義並命名所有資料狀態，確保資料值做異動時，不會影響程式邏輯   Support (支援) 協助處理獨立程式邏輯，邏輯沒有被其他任何的函式綁定，可以獨立完成   ExceptionCode (例外代碼) 定義例外代碼，可以統一管控當例外發生錯誤時，回傳的錯誤代碼     架構存取限制  不能跨 2 階層以上存取  Controller 不能存取 Repository Controller 不能存取 Validator Service 不能存取 Model   低階層的不能存取高階層的資料  Model 不能存取 Repository Repository 不能存取 Service Validator 不能存取 Checker   同一個資料類型，不能互相呼叫  避免同一類型類別呼叫，造成 new 物件的時候有無窮迴圈  PostService 存取 UserService，UserService 存取 PostsService 造成無窮迴圈   ServiceManager 不能呼叫 ServiceManager Service 不能呼叫 Service Checker 不能呼叫 Checker Validator 不能呼叫 Validator Repository 不能呼叫 Repository CacheManager 不能呼叫 CacheManager   獨立結構可以在任何一階層去呼叫   架構設計邏輯範例說明 A. 資料控制結構 Controller (控制器)    項目 說明     用途 控制資料流程   可以存取結構 Checker、ServiceManager、Service、DB transaction，所有獨立結構   可以被存取結構 無    處理 HTTP 請求的入口，依照需求呼叫 ServiceManager 或 Service 去做資料的存取，大部分情況呼叫 Service 去組合需要的資料就好，若相同的組合邏輯在不同的 Controller 都有用到，那就使用 ServiceManager 去組合不同的 Service\n要確保所有 Service 商業邏輯都正確跑完才允許對資料做異動，並避免 Transaction 在 Controller 及 Service 被重複呼叫，導致無法正確鎖定資料狀態，所以使用 Controller 當作資料交易（Transaction）的控制點\n\u0026lt;?php class PostController extends Controller { public function __construct( PostServiceManager $PostServiceManager, PostService $PostService, CommentService $CommentService, PostChecker $PostChecker ) { $this-\u0026gt;PostServiceManager = $PostServiceManager; $this-\u0026gt;PostService = $PostService; $this-\u0026gt;CommentService = $CommentService; $this-\u0026gt;PostChecker = $PostChecker; } // 顯示文章  public function show($post_id) { try { // 驗證資料  $input = [ \u0026#39;post_id\u0026#39; =\u0026gt; $post_id ]; $this-\u0026gt;PostChecker-\u0026gt;checkShow($input); // 撈取文章  $Post = $this-\u0026gt;PostServiceManager-\u0026gt;findPost($post_id); // 撈取文章留言  $Comment = $this-\u0026gt;CommentService-\u0026gt;getCommentByPostId(post_id); } catch (Exception $exception) { throw $exception } } // 更新文章  public function update($post_id) { try { // 驗證資料  $input = request()-\u0026gt;all(); $input[\u0026#39;post_id\u0026#39;] = $post_id; $this-\u0026gt;PostChecker-\u0026gt;checkUpdate($input); // 交易開始  DB::beginTransaction(); // 更新文章  $Post = $this-\u0026gt;PostService-\u0026gt;update($post_id, $input); // 交易結束  DB::commit(); } catch (Exception $exception) { // 交易失敗  DB::rollBack(); throw $exception } } }  ServiceManager (服務整合管理)    項目 說明     用途 組合管理不同 Service 的商業邏輯   可以存取結構 Service、所有獨立結構   可以被存取結構 Controller    使用不同 Service 撈取資料，將不同資料組合成商業邏輯，供 Controller 做存取\n\u0026lt;?php class PostServiceManager { public function __construct( PostService $PostService, UserService $UserService ) { $this-\u0026gt;PostService = $PostService; $this-\u0026gt;UserService = $UserService; } // 撈取文章資料  public function findPost($post_id){ try { // 撈取文章  $Post = $this-\u0026gt;PostService-\u0026gt;findPost($post_id); // 撈取文章作者資料  $user_id = $Post-\u0026gt;user_id; $Post-\u0026gt;user = $this-\u0026gt;UserService-\u0026gt;findUser($user_id); return $Post; } catch (Exception $exception) { throw $exception } } } Service (服務)    項目 說明     用途 處理商業邏輯   可以存取結構 Repository、所有獨立結構   可以被存取結構 Controller、ServiceManager    使用不同的 Repository 撈取資料，將不同資料組合成商業邏輯\n\u0026lt;?php class PostService { public function __construct( PostRepository $PostRepository, PostTagRepository $PostTagRepository ) { $this-\u0026gt;PostRepository = $PostRepository; $this-\u0026gt;PostTagRepository = $PostTagRepository; } // 撈取文章  public function findPost($post_id) { try { // 撈取文章  $Post = $this-\u0026gt;PostRepository-\u0026gt;find($post_id); // 撈取文章標籤  $Tag = $this-\u0026gt;PostTagRepository-\u0026gt;getByPostId($post_id); return [$Post, $Tag]; } catch (Exception $exception) { throw $exception } } }  Repository (資源庫)    項目 說明     用途 資料表資料撈取邏輯   可以存取結構 Model、所有獨立結構   可以被存取結構 Service    撈取特定 Model 資料，像 PostRepository 可以存取 Post Model (模型) 的 基本資料，並使用不同條件撈取 Model 的資料，供 Service 做存取\n也可以使用 PostRecommendRepository 存取 Post Model (模型) 的 推薦資料\n同一個 Model (模型) 可以用不同的 Repository 去呼叫，但同一 Repository 只能有一個 Model (模型)\n\u0026lt;?php class PostRepository { public function __construct( Post $Post ) { $this-\u0026gt;Post = $Post; } public function find($post_id) { try { // 撈取資料庫文章資料  $Post = $this-\u0026gt;Post-\u0026gt;find($post_id); return $Post; } catch (Exception $exception) { throw $exception } } public function findLatestPost() { try { // 撈取資料庫文章資料  $Post = $this-\u0026gt;Post -\u0026gt;order(\u0026#39;created_at\u0026#39;, \u0026#39;desc\u0026#39;) -\u0026gt;first(); return $Post; } catch (Exception $exception) { throw $exception } } } Model (資料庫模型)    項目 說明     用途 資料表設定   可以存取結構 所有獨立結構   可以被存取結構 Repository    Eloquent 存取資料表相關設定，使用 Eloquent 直接存取資料表資料\n\u0026lt;?php class Post extends Model { protected $table = \u0026#39;post\u0026#39;; protected $fillable = []; protected $primaryKey = \u0026#39;id\u0026#39;; protected $dates = [\u0026#39;created_at\u0026#39;, \u0026#39;updated_at\u0026#39;]; protected $presenter = PostPresenter::class; }  Presenter (資料呈現)    項目 說明     用途 資料表資料格式呈現轉換   可以存取結構 所有獨立結構   可以被存取結構 Model    提供 Model 的資料用其他方式呈現\n\u0026lt;?php class PostPresenter extends Presenter { public function created_at_human_time() { return $this-\u0026gt;created_at-\u0026gt;diffForHumans(); } } Checker (檢查器)    項目 說明     用途 根據 Controller 所需商業邏輯，驗證不同資料表欄位資料   可以存取結構 Validator、所有獨立結構   可以被存取結構 Controller    協助 Controller 驗證不同資料表資料的正確性，若驗證錯誤則丟處例外，Controller 根據例外代碼去做處理\n\u0026lt;?php class PostValidator { public function checkFindPost($input){ // 驗證文章資料  $this-\u0026gt;PostValidator-\u0026gt;validatePostId($input); $this-\u0026gt;PostValidator-\u0026gt;validatePostContent($input); // 驗證會員資料  $this-\u0026gt;MemberValidator-\u0026gt;validateMemberId($input); } } Validator (驗證器)    項目 說明     用途 資料表欄位資料驗證   可以存取結構 所有獨立結構   可以被存取結構 Checker    協助 Checker 驗證資料的正確性，若驗證錯誤則丟處例外，Checker 根據例外代碼去做處理\n\u0026lt;?php class PostValidator { public function validatePostId($input){ // 設定驗證規則  $rules = [ \u0026#39;post_id\u0026#39; =\u0026gt; [ \u0026#39;required\u0026#39;, \u0026#39;max:20\u0026#39;, ], ]; // 開始驗證  $this-\u0026gt;validator = Validator::make($input, $rules); if ($this-\u0026gt;validator-\u0026gt;fails()) { throw new Exception( \u0026#39;文章編號格式錯誤\u0026#39;, PostExceptionCode::POST_ID_FORMAT_ERROR ); } } }  Combination（資料整合）    項目 說明     用途 整理 Repository 資料成資訊   可以存取結構 所有獨立結構   可以被存取結構 Serivce、CombinationManager    當 Service 從 Repository 取得資料後，協助整理判斷 Repository 資料的屬性狀態，像是可以從 文章編號 取得 文章網址\n\u0026lt;?php class PostsCombination { // 設定整合資訊  public function setCombinationInfo(\u0026amp;$Posts) { if (!($Posts instanceof Posts)) { return false; } // 文章網址  $url = url(\u0026#34;article/{$Posts-\u0026gt;id}\u0026#34;) $Posts-\u0026gt;info-\u0026gt;url = $url; } } CombinationManager（複合資料整合管理）    項目 說明     用途 整理多個 Service 的資料成資訊   可以存取結構 Combination、Serivce、所有獨立結構   可以被存取結構 ServiceManager、Controller    當整合的資料需要經過不同的資料來源去判斷要產生什麼複合資訊，CombinationManager 協助整理不同來源的資料去做資料整合，目前會從 ServiceManager 去取得不同 Service 的資訊，所以將 CombinationManager 放在這一階層去進行呼叫\n\u0026lt;?php class PostsCombinationManager { protected $UserService; public function __construct( UserCombination $UserCombination, ProjectService $ProjectService ) { // 服務  $this-\u0026gt;UserCombination = $UserCombination; } public function setCombinationInfo(\u0026amp;$combination_data) { $Posts = array_get($combination_data, \u0026#39;Posts\u0026#39;); if ($Posts instanceof Posts) { // 設定文章關聯作者資訊  $this-\u0026gt;UserCombination-\u0026gt;setCombinationInfo($Posts-\u0026gt;User); // 是專題文章  if ($Posts-\u0026gt;type == PostsConstant::TYPE_PROJECT) { $Project = $this-\u0026gt;ProjectService-\u0026gt;findProjectByPostId($Posts-\u0026gt;id); $url = url(\u0026#34;project/{$Project-\u0026gt;slug}/{$Posts-\u0026gt;id}\u0026#34;) $Posts-\u0026gt;info-\u0026gt;url = $url; }; } } }  B.獨立結構 CacheManager (快取)    項目 說明     用途 管理資源快取鍵值及清除快取   可以存取結構 x   可以被存取結構 無限制    在 複雜 的資料庫查詢（Repository）或是商業邏輯（Service、ServiceManager），想要在一定時間內不要再重複的進行複雜的運算，可以透過快取將運算的結果快取起來\nPostsCacheManager 文章資源庫\nclass PostRepository { public function __construct( Post $Post, PostsCacheManager $PostsCacheManager ) { $this-\u0026gt;Post = $Post; $this-\u0026gt;PostsCacheManager = $PostsCacheManager; } public function find($post_id) { try { $cache_key = $this-\u0026gt;PostsCacheManager-\u0026gt;getPostIdCacheKey($post_id); $Posts = $this-\u0026gt;PostsCacheManager-\u0026gt;getCache($cache_key); if (!is_null($Posts)) { return $Posts; } // 撈取資料庫文章資料 $Posts = $this-\u0026gt;Post-\u0026gt;find($post_id); if (!is_null($Posts)) { // 有該資料，將資料存入快取 $this-\u0026gt;PostsCacheManager-\u0026gt;putCache($Posts, $cache_key); } return $Posts; } catch (Exception $exception) { throw $exception } } public function findLatestPost() { try { // 撈取資料庫文章資料 $Post = $this-\u0026gt;Post -\u0026gt;order(\u0026#39;created_at\u0026#39;, \u0026#39;desc\u0026#39;) -\u0026gt;first(); return $Post; } catch (Exception $exception) { throw $exception } } } PostsCacheManager 文章快取\nclass PostsCacheManager { protected $cache_key = [ // 文章快取 \u0026#39;post_id\u0026#39; =\u0026gt; \u0026#39;[PostById][post_id:{post_id}]\u0026#39;, // 已發布文章快取 \u0026#39;published_post_id\u0026#39; =\u0026gt; \u0026#39;[PublishedPostById][post_id:{post_id}]\u0026#39;, ]; /** * 文章快取 */ public function getPostIdCacheKey($post_id) { $search = [ \u0026#39;{post_id}\u0026#39;, ]; $replace = [ $post_id, ]; $cache_key = str_replace($search, $replace, $this-\u0026gt;cache_key[\u0026#39;post_id\u0026#39;]); return $cache_key; } /** * 已發布文章快取 */ public function getPublishedPostIdCacheKey($post_id) { $search = [ \u0026#39;{post_id}\u0026#39;, ]; $replace = [ $post_id, ]; $cache_key = str_replace($search, $replace, $this-\u0026gt;cache_key[\u0026#39;published_post_id\u0026#39;]); return $cache_key; } /** * 文章快取 */ public function getPostIdCacheKey($post_id) { $search = [ \u0026#39;{post_id}\u0026#39;, ]; $replace = [ $post_id, ]; $cache_key = str_replace($search, $replace, $this-\u0026gt;cache_key[\u0026#39;post_id\u0026#39;]); return $cache_key; } /** * 清除文章快取 */ public function forgetPostsCache($cache_data) { $Posts = array_get($cache_data, \u0026#39;Posts\u0026#39;); if (!is_null($Posts) AND ($Posts instanceof Posts)) { $cache_key = $this-\u0026gt;getPostIdCacheKey($post_id); $is_cache_forget = $Cache::forget($cache_key); $cache_key = $this-\u0026gt;getPublishedPostIdCacheKey($post_id); $is_cache_forget = $Cache::forget($cache_key); // .... 清除文章其他快取 } } }  Constant (常數)    項目 說明     用途 定義資料狀態名稱   可以存取結構 x   可以被存取結構 無限制    資料皆為靜態變數，可以供所有資料層級 (e.g. Controller、Service、Repository) 做存取\n\u0026lt;?php class PostConstant { const POST_TYPE_PUBLIC = \u0026#39;P\u0026#39;; const POST_TYPE_DELETE = \u0026#39;D\u0026#39;; } Support (支援)    項目 說明     用途 協助處理獨立邏輯資料處理   可以存取結構 x   可以被存取結構 無限制    方法皆為靜態變數，可以供所有資料層級 (e.g. Controller、Service、Repository) 做存取\n若有其他可供全域共用的方法皆寫在 Support 靜態方法供大家存取\n\u0026lt;?php class PostSupport { // 撈取所有文章類型  public static function getAllPostType() { $all_post_type = [ PostConstant::POST_TYPE_PUBLIC, PostConstant::POST_TYPE_DELETE, ]; return $all_post_type; } }  ExceptionCode (例外代碼)    項目 說明     用途 例外錯誤代碼定義   可以存取結構 x   可以被存取結構 x    資料皆為靜態變數，可以供所有資料層級 (e.g. Controller、Service、Repository) 做存取\n\u0026lt;?php class PostExceptionCode { const POST_ID_FORMAT_ERROR = 10000001; const POST_NOT_FOUND = 10000002; const POST_TAG_NOT_FOUND = 10000003; } View (視圖) 使用限制 View 的職責是負責顯示資料，所有的資料應由 Controller 準備好再傳給 View，所以不要在 View 內有複雜的程式判斷邏輯，在 View 裡面只有 if, for, foreach 跟 echo 列印 的程式，僅需要將資料呈現在對的 HTML 裡面，不要再對資料重複處理過。\n像是文章的網址可能會因為類型不同會有不同的網址，像是一般文章網址可能為 http://kejyun.com/post/1，而影音文章網址可能為 http://kejyun.com/video/2，兩者的資料皆為 Post 資料表的資料，在 View 中要顯示網址應為 echo $Post-\u0026gt;post_url; 將網址印出，post_url 則是在傳給 View 之前就經過邏輯判斷的資料，而不是在 View 中判斷不同文章類型（PostConstant::POST_TYPE_NORMAL, PostConstant::POST_TYPE_VIDEO）在 View 中顯示不同的網址資料。\n之後若文章網址邏輯需要修改，則需要到各個 View 中去修改，很容易漏改道造成系統程式出錯\n\u0026lt;a href=\u0026#34;{{ $Post-\u0026gt;info-\u0026gt;post_url }}\u0026#34;\u0026gt; {{ $Post-\u0026gt;Title }}\u0026lt;/a\u0026gt; "
},
{
	"uri": "https://laravel5-book.kejyun.com/database/",
	"title": "Database",
	"tags": [],
	"description": "",
	"content": "這裏會介紹一些 Laravel 使用的資料庫\n"
},
{
	"uri": "https://laravel5-book.kejyun.com/database/model/",
	"title": "Eloquent Model (模型)",
	"tags": [],
	"description": "",
	"content": "Eloquent Model 這裏會介紹如何在 Laravel 使用 Eloquent Model 管理資料庫\n"
},
{
	"uri": "https://laravel5-book.kejyun.com/database/model/eloquent-relationships/",
	"title": "Eloquent 關聯",
	"tags": [],
	"description": "",
	"content": "Eloquent 關聯 假如我們有兩個模型，「文章（Article）」及「使用者（Users）」，假設一個情境，1 個使用者可以寫多篇的文章，但 1 篇文章只能被 1 個使用者發表\n如果我們想要透過關聯關係，從使用者模型去取得使用者的文章，就像：\n// 取得使用者編號 1 的物件 $user = \\App\\Users::find(1); // 取得使用者的所有發表的文章 $user-\u0026gt;articles(); 我們會想要使用者模型內設定這樣的關聯關係，就像：\nclass Users extends Model { // 設定使用者擁有許多文章 public function articles() { return $this-\u0026gt;hasMany(\u0026#39;App\\Article\u0026#39;); } } 如果我們想透過關聯關係，從文章模型去取得是哪一個使用者發表文章，就像：\n// 取得文章編號 1 的物件 $article = \\App\\Article::find(1); // 取得發表文章的使用者資訊 $user = $article-\u0026gt;user(); class Article extends Model { // 設定文章屬於某一的使用者 public function user() { return $this-\u0026gt;belongsTo(\u0026#39;App\\User\u0026#39;); } public function owner() { return $this-\u0026gt;belongsTo(\u0026#39;App\\User\u0026#39;); } public function writer() { return $this-\u0026gt;belongsTo(\u0026#39;App\\User\u0026#39;); } }  設定關聯屬性的函式名稱可以自訂，看自己覺得什麼樣的名稱適合自己就可以了，自訂完後一樣可以使用關聯的方式，撈取出發表文章使用者的資訊\n// 取得文章編號 1 的物件 $article = \\App\\Article::find(1); // 取得發表文章的使用者資訊 $owner_user = $article-\u0026gt;owner(); $writer_user = $article-\u0026gt;writer(); 設定完之後，必須確定文章（Article）資料表有使用者編號（user_id）的外來鍵欄位\n\u0026lt;?php // database/migrations/2015_04_13_154720_create_article_table.php  use Illuminate\\Database\\Schema\\Blueprint; use Illuminate\\Database\\Migrations\\Migration; class CreateArticleTable extends Migration { public function up() { Schema::table(\u0026#39;article\u0026#39;, function(Blueprint $table) { // 發表文章使用者編號  $table-\u0026gt;integer(\u0026#39;user_id\u0026#39;)-\u0026gt;unsigned(); // 設定外來鍵  $table-\u0026gt;foreign(\u0026#39;user_id\u0026#39;) -\u0026gt;references(\u0026#39;id\u0026#39;) -\u0026gt;on(\u0026#39;users\u0026#39;) -\u0026gt;onDelete(\u0026#39;cascade\u0026#39;); }); } public function down() { Schema::drop(\u0026#39;users\u0026#39;); } } 參考資料  Eloquent Relationships - Laracasts  "
},
{
	"uri": "https://laravel5-book.kejyun.com/environment/homestead/install-with-homestead/",
	"title": "Homestead",
	"tags": [],
	"description": "",
	"content": "Homestead 常常我我們需要開發Web Application時候，都需要花很長的時間把環境建置起來，而Homestead以讓我們透過簡單的設定檔，輕鬆的建置好整個執行環境，讓我們能夠更專注於在開發上\n OSX El Capitan 10.11.3\n  Laravel 5.2\n  Vagrant 1.8.1\n  Virtualbox 5.0.14\n 安裝 Virtualbox 從 VirtualBox 官方網站 下載並安裝 VirtualBox\n下載連結：http://download.virtualbox.org/virtualbox/5.0.14/VirtualBox-5.0.14-105127-OSX.dmg\n安裝 Vagrant 從 Vagrant 官方網站 下載並安裝 Vagrant\n下載連結：https://releases.hashicorp.com/vagrant/1.8.1/vagrant_1.8.1.dmg\n安裝 Homestead Vagrant Box 在 VirtualBox 及 Vagrant 安裝完後，使用下列指令將 Homestead 加入您的虛擬主機中\nvagrant box add laravel/homestead  使用 Git 複製 Laravel homestead 並建立 Homestead 設定檔 $ git clone https://github.com/laravel/homestead.git Homestead $ cd Homestead ~/Homestead$ bash init.sh 建立ssh key $ ssh-keygen -t rsa -C \u0026#34;kejyun@homestead\u0026#34; 編輯 Homestead 設定檔 $ vim ~/.homestead/Homestead.yaml 確認設定檔中ssh key有對應到正確的路徑\nauthorize: ~/.ssh/id_rsa.pub keys: - ~/.ssh/id_rsa 設定虛擬主機提供者 vagrant 支援 virtualbox, vmware_fusion 或 vmware_workstation 這幾個虛擬主機，我們使用 VirtualBox 所以就填入 virtualbox\nprovider: virtualbox  設定本機程式碼路徑對應到測試環境的路徑共用資料夾  map：本機路徑\n  to：Vagrant測試機路徑\n 程式路徑 folders: - map: ~/Code to: /home/vagrant/Code - map: ~/laravel52 to: /home/vagrant/laravel52 網站路徑 sites: - map: kejyun.app to: /home/vagrant/laravel52/public 設定 /ect/hosts 對應本機網址到 Vagrant $ sudo vim /etc/hosts 加入下列設定\n192.168.10.10 kejyun.app  IP 位址為 Homestead.yaml 設定中的 ip 設定值，kejyun.app 則是參照設定檔中的 sites map 設定有哪些則加進去 hosts 設定檔中\n  啟動 Vagrant ~/Homestead $ vagrant up  在剛剛使用Git複製下來的homestead資料夾中執行vagrant up指令，會自動下載virtualbox相關的虛擬主機設定，並依照設定檔設置虛擬主機。\n 設定完成後可以開啟瀏覽器到 http://kejyun.app 看看Homestead是否有正常啟動，若看到下列畫面表示可以正常運作了！！！\n備註 若要關閉Homestead虛擬機器，則可以使用下列指令關閉\nvagrant halt 若設定檔有修改要重新讀取，則可以使用下列指令重新讀取設定\nvagrant provision  SSL read: error:00000000:lib(0):func(0):reason(0), errno 60 若在啟動 homestead 時出現 SSL read 的錯誤訊息的話，可以重新加入新的 homestead vagrand box\n$ vagrant up Bringing machine \u0026#39;default\u0026#39; up with \u0026#39;virtualbox\u0026#39; provider... ==\u0026gt; default: Box \u0026#39;laravel/homestead\u0026#39; could not be found. Attempting to find and install... default: Box Provider: virtualbox default: Box Version: \u0026gt;= 0.4.0 ==\u0026gt; default: Loading metadata for box \u0026#39;laravel/homestead\u0026#39; default: URL: https://atlas.hashicorp.com/laravel/homestead ==\u0026gt; default: Adding box \u0026#39;laravel/homestead\u0026#39; (v0.4.4) for provider: virtualbox default: Downloading: https://atlas.hashicorp.com/laravel/boxes/homestead/versions/0.4.4/providers/virtualbox.box An error occurred while downloading the remote file. The error message, if any, is reproduced below. Please fix this error and try again. SSL read: error:00000000:lib(0):func(0):reason(0), errno 60 加入新的 homestead vagrand box vagrant box add --insecure -c laravel/homestead http://atlas.hashicorp.com/laravel/boxes/homestead $ vagrant box add --insecure -c laravel/homestead http://atlas.hashicorp.com/laravel/boxes/homestead ==\u0026gt; box: Loading metadata for box \u0026#39;http://atlas.hashicorp.com/laravel/boxes/homestead\u0026#39; This box can work with multiple providers! The providers that it can work with are listed below. Please review the list and choose the provider you will be working with. 1) virtualbox 2) vmware_desktop Enter your choice: 1 ==\u0026gt; box: Adding box \u0026#39;laravel/homestead\u0026#39; (v0.4.4) for provider: virtualbox box: Downloading: https://atlas.hashicorp.com/laravel/boxes/homestead/versions/0.4.4/providers/virtualbox.box ==\u0026gt; box: Successfully added box \u0026#39;laravel/homestead\u0026#39; (v0.4.4) for \u0026#39;virtualbox\u0026#39;! 加入完成後，再重新啟動 homestead 即可\n$ vagrant up 變更 Homestead 主機 ip 當我們想要有多台 Homestead 主機時，會因為 Homestead 預設的主機 ip 都為 192.168.10.11 而導致 ip 之間有衝突，所以我們也可以透過置換 ip 去達到同時開不同的 Homestead 主機。\n--- ip: \u0026#34;192.168.99.10\u0026#34; 我們僅需要將 ip 直接換成我們想要的 ip，這裡我將 ip 換成 192.168.99.10，換完 ip 之後，僅需要打 vagrant reload 這樣就可以成功將 ip 置換掉了！\nvagrant reload VT-x is disabled in the BIOS for all CPU modes 在使用 vagrant up 的時候，若出現 VT-x is disabled in the BIOS for all CPU modes 表示你的 BIOS 沒有開啟虛擬化功能\nThere was an error while executing VBoxManage, a CLI used by Vagrant for controlling VirtualBox. The command and stderr is shown below. Command: [\u0026quot;startvm\u0026quot;, \u0026quot;4316329f-815b-4088-b04f-e7ff0c224c4a\u0026quot;, \u0026quot;--type\u0026quot;, \u0026quot;headless\u0026quot;] Stderr: VBoxManage.exe: error: Not in a hypervisor partition (HVP=0) (VERR_NEM_NOT_AVAILABLE). VBoxManage.exe: error: VT-x is disabled in the BIOS for all CPU modes (VERR_VMX_MSR_ALL_VMX_DISABLED) VBoxManage.exe: error: Details: code E_FAIL (0x80004005), component ConsoleWrap, interface IConsole 此時只需要到 BIOS 將虛擬化功能開啟即可\n 虛擬化功能名稱可能會像是：“Intel VT-x,” “Intel Virtualization Technology,” “Virtualization Extensions,” “Vanderpool”，並且放在 “Chipset,” “Northbridge,” “Advanced Chipset Control,” or “Advanced CPU Configuration” 的選單上\n 開啟後重新使用 vagrant up 即可順利開啟虛擬機器\n 除錯 安裝 Laravel 過程出現 Could not scan for classes inside \u0026quot;/home/vagrant/Code/blog/vendor/phpunit/php-code-coverage/src/\u0026quot; 訊息 2020/04/05 時在安裝新版 Homestead 時，發現一直出現以下錯誤訊息，一直無法順利安裝 Laravel\n安裝過程是用官網的步驟直接安裝\nvagrant box add laravel/homestead git clone https://github.com/laravel/homestead.git ~/Homestead cd ~/Homestead git checkout release 當前的 Homestead 版本是 release v10.7.0，然後使用標準 composer 指令去安裝 Laravel\ncomposer create-project --prefer-dist laravel/laravel blog 安裝過程最後不斷出現 Could not scan for classes inside \u0026quot;/home/vagrant/Code/blog/vendor/phpunit/php-code-coverage/src/\u0026quot; 的訊息\nPackage jakub-onderka/php-console-color is abandoned, you should avoid using it. Use php-parallel-lint/php-console-color instead. Package jakub-onderka/php-console-highlighter is abandoned, you should avoid using it. Use php-parallel-lint/php-console-highlighter instead. Generating optimized autoload files [RuntimeException] Could not scan for classes inside \u0026#34;/home/vagrant/Code/blog/vendor/phpunit/php-code-coverage/src/\u0026#34; which does not appear to be a file nor a folder install [--prefer-source] [--prefer-dist] [--dry-run] [--dev] [--no-dev] [--no-custom-installers] [--no-autoloader] [--no-scripts] [--no-progress] [--no-suggest] [-v|vv|vvv|--verbose] [-o|--optimize-autoloader] [-a|--classmap-authoritative] [--apcu-autoloader] [--ignore-platform-reqs] [--] [\u0026lt;packages\u0026gt;]... vagrant@homestead:~/Code/test$ 在搜尋了許久發現 Homestead 9新盒子建立一个新的Laravel專案作曲家無法掃描裏面的類/ vendor / phpunit / php-code-coverage / src / - laravel - Codebug 文章中提到了一個關鍵字\n 將 VirtualBox 更新為 v6。\n  在GitHub上查看此問题：https://github.com/laravel/homestead/issues/1219\n  Unable to load the \u0026ldquo;app\u0026rdquo; configuration file. · Issue #1219 · laravel/homestead\n 發現自己的 VirtualBox 版本為 5.x，立即去官網將 VirtualBox 更新至 6.x 就可以順利安裝了，安裝過程中完全沒有提到跟 VirtualBox 有關的錯誤訊息，導致我鬼打牆了好久 QQ\n也有人遇到的問題是因為 composer cache 的問題，也可以用這個方式移除 compser cache 來解決安裝問題\ncomposer clear-cache cd project/ rm -rf vendor composer install 參考資料  Say Hello to Laravel Homestead 2.0 Laravel - Homestead Virtualbox Vagrant Vagrant 常用指令 SSL read: error · Issue #401 · Varying-Vagrant-Vagrants/VVV Vagrant: Fix for error 60 / SSL read - Slick Change ip homestead Vagrant error on Windows 10 · Issue #195 · scotch-io/scotch-box · GitHub VBoxManage: error: VT-x is disabled in the BIOS for all CPU modes · Issue #1301 · openebs/openebs · GitHub How to Enable Intel VT-x in Your Computer’s BIOS or UEFI Firmware Homestead 9新盒子建立一个新的Laravel專案作曲家無法掃描裏面的類/ vendor / phpunit / php-code-coverage / src / - laravel - Codebug Unable to load the \u0026ldquo;app\u0026rdquo; configuration file. · Issue #1219 · laravel/homestead Fresh install laravel 5.3 on Homestead 3.0.2 fail \u0026ldquo;/vendor/phpunit/php-code-coverage/src/\u0026rdquo; · Issue #15105 · laravel/framework  "
},
{
	"uri": "https://laravel5-book.kejyun.com/design-pattern/psr/",
	"title": "PSR",
	"tags": [],
	"description": "",
	"content": "PSR (php standard recommendations) 為了讓大家開發的套件，能夠更輕鬆地整合到自己的專案當中，在 PHP 社群中大家一起定義了一些標準的程式碼撰寫規則\n但是 Laravel 5.0.x 版本之前，Laravel 都沒有真正的遵照 PSR 的規範去撰寫程式碼，直到 Laravel 5.1 LTS 版本時，Laravel 終於將所有的程式碼遵照 PSR-2 及 PSR-4 的程式碼撰寫規則了，詳細的規則說明大家可以自己參考相關的說明文件。\n而為了讓自己專案的開發也能夠遵照 PSR 規則，除了自己一個檔案一個檔案自己修改外，也可以用 PHP Coding Standards Fixer 套件去幫我們自動地將程式修改成遵照 PSR 規則的程式！\nPHP Coding Standards Fixer 安裝使用教學 使用 compser 下載套件 使用 composer 將 php-cs-fixer 安裝到全域（global）目錄下\n$ composer global require fabpot/php-cs-fixer 設定 composer bin 目錄到環境變數中 我們必須要將我們家目錄下的全域 ~/.composer/vendor/bin 目錄，設到環境變數中，這樣我們在命令列就可以直接執行 ~/.composer/vendor/bin 下面的可執行檔案了\n$ export PATH=\u0026#34;$PATH:$HOME/.composer/vendor/bin\u0026#34;  我們可以直接在命令列下這樣的指令就可以了，但每次開啟新的 Terminal 視窗時，都要再重新的設定一次這樣的環境變數，所以我們也可以把這個設定寫在 ~/.bash_profile 檔案中，這樣每次執行 Terminal 時，就會自動將 ~/.composer/vendor/bin 設到環境變數中了！\n 使用 php-cs-fixer 修正 PHP 檔案 設定完成後，我們就可以使用 php-cs-fixer fix /path/to/project --level=psr2 這樣的指令去修正我們專案目錄下的檔案了\n一些 php-cs-fixer 相關的指令會像這樣:\n$ php-cs-fixer fix /path/to/project --level=psr0 $ php-cs-fixer fix /path/to/project --level=psr1 $ php-cs-fixer fix /path/to/project --level=psr2 $ php-cs-fixer fix /path/to/project --level=symfony  設定 Sublime 使用 php-cs-fixer 修正程式碼 在 Sublime 上方工具列 Tools\\Bulid System\\New Build System 我們可以新增一個新的建立指令，指令中我們輸入像這樣的指令：\n{ \u0026#34;shell_cmd\u0026#34;: \u0026#34;php-cs-fixer fix $file --level=psr2\u0026#34; } 將新的指令檔案名稱取為 php-cs-fixer.sublime-bulid，這樣我們回到 Sublime 去開啟任一 PHP 檔案，只要按下 Command（⌘）+B，Sublime 就會自動幫我們執行 php-cs-fixer 的 shell script 指令，去修正我們的 PHP 檔案了！！\nphp-cs-fixer 使用小技巧 我們可以將修改 ~/.bash_profile 檔案，將使用 php-cs-fixer 修正 Terminal 目前目錄的 PHP 指令加入，這樣我們只要用 Terminal 瀏覽到我們想要做 php-cs-fixer 的目錄下，我們每次只需要下 phpCSFixerThisFolder 指令就可以了，這樣就不用記住也不用打那麼落落長的 php-cs-fixer 指令了！\nalias phpCSFixerThisFolder=\u0026#34;php-cs-fixer fix ./ --level=psr2\u0026#34;  PSR 中文文件  PSR-1 - Basic Coding Standard PSR-2 - Coding Style Guide PSR-3 - 日誌介面 PSR-4 - Autoloader  參考資料  PHP-FIG — PHP Framework Interop Group PHP: The Right Way - 繁體中文 PHP Coding Standards Fixer PHP-CS-Fixer Adopting PSR-2 - laracasts  "
},
{
	"uri": "https://laravel5-book.kejyun.com/database/qa/cannot-mass-insert/",
	"title": "使用大量資料的方式新增時無法新增",
	"tags": [],
	"description": "",
	"content": "使用大量資料的方式新增（Mass Assignment）時無法新增 在 Laravel 若沒有在模型（Model）中同時設定「可以新增的欄位變數 $fillable」及「需要保護的欄位變數 $guarded」時，為了安全性著想，在做大量的新增或異動資料時（Mass Assignment），會無法正確的去新增或異動資料。\n設定「可以新增的欄位變數 $fillable」 設定你覺得允許做大量新增的欄位名稱\nclass User extends Model { protected $fillable = [\u0026#39;first_name\u0026#39;, \u0026#39;last_name\u0026#39;, \u0026#39;email\u0026#39;]; }  設定「需要保護的欄位變數 $guarded」 我們可以指定某些欄位，不能被使用大量新增或異動，去變更欄位的資料值\nclass User extends Model { protected $guarded = [\u0026#39;id\u0026#39;, \u0026#39;password\u0026#39;]; } 若我們想要讓模型（Model）可以被大量新增，且我們沒有需要保護的欄位時，我們還是需要設定 $guarded 變數為空陣列 []，否則 Laravel 預會保護所有的欄位資料，讓你無法進行大量的新增或異動資料\nclass User extends Model { protected $fillable = [\u0026#39;id\u0026#39;, \u0026#39;password\u0026#39;, \u0026#39;first_name\u0026#39;, \u0026#39;last_name\u0026#39;, \u0026#39;email\u0026#39;]; protected $guarded = []; } 參考資料  Eloquent ORM 新增、更新、刪除 - Laravel.tw Laravel Eloquent Save to DB Using Create - Unhelpful Error Eloquent Create Method - Always inserts blank entries. Unable to create a model with Eloquent create method. Error telling MassAssignMentException  "
},
{
	"uri": "https://laravel5-book.kejyun.com/qa/qa-segmentation-fault-11-when-seeding/",
	"title": "Segmentation fault: 11 when seeding",
	"tags": [],
	"description": "",
	"content": "Segmentation fault: 11 when seeding 在使用 Laravel 的 Pagination 的時候，因為畫面有些許異動需要改 Pagination 的結構樣式，所以需要使用 artisan 產生預設的樣板\nphp artisan vendor:publish --tag=laravel-pagination 在執行完指令後，跑出了 Segmentation fault: 11 的訊息\nSegmentation fault: 11  經查詢後，發現這個是 PHP 版本的問題\n因為我用 Homestead，專案目錄與 Homestead 同步，所以索性我在 OSX 下這個指令，但我 OSX 的 PHP 版本似乎過舊，所以就 ssh 到 Homestead 中去下這個命令就好了～\nvagrant ssh cd ~/Code/project ~/Code/project$ php artisan vendor:publish --tag=laravel-pagination Copied Directory [/vendor/laravel/framework/src/Illuminate/Pagination/resources/views] To [/resources/views/vendor/pagination] Publishing complete. 參考資料  Database: Pagination Segmentation fault: 11 when seeding · Issue #3921 · laravel/framework  "
},
{
	"uri": "https://laravel5-book.kejyun.com/hosting/composer/hosting-install-composer/",
	"title": "安裝 composer",
	"tags": [],
	"description": "",
	"content": "安裝 composer 下載 composer php -r \u0026#34;copy(\u0026#39;https://getcomposer.org/installer\u0026#39;, \u0026#39;composer-setup.php\u0026#39;);\u0026#34; php -r \u0026#34;if (hash_file(\u0026#39;sha384\u0026#39;, \u0026#39;composer-setup.php\u0026#39;) === \u0026#39;756890a4488ce9024fc62c56153228907f1545c228516cbf63f885e036d37e9a59d27d63f46af1d4d07ee0f76181c7d3\u0026#39;) { echo \u0026#39;Installer verified\u0026#39;; } else { echo \u0026#39;Installer corrupt\u0026#39;; unlink(\u0026#39;composer-setup.php\u0026#39;); } echo PHP_EOL;\u0026#34; php composer-setup.php php -r \u0026#34;unlink(\u0026#39;composer-setup.php\u0026#39;);\u0026#34; 將 composer 執行檔移動到系統環境變數路徑 移動過去系統環境變數路徑中，這樣所有系統的使用者才都可以執行\nsudo mv composer.phar /usr/bin/composer 安裝所有 Laravel 專案套件 在我們將程式使用 git 推送到主機時，vendor 下所有的套件都不會被推送到主機，所以程式碼上去主機後，需要自己作安裝套件的動作\ncd /home/kejyun/laravel55 composer install 這樣我們就完成了 composer 的安裝跟安裝 Laravel 專案套件了\n proc_open(): fork failed - Cannot allocate memory 無法配置記憶體安裝套件 1. 可以將 php.ini 的 memory_limit 提高\nvim /etc/php/7.1/fpm/php.ini vim /etc/php/7.1/cli/php.ini memory_limit = 1024M 2. 使用 SWAP 增加系統虛擬記憶體\nsudo -s cd /var fallocate -l 4G swapfile.1 chmod 600 swapfile.1 mkswap /var/swapfile.1 swapon /var/swapfile.1  虛擬記憶體（SWAP） · ubuntu 學習筆記  參考資料  Composer Download  "
},
{
	"uri": "https://laravel5-book.kejyun.com/resource/resource-conference/",
	"title": "會議議程",
	"tags": [],
	"description": "",
	"content": "會議議程 會議  Laracon US Laracon EU ArtisanConf  會議影片  Laracon EU 2014 Laracon US 2014 Laracon EU 2013 Laracon US 2013  "
},
{
	"uri": "https://laravel5-book.kejyun.com/package/auth/oauth/package-auth-oauth2-password-grant/",
	"title": "Password Grant",
	"tags": [],
	"description": "",
	"content": "OAuth2 Password Grant 設定 config 在 config/oauth2.php 檔案中加入下列設定，並設定你的 token 存活時間(access_token_ttl)，單位時間為秒，在 callback 設定您要用來驗證使用者帳號密碼的類別函式，OAuth2 會透過這個 callback 去驗證使用者的帳號密碼\nreturn [ \u0026#39;grant_types\u0026#39; =\u0026gt; [ \u0026#39;password\u0026#39; =\u0026gt; [ \u0026#39;class\u0026#39; =\u0026gt; \u0026#39;\\League\\OAuth2\\Server\\Grant\\PasswordGrant\u0026#39;, \u0026#39;callback\u0026#39; =\u0026gt; \u0026#39;\\App\\PasswordVerifier@verify\u0026#39;, \u0026#39;access_token_ttl\u0026#39; =\u0026gt; 3600 ], ] ]; 建立驗證身份 callback OAuth 會將 Client 傳來的 username 及 password 欄位的資料透過 callback 傳入並驗證，當中驗證的規則跟邏輯你可以自行定義，若驗證失敗回傳 false 即可，驗證成功的話可以將使用者的編號回傳，OAuth 會將 Access token 對應的使用者編號（資源擁有者編號）記錄下來\nuse Illuminate\\Support\\Facades\\Auth; class PasswordGrantVerifier { public function verify($username, $password) { $credentials = [ \u0026#39;email\u0026#39; =\u0026gt; $username, \u0026#39;password\u0026#39; =\u0026gt; $password, ]; // 驗證成功 if (Auth::once($credentials)) { return Auth::user()-\u0026gt;id; } // 驗證失敗 return false; } }  取得 Access token 在我們取得 Access token 的資料欄位中填入下列欄位\n   欄位名稱 資料     grant_types password   username kejyun@gmail.com   password 123456   client_id KeJyun   client_secret KeJyunSecret     client_id 與 client_secret 為在 OAuth 套件說明頁 建立的\n  username 與 password 是你專案的使用者驗證資料，端看你驗證的 callback 如何定義這兩個欄位的資料，驗證成功後回傳使用者的編號給 OAuth2 記錄即可\n 送出到我們設定的 /oauth/access_token 路由後，我們就可以直接取得 access_token，並回傳此 token 失效的時間 expires_in 為我們設定的 access_token_ttl\n 相關資料表 OAuth2 會將 token 記錄在 oauth_access_tokens 資料表，並將關聯的使用者記錄在 oauth_sessions 資料表，在 oauth_sessions 中的 owner_id 則為我們剛剛回傳的使用者編號\n參考資料  Password Grant  "
},
{
	"uri": "https://laravel5-book.kejyun.com/package/image/intervention/package-image-intervention-other/",
	"title": "其他圖片處理",
	"tags": [],
	"description": "",
	"content": "Intervention Image 其他圖片處理 cache() 快取 // 試著讀取快取的圖片 $img = Image::cache(function($image) { // 讀取本機圖片，將圖片 resize 至 300x200，並作灰階處理 return $image-\u0026gt;make(\u0026#39;public/foo.jpg\u0026#39;) -\u0026gt;resize(300, 200) -\u0026gt;greyscale(); }); 若用檔案快取，快取的圖片資料會存放在 storage/framework/cache/data 目錄下。\n Intervention/imagecache: Caching extension for the Intervention Image Class   canvas() 建立圖片畫布 // 建立畫布 $img = Image::canvas(300, 100); Image::canvas(300, 100);\n// 建立畫布，並使用 #ff0000 顏色當作背景 $img = Image::canvas(32, 32, \u0026#39;#ff0000\u0026#39;); Image::canvas(32, 32, \u0026lsquo;#ff0000\u0026rsquo;);\nellipse() 畫橢圓 // 建立顏色為 #ddd，寬度 300px，高度 100px 的畫布 $img = Image::canvas(300, 100, \u0026#39;#ddd\u0026#39;); // 在畫布中畫出寬度 25px，高度 60px，位置在 (50,50) ，顏色為 #0000ff 的橢圓 $img-\u0026gt;ellipse(25, 60, 50, 50, function ($draw) { $draw-\u0026gt;background(\u0026#39;#0000ff\u0026#39;); }); ellipse(25, 60, 50, 50) color #0000ff\"\n$img-\u0026gt;ellipse(25, 60, 50, 50) color #0000ff\n exif() 取得圖片 exif 資訊 必須使用 Imagick 2.3.9 的函式庫，並且必須編譯 --enable-exif，且有 mbstring 的套件才可取得 exif 資訊\n// 取得所有 exif 資訊 $data = Image::make(\u0026#39;public/foo.jpg\u0026#39;)-\u0026gt;exif(); // 讀取鏡頭 Model $name = Image::make(\u0026#39;public/foo.jpg\u0026#39;)-\u0026gt;exif(\u0026#39;Model\u0026#39;); filesize() 檔案大小 當檔案不是從實際的檔案讀取，則會回傳 false\n// 建立圖片實例 $img = Image::make(\u0026#39;public/foo.jpg\u0026#39;); // 取得檔案大小 $size = $img-\u0026gt;filesize();  fill() 填滿顏色或圖片 // 建立畫布，寬度 800px 高度 600px $img = Image::canvas(800, 600); // 填滿 #ff5500 顏色 $img-\u0026gt;fill(\u0026#39;#ff5500\u0026#39;); fill('#ff5500\u0026rsquo;);\"\n$img-\u0026gt;fill('#ff5500\u0026rsquo;);\n// 填滿圖片 $img-\u0026gt;fill(\u0026#39;tile.png\u0026#39;); fill(\u0026lsquo;tile.png\u0026rsquo;);\"\n$img-\u0026gt;fill(\u0026lsquo;tile.png\u0026rsquo;);\nfilter() 指定過濾器 可以將一些常用的過濾規則通通寫在過濾器中，這樣就可以直接指定 Filter 去做過濾\n// init new image instance $img = Image::make(\u0026#39;foo.jpg\u0026#39;); // apply filter $img-\u0026gt;filter(new DemoFilter(45)); \u0026lt;?php namespace Intervention\\Image\\Filters; class DemoFilter implements FilterInterface { const DEFAULT_SIZE = 10; private $size; public function __construct($size = null) { $this-\u0026gt;size = is_numeric($size) ? intval($size) : self::DEFAULT_SIZE; } /** * 執行圖片過濾 */ public function applyFilter(\\Intervention\\Image\\Image $image) { $image-\u0026gt;pixelate($this-\u0026gt;size); $image-\u0026gt;greyscale(); return $image; } }  width() 圖片寬度 // 取得圖片寬度 $width = Image::make(\u0026#39;public/foo.jpg\u0026#39;)-\u0026gt;width(); height() 圖片高度 // 取得圖片高度 $height = Image::make(\u0026#39;public/foo.jpg\u0026#39;)-\u0026gt;height(); interlace() 交錯模式 如果是 JPEG 的圖片，將會把圖片儲存成 progressive JPEG 的圖片\n// 建立圖片實例 $img = Image::make(\u0026#39;public/foo.png\u0026#39;); // 啟用 interlacing $img-\u0026gt;interlace(); // 儲存為 interlaced 的圖片 $img-\u0026gt;save(); // 開啟 interlaced 圖片 $img = Image::make(\u0026#39;public/interlaced.gif\u0026#39;); // 關閉 interlacing $img-\u0026gt;interlace(false); // 儲存為 standard mode 的圖片 $img-\u0026gt;save(); mime() 取得圖片 mime $mime = Image::make(\u0026#39;public/foo.jpg\u0026#39;)-\u0026gt;mime();  pickColor() 選出圖片顏色色碼 // 建立圖片實例 $img = Image::make(\u0026#39;public/foo.jpg\u0026#39;); // 選出位置在 (100,100) 的像素顏色: 陣列資料 $arraycolor = $img-\u0026gt;pickColor(100, 100); /* array:4 [ 0 =\u0026gt; 43 1 =\u0026gt; 58 2 =\u0026gt; 78 3 =\u0026gt; 1.0 ] */ // 選出位置在 (100,100) 的像素顏色: rgb $rgb_color = $img-\u0026gt;pickColor(100, 100, \u0026#39;rgb\u0026#39;); // rgba(43, 58, 78) // 選出位置在 (100,100) 的像素顏色: rgba $rgba_color = $img-\u0026gt;pickColor(100, 100, \u0026#39;rgba\u0026#39;); // rgba(43, 58, 78, 1.00) // 選出位置在 (100,100) 的像素顏色: hex $hex_color = $img-\u0026gt;pickColor(100, 100, \u0026#39;hex\u0026#39;); // #2b3a4e pixel() 在指定像素點畫出顏色 // 建立畫布 $img = Image::canvas(100, 100, \u0026#39;#ddd\u0026#39;); // 在 (32,32) 像素畫出藍色 $img-\u0026gt;pixel(\u0026#39;#0000ff\u0026#39;, 32, 32); // 在 (32,32) 像素畫出紅色 $img-\u0026gt;pixel(\u0026#39;#ff0000\u0026#39;, 64, 64); pixel();\"\n$img-\u0026gt;pixel();\npolygon() 畫出多邊形 // 建立畫布 $img = Image::canvas(800, 600, \u0026#39;#ddd\u0026#39;); // 定義多邊形位置 $points = array( 40, 50, // Point 1 (x, y) 20, 240, // Point 2 (x, y) 60, 60, // Point 3 (x, y) 240, 20, // Point 4 (x, y) 50, 40, // Point 5 (x, y) 10, 10 // Point 6 (x, y) ); // 畫出多邊形 $img-\u0026gt;polygon($points, function ($draw) { // 背景顏色 #000ff $draw-\u0026gt;background(\u0026#39;#0000ff\u0026#39;); // 邊框寬度 1，顏色 #ff0000 $draw-\u0026gt;border(1, \u0026#39;#ff0000\u0026#39;); }); rectangle() 畫出四邊形 // 建立畫布 $img = Image::canvas(250, 300, \u0026#39;#ddd\u0026#39;); // 畫出紅色四邊形 $img-\u0026gt;rectangle(5, 5, 195, 195, function ($draw) { $draw-\u0026gt;background(\u0026#39;#ff0000\u0026#39;); }); rectangle() background #ff0000\"\n$img-\u0026gt;rectangle() background #ff0000\n// 畫出透明度 0.5 的四邊形，使用 2px 黑色邊框 $img-\u0026gt;rectangle(5, 5, 195, 195, function ($draw) { $draw-\u0026gt;background(\u0026#39;rgba(255, 255, 255, 0.5)\u0026#39;); $draw-\u0026gt;border(2, \u0026#39;#000\u0026#39;); }); rectangle() background rgba(255, 255, 255, 0.5) border 2px #000\"\n$img-\u0026gt;rectangle() background rgba(255, 255, 255, 0.5) border 2px #000\n response() 回應包含 HTTP Header 圖片 參數1: 圖片類型\n jpg — return JPEG encoded image data png — return Portable Network Graphics (PNG) encoded image data gif — return Graphics Interchange Format (GIF) encoded image data tif — return Tagged Image File Format (TIFF) encoded image data bmp — return Bitmap (BMP) encoded image data  參數2: 圖片品質\n 數值介於 0~100  // 建立圖片實例 $img = Image::make(\u0026#39;public/foo.jpg\u0026#39;); return $img-\u0026gt;response(); // 回應 png 圖片 return $img-\u0026gt;response(\u0026#39;jpg\u0026#39;); response(\u0026lsquo;jpg\u0026rsquo;);\"\n$img-\u0026gt;response(\u0026lsquo;jpg\u0026rsquo;);\n// 回應 jpg 圖片 品質 20 return $img-\u0026gt;response(\u0026#39;jpg\u0026#39;, 20); response(\u0026lsquo;jpg\u0026rsquo;, 20);\"\n$img-\u0026gt;response(\u0026lsquo;jpg\u0026rsquo;, 20);\n"
},
{
	"uri": "https://laravel5-book.kejyun.com/package/chart/",
	"title": "圖表",
	"tags": [],
	"description": "",
	"content": "圖表  Lavacharts  "
},
{
	"uri": "https://laravel5-book.kejyun.com/http/route/sub-domain-route/",
	"title": "子網域路由（Sub-Domain Route）",
	"tags": [],
	"description": "",
	"content": "子網域路由（Sub-Domain Route） 我們可能會因為有多個子網域，而我們希望各個不同的子網域有自己的路由設定，像是我們希望各個子網域的首頁能夠藍道不同的頁面，這個時候我們可以透過子網域路由去幫我們達成這樣的工作\n加入您的子網域到 hosts 設定 如果是正式環境則不用做此設定，如果是測試環境也想要達到子網域路由的效果，則必須做此設定\n開啟 /etc/hosts 檔案，並加入您需要的子網域\n127.0.0.1 resume.kejyun.dev 127.0.0.1 book.kejyun.dev Homestead 加入此子網域的虛擬主機設定 sites: - map: resume.kejyun.dev to: /home/vagrant/Code/KeJyunProject/public - map: book.kejyun.dev to: /home/vagrant/Code/KeJyunProject/public 重新讀取 Homestead 設定 若設定檔有修改要重新讀取，則可以使用下列指令重新讀取設定\nvagrant provision  加入子網域路由 在 route.php 檔案中加入子網域路由\nRoute::group([\u0026#39;domain\u0026#39; =\u0026gt; \u0026#39;resume.kejyun.dev\u0026#39;], function() { Route::get(\u0026#39;/\u0026#39;, function() { return \u0026#39;KeJyun Resume\u0026#39;; }); }); Route::group([\u0026#39;domain\u0026#39; =\u0026gt; \u0026#39;book.kejyun.dev\u0026#39;], function() { Route::get(\u0026#39;/\u0026#39;, function() { return \u0026#39;KeJyun Book\u0026#39;; }); }); 這樣我們就可以在 http://resume.kejyun.dev 及 http://book.kejyun.dev 這兩個子網域看到不同的首頁了！\n參考資料  Homestead and Subdomains  "
},
{
	"uri": "https://laravel5-book.kejyun.com/services/unit-test/unit-test-assert/",
	"title": "Assert",
	"tags": [],
	"description": "",
	"content": "Assert 狀態碼測試 assertOk ： 測試回傳狀態碼為 200 assertForbidden ： 測試回傳狀態碼為 403 assertNotFound ： 測試回傳狀態碼為 404 assertSuccessful ： 測試回傳狀態碼為 200 ~ 299 \u0026lt;?php $response = $this-\u0026gt;json(\u0026#39;GET\u0026#39;, \u0026#39;/api/status-code\u0026#39;); // 測試狀態碼 $response-\u0026gt;assertOk(); // 狀態碼 200 $response-\u0026gt;assertNotFound(); // 狀態碼 404 $response-\u0026gt;assertForbidden(); // 狀態碼 403 $response-\u0026gt;assertSuccessful(); // 狀態碼 200 ~ 299 assertStatus ： 測試指定狀態碼 \u0026lt;?php $response = $this-\u0026gt;json(\u0026#39;GET\u0026#39;, \u0026#39;/api/status-code\u0026#39;); // 測試狀態碼 $response-\u0026gt;assertStatus(201); // 狀態碼 201 assertRedirect ： 測試是否為重新導向狀態碼  重新導向狀態碼：201, 301, 302, 303, 307, 308\n \u0026lt;?php $response = $this-\u0026gt;call(\u0026#39;GET\u0026#39;, \u0026#39;/redirect-uri\u0026#39;); // 測試狀態碼 $response-\u0026gt;assertRedirect($redirect_uri);  狀態測試 assertLocation ： 測試目前網址位置 \u0026lt;?php $response = $this-\u0026gt;call(\u0026#39;GET\u0026#39;, \u0026#39;/specific-location\u0026#39;); // 測試是否包含指定資料 $response-\u0026gt;assertLocation(\u0026#39;/specific-location\u0026#39;); 資料測試 assertSee ： 測試是否有包含指定資料 \u0026lt;?php $response = $this-\u0026gt;call(\u0026#39;GET\u0026#39;, \u0026#39;/hello-world\u0026#39;); // 測試是否包含指定資料 $response-\u0026gt;assertSee(\u0026#39;\u0026lt;h1\u0026gt;Hello World\u0026lt;/h1\u0026gt;\u0026#39;); assertSeeInOrder ： 測試是否看到指定順序資料 \u0026lt;?php $response = $this-\u0026gt;call(\u0026#39;GET\u0026#39;, \u0026#39;/hello-world\u0026#39;); // 測試是否沒有包含指定資料 $response-\u0026gt;assertSeeInOrder([ \u0026#39;\u0026lt;h1\u0026gt;\u0026#39;, \u0026#39;Hello\u0026#39;, \u0026#39;World\u0026#39;, \u0026#39;\u0026lt;/h1\u0026gt;\u0026#39;, ]); assertSeeText ： 測試是否看到指定文字（不包含 html tag） \u0026lt;?php $response = $this-\u0026gt;call(\u0026#39;GET\u0026#39;, \u0026#39;/hello-world\u0026#39;); // 測試是否包含指定資料 $response-\u0026gt;assertSeeText(\u0026#39;Hello World\u0026#39;);  assertSeeTextInOrder ： 測試是否看到指定順序文字（不包含 html tag） \u0026lt;?php $response = $this-\u0026gt;call(\u0026#39;GET\u0026#39;, \u0026#39;/hello-world\u0026#39;); // 測試是否沒有包含指定資料 $response-\u0026gt;assertSeeTextInOrder([ \u0026#39;Hello\u0026#39;, \u0026#39;World\u0026#39;, ]); assertDontSee ： 測試是否沒有看到指定資料 \u0026lt;?php $response = $this-\u0026gt;call(\u0026#39;GET\u0026#39;, \u0026#39;/hello-world\u0026#39;); // 測試是否沒有包含指定資料 $response-\u0026gt;assertDontSee(\u0026#39;\u0026lt;h1\u0026gt;No Hello World\u0026lt;/h1\u0026gt;\u0026#39;); assertDontSeeText ： 測試是否沒有看到指定文字 \u0026lt;?php $response = $this-\u0026gt;call(\u0026#39;GET\u0026#39;, \u0026#39;/hello-world\u0026#39;); // 測試是否沒有包含指定資料 $response-\u0026gt;assertDontSeeText(\u0026#39;No Hello World\u0026#39;);  Cookie 測試 assertPlainCookie ： 測試是否為未加密 Cookie \u0026lt;?php $response = $this-\u0026gt;call(\u0026#39;GET\u0026#39;, \u0026#39;/get-cookie\u0026#39;); // 測試是否包含指定資料 $response-\u0026gt;assertPlainCookie(\u0026#39;cookie-name\u0026#39;); assertCookie ： 測試指定 Cookie 是否有包含指定鍵值資料 \u0026lt;?php $response = $this-\u0026gt;call(\u0026#39;GET\u0026#39;, \u0026#39;/get-cookie\u0026#39;); // 測試是否包含指定資料 $response-\u0026gt;assertCookie(\u0026#39;cookie-name\u0026#39;, \u0026#39;cookie-value\u0026#39;, $encrypted = true, $unserialize = false); assertCookieExpired ： 測試指定鍵值 cookie 是否失效 \u0026lt;?php $response = $this-\u0026gt;call(\u0026#39;GET\u0026#39;, \u0026#39;/get-cookie\u0026#39;); // 測試是否包含指定資料 $response-\u0026gt;assertCookieExpired(\u0026#39;expired-cookie-name\u0026#39;);  JSON 測試 assertJson ： 測試 JSON 子集合資訊  測試的資料，僅需為原始資料的子集合即可\n 回傳資料 { \u0026#34;status\u0026#34; : true, \u0026#34;data\u0026#34;: { \u0026#34;title\u0026#34;: \u0026#34;Nam saepe earum molestias consequuntur et doloremque ea.\u0026#34;, \u0026#34;body\u0026#34;: \u0026#34;Consequatur iure omnis distinctio tempore accusamus...\u0026#34;, \u0026#34;active\u0026#34;: false } } 測試 JSON 子集合資訊 $response = $this-\u0026gt;json(\u0026#39;GET\u0026#39;, \u0026#39;/api/json\u0026#39;); // 測試成功 $response-\u0026gt;assertJsonFragment([ \u0026#39;status\u0026#39; =\u0026gt; true, ]); // 測試成功 $response-\u0026gt;assertJsonFragment([ \u0026#39;status\u0026#39; =\u0026gt; true, \u0026#39;data\u0026#39; =\u0026gt; [ \u0026#34;active\u0026#34;=\u0026gt; false ] ]); assertJsonFragment ： 測試 JSON 部分鍵值資訊 回傳資料 { \u0026#34;status\u0026#34; : true, \u0026#34;data\u0026#34;: { \u0026#34;title\u0026#34;: \u0026#34;Nam saepe earum molestias consequuntur et doloremque ea.\u0026#34;, \u0026#34;body\u0026#34;: \u0026#34;Consequatur iure omnis distinctio tempore accusamus...\u0026#34;, \u0026#34;active\u0026#34;: false } } 測試成功\n$response = $this-\u0026gt;json(\u0026#39;GET\u0026#39;, \u0026#39;/api/json\u0026#39;); // 測試成功 $response-\u0026gt;assertJsonFragment([ \u0026#39;status\u0026#39; =\u0026gt; true, ]); // 測試成功 $response-\u0026gt;assertJsonFragment([ \u0026#39;status\u0026#39; =\u0026gt; true, \u0026#39;data\u0026#39; =\u0026gt; [ \u0026#34;title\u0026#34; =\u0026gt; \u0026#34;Nam saepe earum molestias consequuntur et doloremque ea.\u0026#34;, \u0026#34;body\u0026#34;=\u0026gt; \u0026#34;Consequatur iure omnis distinctio tempore accusamus...\u0026#34;, \u0026#34;active\u0026#34;=\u0026gt; false ] ]);  測試 JSON 部分鍵值資訊  若有要指定測試鍵值的資料，則測試的鍵值資料必須包含所有的資訊\n 測試成功\n$response = $this-\u0026gt;json(\u0026#39;GET\u0026#39;, \u0026#39;/api/json\u0026#39;); // 測試成功 $response-\u0026gt;assertJsonFragment([ \u0026#39;status\u0026#39; =\u0026gt; true, ]); // 測試成功 $response-\u0026gt;assertJsonFragment([ \u0026#39;status\u0026#39; =\u0026gt; true, \u0026#39;data\u0026#39; =\u0026gt; [ \u0026#34;title\u0026#34; =\u0026gt; \u0026#34;Nam saepe earum molestias consequuntur et doloremque ea.\u0026#34;, \u0026#34;body\u0026#34;=\u0026gt; \u0026#34;Consequatur iure omnis distinctio tempore accusamus...\u0026#34;, \u0026#34;active\u0026#34;=\u0026gt; false ] ]); 測試失敗\n// 測試失敗 $response-\u0026gt;assertJsonFragment([ 'status' =\u0026gt; true, 'data' =\u0026gt; [ \u0026quot;title\u0026quot; =\u0026gt; \u0026quot;Nam saepe earum molestias consequuntur et doloremque ea.\u0026quot;, ] ]);  assertJsonStructure ： 測試 JSON 結構 回傳資料 { \u0026#34;status\u0026#34; : true, \u0026#34;data\u0026#34;: { \u0026#34;title\u0026#34;: \u0026#34;Nam saepe earum molestias consequuntur et doloremque ea.\u0026#34;, \u0026#34;body\u0026#34;: \u0026#34;Consequatur iure omnis distinctio tempore accusamus...\u0026#34;, \u0026#34;active\u0026#34;: false } } 測試 JSON 結構 $response = $this-\u0026gt;json(\u0026#39;GET\u0026#39;, \u0026#39;/api/json\u0026#39;); $response-\u0026gt;assertJsonStructure([ \u0026#39;status\u0026#39;, \u0026#39;data\u0026#39; =\u0026gt; [ \u0026#39;body\u0026#39;, \u0026#39;title\u0026#39;, \u0026#39;active\u0026#39; ] ]) assertExactJson ： 測試 JSON 資料是否完全符合 回傳資料 { \u0026#34;status\u0026#34; : true, \u0026#34;data\u0026#34;: { \u0026#34;title\u0026#34;: \u0026#34;Nam saepe earum molestias consequuntur et doloremque ea.\u0026#34;, \u0026#34;body\u0026#34;: \u0026#34;Consequatur iure omnis distinctio tempore accusamus...\u0026#34;, \u0026#34;active\u0026#34;: false } }  測試 JSON 結構 $response = $this-\u0026gt;json(\u0026#39;GET\u0026#39;, \u0026#39;/api/json\u0026#39;); $response-\u0026gt;assertExactJson([ \u0026#39;status\u0026#39; =\u0026gt; true, \u0026#39;data\u0026#39; =\u0026gt; [ \u0026#34;title\u0026#34; =\u0026gt; \u0026#34;Nam saepe earum molestias consequuntur et doloremque ea.\u0026#34;, \u0026#34;body\u0026#34;=\u0026gt; \u0026#34;Consequatur iure omnis distinctio tempore accusamus...\u0026#34;, \u0026#34;active\u0026#34;=\u0026gt; false ] ]) 參考資料  Testing JSON APIs, specifically: assertJsonStructure  "
},
{
	"uri": "https://laravel5-book.kejyun.com/services/laravel-mix/laravel-mix-browser-sync/",
	"title": "BrowserSync",
	"tags": [],
	"description": "",
	"content": "BrowserSync 使用 BrowserSync 可以在我們對於 blade 檔案做異動時，自動重新載入頁面\n 安裝 BrowserSync  npm install browser-sync --save-dev npm install browser-sync-webpack-plugin@2.0.1 --save-dev 設定 BrowserSync 至 webpack.mix.js  mix.browserSync({ proxy: 'my-domain.test' }); 監控 BrowserSync 運作  npm run watch 參考資料  BrowserSync | Laravel Mix Documentation  "
},
{
	"uri": "https://laravel5-book.kejyun.com/services/errors-logs/service/errors-log-service-bugsnag/",
	"title": "Bugsnag",
	"tags": [],
	"description": "",
	"content": "Bugsnag  版本：Laravel 5.0 ~ 5.6\n  紀錄指定的錯誤訊息及系統錯誤\n 1. 安裝\ncomposer require \u0026#34;bugsnag/bugsnag-laravel:^2.0\u0026#34; 2. 設定 config/app.php\n\u0026lt;?php // config/app.php return [ \u0026#39;providers\u0026#39; =\u0026gt; [ Bugsnag\\BugsnagLaravel\\BugsnagServiceProvider::class, ], ]; 3. 設定 API KEY\n到 .env 檔案設定 API KEY，根據官方安裝引導可以取得此 API KEY\n# .env BUGSNAG_API_KEY=\u0026lt;API_KEY\u0026gt; 3. 設定檔\nLaravel 5.6\n\u0026lt;?php // config/logging.php: return [ \u0026#39;channels\u0026#39; =\u0026gt; [ \u0026#39;stack\u0026#39; =\u0026gt; [ \u0026#39;driver\u0026#39; =\u0026gt; \u0026#39;stack\u0026#39;, // Add bugsnag to the stack:  \u0026#39;channels\u0026#39; =\u0026gt; [\u0026#39;single\u0026#39;, \u0026#39;bugsnag\u0026#39;], ], // Create a bugsnag logging channel:  \u0026#39;bugsnag\u0026#39; =\u0026gt; [ \u0026#39;driver\u0026#39; =\u0026gt; \u0026#39;bugsnag\u0026#39;, ], ], ] Laravel 5.0~5.5\n到 app/Providers/AppServiceProvider.php 檔案中的 register 方法加入此設定\nclass AppServiceProvider extends ServiceProvider { public function register() { $this-\u0026gt;app-\u0026gt;alias(\u0026#39;bugsnag.logger\u0026#39;, \\Illuminate\\Contracts\\Logging\\Log::class); $this-\u0026gt;app-\u0026gt;alias(\u0026#39;bugsnag.logger\u0026#39;, \\Psr\\Log\\LoggerInterface::class); } }  4. 發送錯誤訊息到 Bugsnag\nuse Bugsnag\\BugsnagLaravel\\Facades\\Bugsnag; use RuntimeException; Bugsnag::notifyException(new RuntimeException(\u0026#34;Test error\u0026#34;)); 5. 檢視 Bugsnag 錯誤訊息\n6. 留下麵包屑\ntry { // 留下麵包屑 Bugsnag::leaveBreadcrumb(\u0026#39;leaveBreadcrumb 111\u0026#39;); Bugsnag::leaveBreadcrumb(\u0026#39;leaveBreadcrumb 222\u0026#39;); throw new Exception(\u0026#39;Test Hello Exception\u0026#39;); } catch (Exception $exception) { // 傳送訊息 Bugsnag::notifyException($exception); } 7. 檢視麵包屑訊息\n可以看到在程式中留下的麵包屑，可以知道程式在哪一段麵包屑後出錯\n 程式系統錯誤 當程式或系統發生錯誤時，也會記錄相關資訊\n參考資料  Error reporting, monitoring, and resolution with Bugsnag bugsnag/bugsnag-laravel: Bugsnag notifier for the Laravel PHP framework. Monitor and report Laravel errors. Bugsnag docs › Platforms › PHP › Laravel  "
},
{
	"uri": "https://laravel5-book.kejyun.com/http/middleware/middleware-intro/",
	"title": "中介層介紹",
	"tags": [],
	"description": "",
	"content": "中介層介紹 這裏會介紹如何在 Laravel 5 使用中介層處理資料，Middleware 在 Laravel 4 叫做 Filter，他可以在處理資料之前，先過濾條件判斷，符合條件的再繼續處理之後的 Http 請求。\n就像實作一個部落格，使用者發表文章的時候，一定要登入，否則就會被導到登入頁（或首頁），判斷登入條件的部分在 Laravel 5 可以用中介層去實現。\n檢視中介層類別 我們可以看看內建的驗證使用者是否有登入的 Authenticate 中介層\n\u0026lt;?php namespace App\\Http\\Middleware; // app\\Http\\Middleware\\Authenticate.php  use Closure; use Illuminate\\Contracts\\Auth\\Guard; class Authenticate { protected $auth; /** * Create a new filter instance. * 建立過濾器實例，建構時注入 Guard 類別並存到 auth 變數 * * @param Guard $auth * @return void */ public function __construct(Guard $auth) { $this-\u0026gt;auth = $auth; } /** * Handle an incoming request. * 處理 request * * @param \\Illuminate\\Http\\Request $request * @param \\Closure $next * @return mixed */ public function handle($request, Closure $next) { if ($this-\u0026gt;auth-\u0026gt;guest()) { if ($request-\u0026gt;ajax()) { return response(\u0026#39;Unauthorized.\u0026#39;, 401); } else { return redirect()-\u0026gt;guest(\u0026#39;auth/login\u0026#39;); } } return $next($request); } } 有設定 Http Request 中介層時，所有的請求都會丟給中介層的 handle() 函式做處理，第一個變數傳入的是 Request 本身，第二個變數是若檢查驗證成功之後要執行的函數，並把 Request 丟給下一層處理 $next($request)。\n 註冊中介層變數 中介層設定好之後，必須要到 app\\Http\\Kernel.php 去註冊你的中介層\n\u0026lt;?php namespace App\\Http; // app\\Http\\Kernel.php  use Illuminate\\Foundation\\Http\\Kernel as HttpKernel; class Kernel extends HttpKernel { /** * The application\u0026#39;s global HTTP middleware stack. * 全域中介層堆疊 * * @var array */ protected $middleware = [ \u0026#39;Illuminate\\Foundation\\Http\\Middleware\\CheckForMaintenanceMode\u0026#39;, // 檢查應用程式是不是維護中  \u0026#39;Illuminate\\Cookie\\Middleware\\EncryptCookies\u0026#39;, // 加密 Cookies  \u0026#39;Illuminate\\Cookie\\Middleware\\AddQueuedCookiesToResponse\u0026#39;, // 加入 Queued Cookies 到 Response  \u0026#39;Illuminate\\Session\\Middleware\\StartSession\u0026#39;, // 開啟 Session  \u0026#39;Illuminate\\View\\Middleware\\ShareErrorsFromSession\u0026#39;, // 從 Session 中共享錯誤資訊  \u0026#39;App\\Http\\Middleware\\VerifyCsrfToken\u0026#39;, // 驗證 CSRF Token  ]; /** * The application\u0026#39;s route middleware. * 路由中介層 * * @var array */ protected $routeMiddleware = [ \u0026#39;auth\u0026#39; =\u0026gt; \u0026#39;App\\Http\\Middleware\\Authenticate\u0026#39;, \u0026#39;auth.basic\u0026#39; =\u0026gt; \u0026#39;Illuminate\\Auth\\Middleware\\AuthenticateWithBasicAuth\u0026#39;, \u0026#39;guest\u0026#39; =\u0026gt; \u0026#39;App\\Http\\Middleware\\RedirectIfAuthenticated\u0026#39;, ]; }  在 app\\Http\\Kernel.php 類別中，$middleware 變數是設定全域中介層堆疊清單，每一個 Http Request 都會依序經過 $middleware 所有的中介層做判斷\n$middleware 中介層判斷完後都沒問題，才丟給路由中介層 $routeMiddleware 做處理（若路由有設定要使用哪個中介層的話，沒有設定則略過）。\n當我們有自己的中介層，我們可以依自己需求看要將中介層設定加到哪一個變數設定中，如果需要每一個 Request 都做檢查的話，則將中介層設定到 $middleware，否則設定在。 $routeMiddleware 並指定中介層名稱即可。\n在 Controller 使用中介層 我們可以強制設定，當使用者要存取文章的資源時都必須要登入，所以在 ArticleController 控制器的建構子，我們可以用 $this-\u0026gt;middleware('auth'); 設定全部 ArticleController 中的函式皆使用 auth 中介層。\n auth 中介層名稱是參照 app\\Http\\Kernel.php 中的 $routeMiddleware 變數設定\n class ArticleController extends Controller { public function __construct() { $this-\u0026gt;middleware(\u0026#39;auth\u0026#39;); } // 新增文章 public function store(Requests $request) { } } 我們也可以使用 only 方式，指定中介層只有在指定的函式中才使用，或是使用 except 方式指定除了某些函式不使用中介層外，其他都要使用中介層當作過濾\n// 只有設定的函式使用中介層 $this-\u0026gt;middleware(\u0026#39;auth\u0026#39;, [\u0026#39;only\u0026#39;=\u0026gt;\u0026#39;create\u0026#39;]); // 只有設定的函式\u0026#34;不要\u0026#34;使用中介層 $this-\u0026gt;middleware(\u0026#39;auth\u0026#39;, [\u0026#39;except\u0026#39;=\u0026gt;\u0026#39;index\u0026#39;]);  在 Route 使用中介層 // app\\Http\\routes.php Route::get(\u0026#39;about\u0026#39;, [ \u0026#39;middleware\u0026#39; =\u0026gt; \u0026#39;auth\u0026#39;, \u0026#39;uses\u0026#39;=\u0026gt; \u0026#39;HomeController@about\u0026#39; ]); 建立自己的中介層 我們可以使用指令建立自己的 Middleware，假如我建立一個 KeJyunMiddleware 為名稱的中介層，可以在命令列輸入：\n$ php artisan make:middleware KeJyunMiddleware 建立的中介層會放在 app\\Http\\Middleware\\KeJyunMiddleware.php 中\n\u0026lt;?php namespace App\\Http\\Middleware; // app\\Http\\Middleware\\KeJyunMiddleware.php  use Closure; class KeJyunMiddleware { public function handle($request, Closure $next) { return $next($request); } } 建立好自訂的中介層之後，到 app\\Http\\Kernel.php 註冊中介層後即可使用\n\u0026lt;?php namespace App\\Http; // app\\Http\\Kernel.php  class Kernel extends HttpKernel { protected $routeMiddleware = [ \u0026#39;kejyun\u0026#39; =\u0026gt; \u0026#39;App\\Http\\Middleware\\KeJyunMiddleware\u0026#39;, ]; } 參考資料  Ogres Are Like Middleware - Laracasts  "
},
{
	"uri": "https://laravel5-book.kejyun.com/http/middleware/",
	"title": "中介層（Middleware）",
	"tags": [],
	"description": "",
	"content": "這裏會介紹如何在 Laravel 處理 中介層（Middleware）。\n"
},
{
	"uri": "https://laravel5-book.kejyun.com/services/errors-logs/errors-log-macro/",
	"title": "日誌巨集",
	"tags": [],
	"description": "",
	"content": "日誌巨集 前言 我們會用 Laravel 內建的 Response 去回應服務的訊息，我們可能會用的回應會像這樣：\n// 建立 JSON 回應 return Response::json([\u0026#39;name\u0026#39; =\u0026gt; \u0026#39;KeJyun\u0026#39;, \u0026#39;Country\u0026#39; =\u0026gt; \u0026#39;Taiwan\u0026#39;]); return response()-\u0026gt;json([\u0026#39;name\u0026#39; =\u0026gt; \u0026#39;KeJyun\u0026#39;, \u0026#39;Country\u0026#39; =\u0026gt; \u0026#39;Taiwan\u0026#39;]); // 建立 JSONP 回應 return Response::json([\u0026#39;name\u0026#39; =\u0026gt; \u0026#39;KeJyun\u0026#39;, \u0026#39;Country\u0026#39; =\u0026gt; \u0026#39;Taiwan\u0026#39;]) -\u0026gt;setCallback($request-\u0026gt;input(\u0026#39;callback\u0026#39;)); return response()-\u0026gt;json([\u0026#39;name\u0026#39; =\u0026gt; \u0026#39;KeJyun\u0026#39;, \u0026#39;Country\u0026#39; =\u0026gt; \u0026#39;Taiwan\u0026#39;]) -\u0026gt;setCallback($request-\u0026gt;input(\u0026#39;callback\u0026#39;)); // 建立檔案下載的回應 return response()-\u0026gt;download($pathToFile); return response()-\u0026gt;download($pathToFile, $name, $headers); return response()-\u0026gt;download($pathToFile)-\u0026gt;deleteFileAfterSend(true); 在這樣的使用下，我們可以很容易的回應訊息給使用者，但是在伺服器發生程式例外錯誤 (Exception) 時，我們可能也需要回應像是這樣的資料：\nreturn Response::json([\u0026#39;status\u0026#39; =\u0026gt; \u0026#39;failure\u0026#39;, \u0026#39;error_code\u0026#39; =\u0026gt; \u0026#39;5566\u0026#39;]); return response()-\u0026gt;json([\u0026#39;status\u0026#39; =\u0026gt; \u0026#39;failure\u0026#39;, \u0026#39;error_code\u0026#39; =\u0026gt; \u0026#39;5566\u0026#39;]); 在我們用 Laravel 做 API 給手機用的時候，更需要有這些錯誤狀態的資料，所以我們沒辦法直接像網頁一樣跳出整個的錯誤 debug 畫面\n但我們若想在 API 回應給手機這樣的錯誤資訊時，也能夠將例外錯誤記錄下來，以便我們進行除錯，我們可以做一個 Response 的巨集，去處理紀錄我們的回應\n 建立服務提供者 我們在命令列輸入 php artisan make:provider ResponseServiceProvider 建立回應的服務提供者\n$ php artisan make:provider ResponseServiceProvider 該服務提供者檔案會被建立在 app/Providers/ResponseServiceProvider.php 中，命名空間為 App\\Providers\\ResponseServiceProvider\n 我們不一定要將服務提供者的檔案放到 app/Providers 目錄中，我們可以依照自己專案的需求，將他移動到像是 app/KeJyun/Providers 目錄中，這樣命名空間就會變成 App\\KeJyun\\Providers\\ResponseServiceProvider，檔案放置的位置隨自己專案需求而定，只要遵照 PSR-4 的規定去設定命名空間及檔案位置即可\n 我新增了一個名稱為 jsonLog 的 Response 巨集，該巨集會回應 json 資料，並依照記錄層級紀錄我們傳給他的資訊，ResponseServiceProvider 程式會像這樣\n\u0026lt;?php namespace App\\KeJyun\\Providers; // app/KeJyun/Providers/ResponseServiceProvider.php  use Illuminate\\Support\\ServiceProvider; use Response, Log; class ResponseServiceProvider extends ServiceProvider { /** * Bootstrap the application services. * * @return void */ public function boot() { /** * 註冊 Response 記錄錯誤巨集 * * @param Array $response_data 回傳的 json 資料 * @param Array|Object|String $log_data 紀錄的資料 * @param String $log_level 紀錄資料的等級（預設為 info） * * @return Response $response 回應的 json 資料 * * @access public * @author KeJyun kejyun@gmail.com * @date 2015-06-06 */ Response::macro(\u0026#39;jsonLog\u0026#39;, function( $response_data, $log_data =\u0026#39;No Data Be log!!!\u0026#39;, $log_level = \u0026#39;info\u0026#39; ) { // 增加 Log檔案錯訊息間距以便閱讀  Log::debug(\u0026#34;\\n\\n\\n\\n\\n\u0026#34;); Log::debug($response_data); Log::debug(\u0026#34;\\n\\n\u0026#34;); switch ($log_level) { case \u0026#39;debug\u0026#39;: Log::debug($log_data); break; case \u0026#39;notice\u0026#39;: Log::notice($log_data); break; case \u0026#39;warning\u0026#39;: Log::warning($log_data); break; case \u0026#39;error\u0026#39;: Log::error($log_data); break; case \u0026#39;critical\u0026#39;: Log::critical($log_data); break; case \u0026#39;alert\u0026#39;: Log::alert($log_data); break; case \u0026#39;info\u0026#39;: default: Log::info($log_data); break; } // 增加 Log檔案錯訊息間距以便閱讀  Log::debug(\u0026#34;\\n\\n\\n\\n\\n\u0026#34;); return Response::json($response_data); }); } /** * Register the application services. * * @return void */ public function register() { //  } }  設定服務提供者 設定完自己的 jsonLog 紀錄巨集後，我們需要到 config/app.php 設定這個 Response 服務提供者，我的命名空間為 App\\KeJyun\\Providers\\ResponseServiceProvider，所以設定會像這樣：\n// config/app.php \u0026#39;providers\u0026#39; =\u0026gt; [ // 其他的服務提供者 \u0026#39;App\\KeJyun\\Providers\\ResponseServiceProvider\u0026#39;, ], 設定完之後，Laravel 在啟動時就會自動載入該服務提供者了\n使用自定的 Response 巨集 jsonLog 在我們撰寫商業邏輯時若發生無法預期的例外狀況，我們會想要紀錄該例外狀況的資料，我們就可以這樣使用 Response jsonLog 巨集：\ntry{ // 商業邏輯處理 } catch (Exception $exception) { $response_data = [ \u0026#39;status\u0026#39;=\u0026gt;\u0026#39;failure\u0026#39;, \u0026#39;error_code\u0026#39;=\u0026gt;5566, ]; return response()-\u0026gt;jsonLog($response_data, $exception, \u0026#39;alert\u0026#39;); } 這樣在系統發生預期之外的例外時，我們也有參考的資料可以幫我們進行除錯了！！\n參考資料  HTTP 回應：回應巨集 - Laravel.tw 服務提供者 - Laravel.tw  "
},
{
	"uri": "https://laravel5-book.kejyun.com/services/queue/",
	"title": "隊列（Queue）",
	"tags": [],
	"description": "",
	"content": "這裏介紹 Laravel 提供的隊列（Queue）功能\n"
},
{
	"uri": "https://laravel5-book.kejyun.com/services/queue/queue-async/",
	"title": "非同步資料庫隊列（Async Database Queue）",
	"tags": [],
	"description": "",
	"content": "非同步資料庫隊列（Async Database Queue） 在我們使用 Laravel 提供的資料庫隊列（Database Queue）時，我們需要在命令列執行 php artisan queue:listen 指令，持續的去監聽是否有需要執行的 Queue。\nbarryvdh/laravel-async-queue 隊列套件，可以讓我們不用持續的監聽隊列資料，並在使用隊列時，立即的使用 shell 在背景執行隊列的工作。\n目前（2015-06-01） 套件 0.4.x 版本有支援 Laravel 5\n安裝 $ composer require \u0026#39;barryvdh/laravel-async-queue:0.4.*@dev\u0026#39;  加入 Service Provider 在 config/app.php 檔案中加入 'Barryvdh\\Queue\\AsyncServiceProvider'\n// config/app.php return [ \u0026#39;providers\u0026#39; =\u0026gt; [ \u0026#39;Barryvdh\\Queue\\AsyncServiceProvider\u0026#39;, ] ]; 產生隊列資料表 barryvdh/laravel-async-queue 隊列套件使用原生的資料庫隊列資料表（Database Queue）去時做的，所以我們可以使用 php artisan queue:table 指令去產生隊列的 Migration\n$ php artisan queue:table 所以執行命令後，你可以找到像是 database/migrations/2015_05_26_225627_create_queue_jobs_table.php 這樣的隊列 Migration 檔案\n Migration 檔名日期 2015_05_26_225627 每個人皆不同，會依照你建立當時的時間去產生\n 產生的隊列 Migration 會長的像這樣：\n\u0026lt;?php use Illuminate\\Database\\Schema\\Blueprint; use Illuminate\\Database\\Migrations\\Migration; class CreateQueueJobsTable extends Migration { /** * Run the migrations. * * @return void */ public function up() { Schema::create(\u0026#39;jobs\u0026#39;, function(Blueprint $table) { $table-\u0026gt;bigIncrements(\u0026#39;id\u0026#39;); $table-\u0026gt;string(\u0026#39;queue\u0026#39;); $table-\u0026gt;text(\u0026#39;payload\u0026#39;); $table-\u0026gt;tinyInteger(\u0026#39;attempts\u0026#39;)-\u0026gt;unsigned(); $table-\u0026gt;tinyInteger(\u0026#39;reserved\u0026#39;)-\u0026gt;unsigned(); $table-\u0026gt;unsignedInteger(\u0026#39;reserved_at\u0026#39;)-\u0026gt;nullable(); $table-\u0026gt;unsignedInteger(\u0026#39;available_at\u0026#39;); $table-\u0026gt;unsignedInteger(\u0026#39;created_at\u0026#39;); }); } /** * Reverse the migrations. * * @return void */ public function down() { Schema::drop(\u0026#39;jobs\u0026#39;); } }  建立隊列資料表 執行 php artisan migrate 將隊列資料表新增至資料庫\n設定隊列驅動 在 config/queue.php 檔案中設定非同步資料庫隊列（Async Database Queue）驅動設定，設定如下：\n// config/queue.php return [ \u0026#39;default\u0026#39; =\u0026gt; \u0026#39;async\u0026#39;, \u0026#39;connections\u0026#39; =\u0026gt; [ \u0026#39;async\u0026#39; =\u0026gt; [ \u0026#39;driver\u0026#39; =\u0026gt; \u0026#39;async\u0026#39;, \u0026#39;table\u0026#39; =\u0026gt; \u0026#39;jobs\u0026#39;, \u0026#39;queue\u0026#39; =\u0026gt; \u0026#39;default\u0026#39;, \u0026#39;expire\u0026#39; =\u0026gt; 60, \u0026#39;connection_name\u0026#39;=\u0026gt;\u0026#39;\u0026#39;, ], ], ];  建立隊列工作 我們可以使用 \\Queue::push('App\\Commands\\SendEmail@fire', $queue_data); 的方法去新增要執行的隊列\n第一個參數是執行隊列需要呼叫的類別名稱位置（App\\Commands\\SendEmail）及方法（fire）\n類別名稱需要正確的指定類別的命名空間（namespace），可以指定這個隊列要執行的類別方法，只要將方法使用 @ 加在後方即可（@customMethod）\n若沒有指定用哪個方法，Laravel 預設會執行 fire 的類別方法（@fire）\n我們使用隊列來寄送 Email，設定隊列的方式大概像這樣：\n// 需要傳送給隊列處理的資料 $queue_data = [ \u0026#39;email\u0026#39; =\u0026gt; \u0026#39;kejyun@gmail.com\u0026#39;, \u0026#39;name\u0026#39; =\u0026gt; \u0026#39;KeJyun\u0026#39;, ]; // 建立隊列 $queue_id = \\Queue::push(\u0026#39;App\\Commands\\SendEmail@fire\u0026#39;, $queue_data); 在 App\\Commands\\Sendmail.php 檔案大概會像這樣：\n\u0026lt;?php namespace App\\Commands; class SendEmail { /** * 執行隊列 * * @return void */ public function fire($job, $data) { // 寄送 Email  \\Mail::send(\u0026#39;emails.welcome\u0026#39;, [], function($message) use ($data) { $message-\u0026gt;to($data[\u0026#39;email\u0026#39;], $data[\u0026#39;name\u0026#39;])-\u0026gt;subject(\u0026#39;歡迎使用 Laravel 5 資料庫隊列寄送 Email!!!\u0026#39;); }); } } 這樣我們就可以正常的使用隊列去幫我們寄信摟！！\n 目前（2015-06-01） barryvdh/laravel-async-queue 在執行完隊列時，無法直接刪除隊列資料，待作者修復這個 bug\n 參考資料  隊列 - Laravel.tw Queues in Laravel with Redis barryvdh/laravel-async-queue - packagist Laravel 5 Async Queue Driver - Github  "
},
{
	"uri": "https://laravel5-book.kejyun.com/environment/install-composer/",
	"title": "Composer 安裝",
	"tags": [],
	"description": "",
	"content": "Composer 安裝 Carbon 1 is deprecated, see how to migrate to Carbon 2. 在安裝 Laravel 時會跑出 Carbon 的版本過舊問題\n$ composer install Loading composer repositories with package information Installing dependencies (including require-dev) from lock file Warning: The lock file is not up to date with the latest changes in composer.json. You may be getting outdated dependencies. Run update to update them. Nothing to install or update Package phpunit/phpunit-mock-objects is abandoned, you should avoid using it. No replacement was suggested. Generating optimized autoload files Carbon 1 is deprecated, see how to migrate to Carbon 2. https://carbon.nesbot.com/docs/#api-carbon-2 You can run './vendor/bin/upgrade-carbon' to get help in updating carbon and other frameworks and libraries that depend on it. 建議我們將 Carbon 升級到 Carbon 2，但因為 Carbon 2 至少要 Laravel 5.8，但線上專案因為是用 Laravel 5.5，無法升級，所以可以在 composer 加入此套件即可向下相容\n{ \u0026quot;require\u0026quot;: { \u0026quot;nesbot/carbon\u0026quot;: \u0026quot;2.21.3 as 1.34.0\u0026quot; \u0026quot;kylekatarnls/laravel-carbon-2\u0026quot;: \u0026quot;^1.0.0\u0026quot; } } 參考資料  陈华博客 | Laravel5.5执行composer update报错问题 - 陈华编程学院 Carbon - A simple PHP API extension for DateTime.  "
},
{
	"uri": "https://laravel5-book.kejyun.com/database/model/eloquent-magic-function/",
	"title": "Eloquent 魔術函式",
	"tags": [],
	"description": "",
	"content": "Eloquent 魔術函式 預先處理被異動的欄位資料 在使用 Eloquent 新增或異動資料時，我們可能想要對輸入的資料做預先的處理，我們可以使用 Laravel 提供的魔術函式 setNameAttribute() 去預先處理欄位資料。\n如果我們要預先處理文章模型（Article）的發布時間欄位（published_at），我們的魔術函式就會是像：\nclass Article extends Model { public function setPublishedAtAttribute($date) { // 將傳入的 Y-m-d 時間設為 datetime 格式的現在時間 $this-\u0026gt;attributes[\u0026#39;published_at\u0026#39;] = Carbon::createFromFormat(\u0026#39;Y-m-d\u0026#39;, $date); // 將傳入的 Y-m-d 時間設為 datetime 格式的凌晨零時 00:00:00 $this-\u0026gt;attributes[\u0026#39;published_at\u0026#39;] = Carbon::parse($date); } }  魔術函式 setNameAttribute() 中，若遇到欄位名稱有底線的狀況，則將名稱設為駝峰式大小寫（Camel-Case），像是 published_at 則變成 PublishedAt\n  自定義 query 處理函式 假如我們要讀取發表的文章，但是發表的時間 published_at 必須過去的時間，設定於未來發表時間的文章不能被撈取出來，我們可以用這樣的方式去撈取：\n// 取得已經發表的文章，依照發表時間降冪（Desc）排序 $article = \\App\\Article::latest(\u0026#39;published_at\u0026#39;) -\u0026gt;where(\u0026#39;published_at\u0026#39;, \u0026#39;\u0026lt;=\u0026#39;, Carbon::now()) -\u0026gt;get(); 我們可以簡化這個 query，把它寫在 Model 用函式的方式做處理，這樣我們就可以用這樣去取得已發表的文章：\n// 取得已經發表的文章，依照發表時間降冪（Desc）排序 $article = \\App\\Article::latest(\u0026#39;published_at\u0026#39;) -\u0026gt;published() -\u0026gt;get(); 而 Model 裡面我們用 scopeName 魔術函式的方式去設定 published()：\nclass Article extends Model { public function scopePublished($query) { $query-\u0026gt;where(\u0026#39;published_at\u0026#39;, \u0026#39;\u0026lt;=\u0026#39;, Carbon::now()); } } 若我們想要取得尚未被發表的文章資訊，我們模式函式也可以設定成：\nclass Article extends Model { public function scopeUnpublished($query) { $query-\u0026gt;where(\u0026#39;published_at\u0026#39;, \u0026#39;\u0026gt;\u0026#39;, Carbon::now()); } } 這樣我們就可以用 unpublished() 去設定取得文章資訊了\n// 取得已經發表的文章，依照發表時間降冪（Desc）排序 $article = \\App\\Article::latest(\u0026#39;published_at\u0026#39;) -\u0026gt;unpublished() -\u0026gt;get(); 這樣的優點是:\n 簡化程式的長度 讓我們在不同的地方不需要寫同樣落落長的查詢 讓查詢的可讀性增加，published() 與 unpublish() 我們不需要看查詢的語法條件就可以知道這個地方是要做什麼樣的查詢了  參考資料  Eloquent 101 - Laracast Dates, Mutators, and Scopes - Laracast Eloquent ORM - Laravel.tw  "
},
{
	"uri": "https://laravel5-book.kejyun.com/http/",
	"title": "Http",
	"tags": [],
	"description": "",
	"content": "這裏會介紹如何在 Laravel 處理 HTTP 請求。\n"
},
{
	"uri": "https://laravel5-book.kejyun.com/design-pattern/model/",
	"title": "Model",
	"tags": [],
	"description": "",
	"content": "Model 模型設計模式 我們在使用任何的 Framework 中，都會聽到 MVC 模型，V（View）是負責畫面顯示，C（Controller）是負責控制程式呼叫模型的邏輯，而最重要的 M（Model）是負責整個資料庫的操作，以及撈取資料的邏輯\n我們常常把模型用來作為處理資料的商業邏輯，不管是任何的「資料樣式的轉換」、「資料撈取的邏輯」、「資料格式的驗證」、「資料處理的順序及商業邏輯」\u0026hellip;等等都是放在模型（Model）去處理\n資料樣式的轉換\n// 2016-01-01 00:00:00.123789 $now = Carbon::now(); // 2016/01/01 $now_date = $now-\u0026gt;format(\u0026#39;Y/m/d\u0026#39;); 資料撈取的邏輯\n撈取所有的女會員資料，年紀小於 30 歲\nUser::where(\u0026#39;gender\u0026#39;=\u0026gt;\u0026#39;female\u0026#39;) -\u0026gt;where(\u0026#39;age\u0026#39;, \u0026#39;\u0026lt;\u0026#39;, 30) -\u0026gt;get(); 撈取所有的男會員資料，年紀大於 30 歲\nUser::where(\u0026#39;gender\u0026#39;=\u0026gt;\u0026#39;male\u0026#39;) -\u0026gt;where(\u0026#39;age\u0026#39;, \u0026#39;\u0026gt;\u0026#39;, 30) -\u0026gt;get(); 資料格式的驗證\n$validator = Validator::make(Request::all(), [ \u0026#39;title\u0026#39; =\u0026gt; \u0026#39;required|unique:posts|max:255\u0026#39;, \u0026#39;content\u0026#39; =\u0026gt; \u0026#39;required\u0026#39;, ]); 資料處理的順序及商業邏輯\n/** * 發送 Email 及簡訊給所有女會員 */ // 取得所有女會員資料 $users = User::where(\u0026#39;gender\u0026#39;=\u0026gt;\u0026#39;female\u0026#39;) -\u0026gt;get(); // 發送 Email foreach ($users as $u) { Mail::send(\u0026#39;emails.hello\u0026#39;, [\u0026#39;user\u0026#39; =\u0026gt; $u], function ($mail) use ($u) { $mail-\u0026gt;to($u-\u0026gt;email, $u-\u0026gt;name) -\u0026gt;subject(\u0026#39;安安!\u0026#39;); }); } // 發送簡訊 foreach ($users as $u) { SMS::send(\u0026#39;sms.hello\u0026#39;, [\u0026#39;user\u0026#39; =\u0026gt; $u], function ($sms) use ($u) { $sms-\u0026gt;to($u-\u0026gt;mobile_phone, $u-\u0026gt;name) -\u0026gt;content(\u0026#39;安安!\u0026#39;); }); }  如果把這些不同類別的資料全部丟到 Model 模型去處理會變得很亂，程式碼難以維護，所以我們會用設計模式來降低程式碼的耦合性，讓程式變得容易維護，我們會將 Model 分成：\n 實體（Entity） 資源庫（Repository） 服務（Service） 表單驗證（Form） 資料呈現（Presenter） ARCA 架構檔案結構  實體（Entity） 實體就是我們用來設定 Eloquent Model 的相關設定，像是資料表名稱（$table）、主鍵名稱（$primaryKey) 等等，裡面除了 Eloquent 相關設定以外，不要擺任何的商業邏輯或資料撈取方法\n實體與資料表的關係是「1 對 1」的關係，有幾個資料表就有幾個實體\n 詳情請見Eloquent Model (模型) - 設定\n 資源庫（Repository） 資源庫是我們要用來撈取資料表資料的各個邏輯，我們資料表會有不同的欄位，不同的欄位條件代表不同的意義，像是：\n撈取所有的女會員資料，年紀小於 30 歲\nUser::where(\u0026#39;gender\u0026#39;=\u0026gt;\u0026#39;female\u0026#39;) -\u0026gt;where(\u0026#39;age\u0026#39;, \u0026#39;\u0026lt;\u0026#39;, 30) -\u0026gt;get(); 撈取所有的男會員資料，年紀大於 30 歲\nUser::where(\u0026#39;gender\u0026#39;=\u0026gt;\u0026#39;male\u0026#39;) -\u0026gt;where(\u0026#39;age\u0026#39;, \u0026#39;\u0026gt;\u0026#39;, 30) -\u0026gt;get(); 這些不同的撈取資料邏輯，我會將它包在資源庫中，該資源庫長得會像這樣：\nclass UserRepository { /** * 撈取所有的女會員資料，年紀小於 30 歲 */ public function getYoungFemale() { return User::where(\u0026#39;gender\u0026#39;=\u0026gt;\u0026#39;female\u0026#39;) -\u0026gt;where(\u0026#39;age\u0026#39;, \u0026#39;\u0026lt;\u0026#39;, 30) -\u0026gt;get(); } /** * 撈取所有的男會員資料，年紀大於 30 歲 */ public function getOldMale() { return User::where(\u0026#39;gender\u0026#39;=\u0026gt;\u0026#39;male\u0026#39;) -\u0026gt;where(\u0026#39;age\u0026#39;, \u0026#39;\u0026gt;\u0026#39;, 30) -\u0026gt;get(); } } 這樣我們撈取這些不同資料邏輯時就可以這樣去撈取：\n$userRepository = new UserRepository(); // 撈取所有的女會員資料，年紀小於 30 歲 $young_female_user = $userRepository-\u0026gt;getYoungFemale(); // 撈取所有的男會員資料，年紀大於 30 歲 $old_male_user = $userRepository-\u0026gt;getOldMale(); 這樣除了可以讓程式碼易讀性提高之外，撈取資料的邏輯也可以抽離出來，下次如果有需要撈取同樣的資料時，就可以重複的去使用它，而且不會有重複的程式碼出現在專案的各個地方，讓管理程式碼變得簡單\n資源庫與實體的關係是「1 對 1」的關係，有幾個實體就有幾個資源庫，每個資源庫是代表那個實體的各個不同的資料撈取邏輯\n 服務（Service） 服務代表我們程式要處理資料的商業邏輯，我會將各個功能邏輯獨立成一個服務，像是使用者「註冊身份驗證」是一個服務，而使用者「個人隱私設定」也是一個服務\n服務與資源庫的關係是「多 對 1」的關係，像是同樣使用者資料，有「註冊身份驗證」及「個人隱私設定」2 種不同類型的服務\n使用者「註冊身份驗證」服務\n/** * 使用者「註冊身份驗證」服務 */ class UserAuthService { /** * 註冊 */ public function signup() { } /** * 登入驗證 */ public function signin() { } } 使用者「個人隱私設定」服務\n/** * 使用者「個人隱私設定」服務 */ class UserPrivacyService extends AnotherClass { /** * 取得使用者隱私設定 */ public function getUserPrivacy() { } /** * 設定使用者隱私 */ public function setUserPrivacy() { } } 不同類型的服務，只要彼此耦合性很低，我傾向把他分成不同的服務去處理，這樣可以很清楚的知道哪個個服務是專門處理哪一種商業邏輯，程式也比較好管理，在異動程式時也比較不會影響到彼此，避免牽一髮動全身的狀況發生\n 表單驗證（Form） 我們設計後端程式的原則，是不要相信任何第三方傳來的資料，在資料做進一步處理時都需要對資料格式做檢查，若於我們設定的資料格式相符，我們才會去做進一步的資料商業邏輯處理\n但是我們可能會在控制器（Controller）做表單資料的驗證，但是服務（Service）、資源庫（Repository）或實體（Entity）為了保護自己的程式邏輯，也有可能去做表單資料的驗證，若每一個階段都做表單資料的驗證，這樣不僅造成了資料發生重複驗證的狀況，也會降低程式的執行速度，更慘的是會造成驗證程式重複出現，如果有驗證規則要修改，我們就必須要確保所有有驗證表單資料的地方，都有正確的被修改，不然程式的商業邏輯可能會沒辦法順利的去執行。\n因為我們對模型做了分層地處理，所以模型的層級架構會像：\n 控制器 (Controller） \u0026gt; 服務（Service） \u0026gt; 資源庫（Repository） \u0026gt; 實體（Entity）\n 控制器會根據他需要的商業邏輯，呼叫不同的服務來處理他的程式邏輯，而且每個控制器，而且每個控制器可能會有不同類型的服務，可能會有使用者（User）的資料、文章（Posts）的資料\u0026hellip;等等需要做資料的驗證，所以驗證資料的規則複雜度會很多。\n我自己會傾向將所有的表單資料驗證都放在服務（Service）中去驗證，不同的商業邏輯可能需要驗證的資料規則不同，但是我們可以確定的是，同一個服務會是同一個類型的資料，像是使用者「註冊身份驗證」服務及使用者「個人隱私設定」服務\u0026lt; 裡面的資料一定是使用者相關的資料，若我們也有文章的服務（PostService），我們也一定可以確保裡面的驗證資料一定是文章相關的資料。\n所以除了服務（Service）層去做資料的驗證外，其他的層級都不需要做任何的資料驗證！\n 資料呈現（Presenter） 我們會將需要處理不同資料樣式的邏輯，使用 laracasts/presenter 去做實體（Entity）的分層處理，不要將有程式邏輯的功能出現在實體（Entity）中\nARCA 架構檔案結構 我會將 Model 的檔案結構依照 Domain 去區分，檔案結構大概會像這樣\n/app /KeJyunApp /User /Entities User.php UserPrivacy.php /Repositories UserRepository.php UserPrivacyRepository.php /Service UserAuthService.php UserPrivacyService.php /Form UserForm.php UserPrivacyForm.php /Presenter UserPresenter.php UserPrivacyPresenter.php /Post /Entities Post.php /Repositories /Service /Form /Presenter 這樣區分的好處是，類似功能的程式可以方便集中管理，當我們在撰寫某一功能的程式，我們可以很快地在同一個資料夾中找到這些檔案，若要找其他功能的程式時，也可以在同一個資料夾很快地去找到\n如果我們將程式檔案依照功能去放置，可能會像這樣\n/app /SomeApp /Entities User.php Post.php Tags.php News.php Event.php ... /Repositories /Service UserAuthService.php UserPrivacyService.php UserStatisticService.php PostManageService.php PostRankService.php PostStatisticService.php TagsService.php NewsService.php EventService.php ... /Form /Presenter  當專案還小，只有少數幾個模型資料需要管理時，還沒有什麼大的問題，但是當我們撰寫很多複雜功能時，這樣檔案管理的方式會是個很大的夢靨，像是服務（Service）與資源庫（Repository）的關係是「多 對 1」的關係，所以服務（Services）資料夾的檔案可能有 40~50 個以上，在我們要找相關的檔案時，就很考驗我們的眼力了（工程師的眼睛是很珍貴的，我們要好好的珍惜～）\n參考資料  在 Laravel 4 使用資源庫 (Repositories) 及服務 (Services) 去降低程式的耦合性 胖胖Model減重的五個方法 by howtomakeaturn PHP 也有 Day #16 - 胖胖 Model 減重的五個方法 by 尤川豪  "
},
{
	"uri": "https://laravel5-book.kejyun.com/database/qa/cannot-mass-insert-with-extend-model/",
	"title": "使用中繼模型繼承 Eloquent 模型造成無法使用大量資料新增",
	"tags": [],
	"description": "",
	"content": "使用中繼模型繼承（extends）Eloquent 模型造成無法使用大量資料新增（Mess Assignment） 大部份的情況可能專案較小，所以我們會直接使用模型（Model）去新增資料，但若專案較大時，且不同的模型之間有共用的方法的話，我會會希望這些模型繼承同一個 Eloquent 模型的中繼類別物件，就像這樣：\nEloquent 模型的中繼類別物件\nclass CustomBaseModel extends Model { public $someVariable = null; public function doSomething() { } } 使用者模型繼承「Eloquent 模型的中繼類別物件」\nclass User extends CustomBaseModel { protected $fillable = [\u0026#39;first_name\u0026#39;, \u0026#39;last_name\u0026#39;, \u0026#39;email\u0026#39;]; } 使用這樣的中繼類別時，如果我們只有設定變數或實作中繼模型類別方法時，我們可以運作的很正常，但是如果我們需要實作中繼類別的建構子__construct()時，我們必須要時做原本 Eloquent Model 類別的建構子，否鑿會無法正常的運作原有的 Eloquent 模型\n在 vendor/laravel/framework/src/Illuminate/Database/Eloquent/Model.php Eloquent 模型的檔案中，我們可以看到建構子__construct()有需要傳入資料表欄位的屬性值 $attributes。\n// vendor/laravel/framework/src/Illuminate/Database/Eloquent/Model.php abstract class Model implements ArrayAccess, Arrayable, Jsonable, JsonSerializable, QueueableEntity, UrlRoutable { public function __construct(array $attributes = array()) { $this-\u0026gt;bootIfNotBooted(); $this-\u0026gt;syncOriginal(); $this-\u0026gt;fill($attributes); } }  這個部分是用來做大量資料新增或異動時（Mass Assignment）需要用到的資料，所以如果我們在中繼類別沒有實作這個建構子__construct()，會讓我們的完整 Eloquent Model 出現問題\n所以在 Eloquent 中繼類別中我們必須要時作的建構子__construct()會長的像這樣：\nclass CustomBaseModel extends Model { public $someVariable = null; function __construct(array $attributes = array()) { parent::__construct($attributes); // 做中繼類別建構子想要做的事 $this-\u0026gt;someVariable = \u0026#39;5566\u0026#39;; } } 我們的中繼類別，需要傳入資料表欄位的屬性值 $attributes，並執行母類別 Eloquent Model 的建構子，這樣我們的 Eloquent 模型就能夠正常運作了！\n"
},
{
	"uri": "https://laravel5-book.kejyun.com/design-pattern/learning-resource/",
	"title": "學習資源",
	"tags": [],
	"description": "",
	"content": "學習資源 文章  框架不應該有「MODELS」資料夾  投影片  胖胖Model減重的五個方法 by howtomakeaturn  影片  PHP 也有 Day #16 - 胖胖 Model 減重的五個方法 by 尤川豪  Repository  recca0120/laravel-repository: Repository Design Pattern for Laravel 5 with Eloquent or Collection  "
},
{
	"uri": "https://laravel5-book.kejyun.com/database/qa/",
	"title": "資料庫常見問題",
	"tags": [],
	"description": "",
	"content": "資料庫常見問題 這裏會列出一些 Laravel 在處理資料庫會遇到的一些常見的問題\n"
},
{
	"uri": "https://laravel5-book.kejyun.com/hosting/mysql/hosting-install-mysql57/",
	"title": "安裝 MySQL 5.7",
	"tags": [],
	"description": "",
	"content": "安裝 MySQL 5.7 設定 MySQL 5.7 套件資源庫 目前（2016/03） MySQL 5.7 沒有在 Ubuntu 的預設套件庫中，所以若要使用 MySQL 5.7 的話，則必須要設定加入此套件庫，這樣我們才能在 Ubuntu 安裝 MySQL 5.7\nwget http://dev.mysql.com/get/mysql-apt-config_0.6.0-1_all.deb sudo dpkg -i mysql-apt-config_0.6.0-1_all.deb sudo dpkg-reconfigure mysql-apt-config 設定使用 MySQL 當作預設安裝版本\n設定完成點 Apply 完成設定\n 更新套件資源庫 加入新的套件資源庫後，必須進行系統套件清單更新，才能夠讀取到新的套件設定\nsudo apt-get update 安裝 MySQL sudo apt-get install mysql-server-5.7 這樣就完成 MySQL 5.7 的安裝了！\n參考資料  MySQL :: A Quick Guide to Using the MySQL APT Repository MySQL :: Download MySQL APT Repository  "
},
{
	"uri": "https://laravel5-book.kejyun.com/resource/resource-jobs/",
	"title": "工作",
	"tags": [],
	"description": "",
	"content": "工作  LaraJobs Laravel Consultants and Freelancers + Laravel Gurus WithLaravel - The job board for Laravel projects and developers  "
},
{
	"uri": "https://laravel5-book.kejyun.com/package/line-bot/",
	"title": "Line Bot",
	"tags": [],
	"description": "",
	"content": "Line Bot 登入管理平台\n登入 LINE Official Account Manager 後，點選上方 Response mode 將模式改為 Bot\n啟用 Webhook\n在 Response settings 頁面，確認 Response mode 為 Bot\n將 Auto-response 關閉，並啟用 Webhooks\n設定 Message API\n在 Messaging API 選單中，取得 Channel ID 及 Channel secret，並設定 Webhook URL\n當使用者輸入訊息時，則會呼叫此 URL\n 安裝 Line 套件\ncomposer require linecorp/line-bot-sdk 套件網址：line/line-bot-sdk-php: LINE Messaging API SDK for PHP\n取得 Access Token\n\u0026lt;?php // Line 頻道編號 $channel_id = \u0026#39;my-line-channel-id\u0026#39;; // Line 頻道密鑰 $channel_secret = \u0026#39;my-line-channel-secret\u0026#39;; $LineBot = new \\LINE\\LINEBot( new \\LINE\\LINEBot\\HTTPClient\\CurlHTTPClient(\u0026#39;\u0026#39;), [\u0026#39;channelSecret\u0026#39; =\u0026gt; $channel_secret] ); $Response = $LineBot-\u0026gt;createChannelAccessToken($channel_id); $channel_access_token = $Response-\u0026gt;getJSONDecodedBody(); $access_token = array_get($channel_access_token, \u0026#39;access_token\u0026#39;); 透過 Access Token 回覆訊息給使用者\n當使用者回覆你的 Line 帳號時，Line Bot 會將使用者回覆的訊息像下方這樣傳送給你，需要回覆給使用者時，可以回覆到這次的 replyToken\n PS: 每次的 replyToken 皆不同\n array ( 'events' =\u0026gt; array ( 0 =\u0026gt; array ( 'type' =\u0026gt; 'message', 'replyToken' =\u0026gt; 'd439xxxxxxx1fc48', 'source' =\u0026gt; array ( 'userId' =\u0026gt; 'xxxx', 'type' =\u0026gt; 'user', ), 'timestamp' =\u0026gt; 1565081621327, 'message' =\u0026gt; array ( 'type' =\u0026gt; 'text', 'id' =\u0026gt; '10343775297084', 'text' =\u0026gt; 'hi kejyun line bot', ), ), ), 'destination' =\u0026gt; 'Ued2b13xxxxxx804b', )  \u0026lt;?php // 取得 Line 傳送過來的資料 $input = request()-\u0026gt;all(); // 取得 Reply Token $reply_token = array_get($input, \u0026#39;events.0.replyToken\u0026#39;); // 回覆訊息給使用者 $textMessageBuilder = new \\LINE\\LINEBot\\MessageBuilder\\TextMessageBuilder(\u0026#39;Hello Line Friend\u0026#39;); $response = $bot-\u0026gt;replyMessage(reply_token, $textMessageBuilder); if ($response-\u0026gt;isSucceeded()) { // 回覆訊息成功  echo \u0026#39;Succeeded!\u0026#39;; Log::debug(\u0026#39;Success\u0026#39;); } else { // 回覆訊息失敗  Log::debug(\u0026#39;Fail\u0026#39;); Log::debug($response-\u0026gt;getHTTPStatus()); Log::debug($response-\u0026gt;getRawBody()); } 其他相關的 API 請參考 Messaging API reference\n參考資料  LINE Official Account Manager Messaging API reference line/line-bot-sdk-php: LINE Messaging API SDK for PHP  "
},
{
	"uri": "https://laravel5-book.kejyun.com/package/auth/oauth/package-auth-oauth2-refresh-token/",
	"title": "Refresh Token",
	"tags": [],
	"description": "",
	"content": "OAuth2 Refresh Token 設定 config 在 config/oauth2.php 檔案中加入下列設定，並設定你的 token 存活時間(access_token_ttl) 及 refresh token 存活時間(refresh_token_ttl) 單位時間為秒\n 注意，若使用 Refresh Token 時，必須至少有 Password Grant 或 Auth Code Grant 的這兩種 OAuth2 驗證方法其中一種，然後在取得 Access token 時，會一併回傳 refresh token\n return [ \u0026#39;grant_types\u0026#39; =\u0026gt; [ \u0026#39;refresh_token\u0026#39; =\u0026gt; [ \u0026#39;class\u0026#39; =\u0026gt; \u0026#39;\\League\\OAuth2\\Server\\Grant\\RefreshTokenGrant\u0026#39;, \u0026#39;access_token_ttl\u0026#39; =\u0026gt; 3600, \u0026#39;refresh_token_ttl\u0026#39; =\u0026gt; 36000 ] ] ]; 使用 Password Grant 取得 Access token 及 Refresh Token 在我們取得 Access token 的資料欄位中填入下列欄位\n   欄位名稱 資料     grant_types password   username kejyun@gmail.com   password 123456   client_id KeJyun   client_secret KeJyunSecret     client_id 與 client_secret 為在 OAuth 套件說明頁 建立的\n  username 與 password 是你專案的使用者驗證資料，端看你驗證的 callback 如何定義這兩個欄位的資料，驗證成功後回傳使用者的編號給 OAuth2 記錄即可\n 送出到我們設定的 /oauth/access_token 路由後，我們就可以直接取得 access_token，並回傳此 token 失效的時間 expires_in 為我們設定的 access_token_ttl，還有 refresh_token 可以讓我們直接更新取得新的可用 token\n 使用 Refresh Token 取得的新的 Access token 權限與先前的 Access token 會完全相同\n  透過 Refresh Token 取得新的 Access Token 在我們取得 Access token 的資料欄位中填入下列欄位\n   欄位名稱 資料     grant_types refresh_token   refresh_token Z9pBcvzzBquBzR01MrfYYWMECgVKlkCxTlkkU9zf   client_id KeJyun   client_secret KeJyunSecret    這樣我們就可以直接透過 Refresh Token 取得新的可使用者 Access Token，而不用再透過使用者帳號密碼去取得可使用的 Access Token\n 相關資料表 OAuth2 會將 token 記錄在 oauth_access_tokens 資料表，並將關聯的使用者記錄在 oauth_sessions 資料表，在 oauth_sessions 中的 owner_id 則為我們剛剛回傳的使用者編號\n並在 oauth_refresh_tokens 資料表中記錄 Refresh Token 是屬於哪一個 Access Token，並透過這個關聯去產生新的 Access Token 與新的 Refresh Token\n參考資料  Refresh Token  "
},
{
	"uri": "https://laravel5-book.kejyun.com/database/postgresql/",
	"title": "PostgreSQL",
	"tags": [],
	"description": "",
	"content": "PostgreSQL 這裏會介紹如何在 Laravel 使用 PostgreSQL 資料庫\n"
},
{
	"uri": "https://laravel5-book.kejyun.com/database/redis/",
	"title": "Redis",
	"tags": [],
	"description": "",
	"content": "Redis 這裏會介紹如何在 Laravel 使用 Redis\n"
},
{
	"uri": "https://laravel5-book.kejyun.com/http/middleware/etag-middleware/",
	"title": "ETag Middleware",
	"tags": [],
	"description": "",
	"content": "ETag Middleware 在我們的網站若資料未變更，我們會希望告訴請求資源的使用者，本資源未修改(304 Not Modified)，所以不用重複讀取資料，這樣可以節省我們傳輸資料頻寬。\n我可以用 Middleware 來達到 ETag 的效果\n建立 ETag Middleware  App\\Http\\Middleware\\ETagMiddleware.php\n \u0026lt;?php namespace App\\Http\\Middleware; use Closure; class ETagMiddleware { /** * Implement Etag support * * @param \\Illuminate\\Http\\Request $request * @param \\Closure $next * @return mixed */ public function handle($request, Closure $next) { // Get response  $response = $next($request); // 如果是 get request  if ($request-\u0026gt;isMethod(\u0026#39;get\u0026#39;)) { // 產生回應內容的 etag  $etag = md5($response-\u0026gt;getContent()); $requestEtag = str_replace(\u0026#39;\u0026#34;\u0026#39;, \u0026#39;\u0026#39;, $request-\u0026gt;getETags()); // 檢查 etag 是否變更  if($requestEtag AND ($requestEtag[0] == $etag OR $requestEtag[0] == \u0026#39;W/\u0026#39;.$etag)) { // 若 etag 相同，設定表頭為資料未修改  $response-\u0026gt;setNotModified(); } // 設定 etag  $response-\u0026gt;setEtag($etag); } // 傳送回應  return $response; } }  設定 Etag Middleware  app/Http/Kernel.php\n \u0026lt;?php namespace App\\Http; use Illuminate\\Foundation\\Http\\Kernel as HttpKernel; class Kernel extends HttpKernel { protected $middlewareGroups = [ \u0026#39;web\u0026#39; =\u0026gt; [ \\App\\Http\\Middleware\\ETagMiddleware::class, ], ]; 這樣我們就完成 Etag Middleware 的設定了!\n參考資料  Setting Etags in Laravel 5 - Matthew Daly\u0026rsquo;s Blog  "
},
{
	"uri": "https://laravel5-book.kejyun.com/services/errors-logs/service/errors-log-service-rollbar/",
	"title": "Rollbar",
	"tags": [],
	"description": "",
	"content": "Rollbar 1. 安裝\ncomposer require rollbar/rollbar-laravel 2. 設定 config/app.php\n Laravel 5.5 以上不用做這個設定\n \u0026lt;?php // config/app.php return [ \u0026#39;providers\u0026#39; =\u0026gt; [ Rollbar\\Laravel\\RollbarServiceProvider::class, ], ];  3. 設定 API KEY\n到 .env 檔案設定 API KEY，根據官方安裝引導可以取得此 API KEY\n# .env ROLLBAR_TOKEN=\u0026lt;API_KEY\u0026gt; 4. 發送錯誤訊息到 rollbar\ntry { throw new Exception(\u0026#39;Hello there is something wrong\u0026#39;); } catch (Exception $exception) { Log::debug($exception); Log::debug(\u0026#39;Hello my test\u0026#39;); }  5. 檢視 rollbar 錯誤訊息\n錯誤訊息 dashboard\n個別錯誤訊息\n參考資料  Error Tracking \u0026amp; Crash Reporting for Software Developers - Rollbar Rollbar Doc - Laravel  "
},
{
	"uri": "https://laravel5-book.kejyun.com/services/queue/queue-supervisor/",
	"title": "Supervisor 啟動 queue",
	"tags": [],
	"description": "",
	"content": "Supervisor 啟動 queue 安裝 Supervisor sudo apt-get install supervisor 設定檔案路徑 /etc/supervisor/conf.d 設定 vim /etc/supervisor/conf.d/laravel-worker.conf 設定檔案 [program:laravel-worker] process_name=%(program_name)s_%(process_num)02d command=php /home/forge/app.com/artisan artisan queue:work --queue=instant,high,medium,default,low --delay=1 --memory=512 --sleep=15 --tries=1 --env=dev --daemon autostart=true autorestart=true user=www-data numprocs=8 redirect_stderr=true stdout_logfile=/home/forge/app.com/worker.log 啟動 Supervisor sudo supervisorctl reread sudo supervisorctl update sudo supervisorctl start laravel-worker:*  停止 Supervisor sudo supervisorctl stop laravel-worker:* 重新啟動 Supervisor 若當 Laravel 設定檔有做異動時，需要重啟 Supervisor 以讀取新的設定\n# 重新啟動指定的 worker supervisorctl restart laravel-worker: # 重新啟動所有的 worker supervisorctl restart all 參考資料  Queues - Laravel - The PHP Framework For Web Artisans supervisord - how to restart only certain processes using supervisorctl? - Stack Overflow  "
},
{
	"uri": "https://laravel5-book.kejyun.com/services/unit-test/unit-test-login-and-upload-file/",
	"title": "單元測試登入及上傳檔案",
	"tags": [],
	"description": "",
	"content": "單元測試登入及上傳檔案 登入使用者 $User = User::find(12345); $this-\u0026gt;be($User); 上傳檔案 // 設定上傳檔案 $post_file = new UploadedFile($path, $name, filesize($path), \u0026#39;image/png\u0026#39;, null, true); // 呼叫上傳網址 $response = $this-\u0026gt;call(\u0026#39;POST\u0026#39;, \u0026#39;/photo/store\u0026#39;, [], [], $post_file); // 取得回傳內容 $content = json_decode($response-\u0026gt;getContent()); dump($content); 參考資料  php - How to test file upload in Laravel 5.2 - Stack Overflow How to mock authentication user on unit test in Laravel?  "
},
{
	"uri": "https://laravel5-book.kejyun.com/services/errors-logs/packages/",
	"title": "日誌套件",
	"tags": [],
	"description": "",
	"content": "這裏介紹 Laravel 提供的日誌套件功能\n參考資料  cr0wst/laravel-slack-log: Utilizes Laravel\u0026rsquo;s notifications to provide logging to slack at various levels. Inspired by Log4j. laravel - Send a slack notification every time Log::error is triggered - Stack Overflow laravel - Send a slack notification every time Log::error is triggered - Stack Overflow  "
},
{
	"uri": "https://laravel5-book.kejyun.com/services/helpers/",
	"title": "輔助方法 (Helpers)",
	"tags": [],
	"description": "",
	"content": "這裏介紹 Laravel 提供的輔助方法 (Helpers)功能\n"
},
{
	"uri": "https://laravel5-book.kejyun.com/database/model/eloquent-apply/",
	"title": "使用 Eloquent",
	"tags": [],
	"description": "",
	"content": "使用 Eloquent 新增資料 大量指定新增資料 // 新增 \\App\\User::Create([ \u0026#39;first_name\u0026#39;=\u0026gt; \u0026#39;KeJyun\u0026#39;, \u0026#39;last_name\u0026#39; =\u0026gt; \u0026#39;Hong\u0026#39;, \u0026#39;email\u0026#39; =\u0026gt; \u0026#39;kejyun@gmail.com\u0026#39;, ]);  填入要新增的資料 // 使用者的資料 $user_data = [ \u0026#39;first_name\u0026#39;=\u0026gt; \u0026#39;KeJyun\u0026#39;, \u0026#39;last_name\u0026#39; =\u0026gt; \u0026#39;Hong\u0026#39;, \u0026#39;email\u0026#39; =\u0026gt; \u0026#39;kejyun@gmail.com\u0026#39;, ]; $user = new \\App\\User; // 填入要新增的資料 $user-\u0026gt;fill($user_info); // 儲存資料 $user-\u0026gt;save(); "
},
{
	"uri": "https://laravel5-book.kejyun.com/view/",
	"title": "視圖 (View)",
	"tags": [],
	"description": "",
	"content": "這裏會介紹如何在 Laravel 5 處理視圖 (View)。\n"
},
{
	"uri": "https://laravel5-book.kejyun.com/environment/debug/",
	"title": "除錯",
	"tags": [],
	"description": "",
	"content": "環境除錯 Laravel 5 : Parse error: syntax error, unexpected \u0026lsquo;?\u0026rsquo;, expecting variable (T_VARIABLE) 當安裝 Laravel 5.5 時，出現 Parse error: syntax error, unexpected '?', expecting variable (T_VARIABLE) 的訊息\n You need to install PHP version 7.1 because nullable types were introduced in 7.1:\n ?string $value 要解決這個問題只需要使用 php \u0026gt; 7.1.3 版本即可\n參考資料  php - Laravel 5 : Parse error: syntax error, unexpected \u0026lsquo;?\u0026rsquo;, expecting variable (T_VARIABLE) - Stack Overflow  "
},
{
	"uri": "https://laravel5-book.kejyun.com/hosting/memcached/hosting-install-memcached/",
	"title": "安裝 Memcached",
	"tags": [],
	"description": "",
	"content": "安裝 Memcached 安裝 直接安裝 Ubuntu 的 Memcached 套件\nsudo apt-get install memcached sudo apt-get install libmemcached-dev libmemcached11 設定 php 7 Memcached 套件 php 7 讀取 Memcached 的套件還是在開發版，沒辦法直接使用 apt-get 去完成安裝，所以我們要自行下載開發版套件去進行編譯安裝\n安裝 php 7 套件編譯軟體 php7.0-dev 是為了執行 php7 的 phpize 而安裝的\nsudo apt-get install pkg-config sudo apt-get install php7.0-dev  下載 php Memcached 套件 git clone https://github.com/php-memcached-dev/php-memcached 切換開發版套件路徑 cd php-memcached git checkout -b php7 origin/php7 編譯 php7 Memcached 套件 phpize ./configure make make test sudo make install  設定載入 php7 memcached 套件 sudo vim /etc/php/7.0/cli/conf.d/20-memcached.ini sudo vim /etc/php/7.0/fpm/conf.d/20-memcached.ini 在 20-memcached.ini 檔案內設定\nextension=memcached.so 設定檔分別要在 cli 與 fpm 兩個地方\n cli 指的是 command line 的 php 執行擋 fpm 指的是 nginx 解析 php 的解譯器  記得兩邊都要設定\n重新啟動 php7.0-fpm 重新啟動之後，在網頁部分可以用 phpinfo(); 確認看看有沒有看到 Memcached 套件\nsudo service php7.0-fpm restart  查詢安裝結果 查詢 phpinfo Memcached 安裝結果\n查詢 php command line Memcached 安裝結果\n$ php -i | grep memcached /etc/php/7.0/cli/conf.d/20-memcached.ini, memcached memcached support =\u0026gt; enabled libmemcached version =\u0026gt; 1.0.18 memcached.compression_factor =\u0026gt; 1.3 =\u0026gt; 1.3 memcached.compression_threshold =\u0026gt; 2000 =\u0026gt; 2000 memcached.compression_type =\u0026gt; fastlz =\u0026gt; fastlz memcached.default_binary_protocol =\u0026gt; 0 =\u0026gt; 0 memcached.default_connect_timeout =\u0026gt; 0 =\u0026gt; 0 memcached.default_consistent_hash =\u0026gt; 0 =\u0026gt; 0 memcached.serializer =\u0026gt; php =\u0026gt; php memcached.sess_binary_protocol =\u0026gt; 1 =\u0026gt; 1 memcached.sess_connect_timeout =\u0026gt; 0 =\u0026gt; 0 memcached.sess_consistent_hash =\u0026gt; 1 =\u0026gt; 1 memcached.sess_lock_expire =\u0026gt; 0 =\u0026gt; 0 memcached.sess_lock_max_wait =\u0026gt; not set =\u0026gt; not set memcached.sess_lock_retries =\u0026gt; 5 =\u0026gt; 5 memcached.sess_lock_wait =\u0026gt; not set =\u0026gt; not set memcached.sess_lock_wait_max =\u0026gt; 2000 =\u0026gt; 2000 memcached.sess_lock_wait_min =\u0026gt; 1000 =\u0026gt; 1000 memcached.sess_locking =\u0026gt; 1 =\u0026gt; 1 memcached.sess_number_of_replicas =\u0026gt; 0 =\u0026gt; 0 memcached.sess_persistent =\u0026gt; 0 =\u0026gt; 0 memcached.sess_prefix =\u0026gt; memc.sess. =\u0026gt; memc.sess. memcached.sess_randomize_replica_read =\u0026gt; 0 =\u0026gt; 0 memcached.sess_remove_failed_servers =\u0026gt; 0 =\u0026gt; 0 memcached.sess_sasl_password =\u0026gt; no value =\u0026gt; no value memcached.sess_sasl_username =\u0026gt; no value =\u0026gt; no value memcached.sess_server_failure_limit =\u0026gt; 0 =\u0026gt; 0 memcached.store_retry_count =\u0026gt; 2 =\u0026gt; 2 Registered save handlers =\u0026gt; files user memcached 這樣我們就完成 Memcached 及在 php 7.0 Memcached 套件的安裝了\n參考資料  php-memcached-dev/php-memcached: memcached extension based on libmemcached library kasparsd/php-7-debian: Install PHP 7 on Debian/Ubuntu ServerPilot | How to Install the PHP Memcache Extension Installing PHP-7 with Memcached - Servers for Hackers  "
},
{
	"uri": "https://laravel5-book.kejyun.com/resource/resource-document/",
	"title": "文件",
	"tags": [],
	"description": "",
	"content": "文件 Laravel  A Laravel 5 Boilerplate Project Laravel Book Web development, design, and other nerdy topics! | Dayle Rees Laravel-簡潔、優雅的PHP開發框架(PHP Web Framework)。 - Laravel中文網Laravel中國社區 Simple Laravel ♥ Scotch Awesome Laravel Curso de Laravel 5 en español desde cero | styde.net Laravel Collective  PHP  Awesome PHP PHP-Tools SitePoint PHP – Learn PHP, MySQL, SOAP \u0026amp; more  設計模式  PSR 繁體中文   安裝  How to Setup Laravel 4 - Tuts+ Code Tutorial  指令函式  Laravel Cheat Sheet Laravel-Tricks.com  "
},
{
	"uri": "https://laravel5-book.kejyun.com/package/debug/",
	"title": "Debug 套件",
	"tags": [],
	"description": "",
	"content": "Debug 套件 這裏會介紹一些在 Laravel 會用到的 Debug 套件\n相關套件  Clockwork  Clockwork - Chrome Web Store    "
},
{
	"uri": "https://laravel5-book.kejyun.com/package/auth/oauth/package-auth-oauth2-password-grant-with-scope/",
	"title": "Password Grant with Scope",
	"tags": [],
	"description": "",
	"content": "OAuth2 Password Grant With Scope 延續 Password Grant 的 OAuth2 設定，我們可以在參數中加入我們要取得的 資源存取範圍（Scope），讓這個 Access Token 僅能有特定資源的存取權限\n新增資源存取範圍（Scope）資料 OAuth2 定義的 Scope 皆存在 oauth_scopes 資料表中，我們在資料表中新增 user_profile 及 user_likes 這兩個 Scope\nINSERT INTO \u0026#34;oauth_scopes\u0026#34; (\u0026#34;id\u0026#34;, \u0026#34;description\u0026#34;, \u0026#34;created_at\u0026#34;, \u0026#34;updated_at\u0026#34;) VALUES (\u0026#39;user_profile\u0026#39;, \u0026#39;profile\u0026#39;, now(), now()); INSERT INTO \u0026#34;oauth_scopes\u0026#34; (\u0026#34;id\u0026#34;, \u0026#34;description\u0026#34;, \u0026#34;created_at\u0026#34;, \u0026#34;updated_at\u0026#34;) VALUES (\u0026#39;user_likes\u0026#39;, \u0026#39;likes\u0026#39;, now(), now());  取得 Access token 在我們取得 Access token 的資料欄位中填入下列欄位\n   欄位名稱 資料     grant_types password   username kejyun@gmail.com   password 123456   client_id KeJyun   client_secret KeJyunSecret   scope user_profile,user_likes     我們的 Scope 也可以指填入一個，若要填入多個 Scope 的話，可以看 config/oauth2.php 設定檔中的 scope_delimiter 要怎麼區別不同的 Scope 資源，預設是用逗號「,」去區別 Scope\n 送出到我們設定的 /oauth/access_token 路由後，我們就可以直接取得 access_token，並回傳此 token 失效的時間 expires_in 為我們設定的 access_token_ttl\n相關資料表 OAuth2 會將 token 記錄在 oauth_access_tokens 資料表，並將關聯的使用者記錄在 oauth_sessions 資料表，而 oauth_access_token_scopes 資料表則存放 Access Token 相關的 Scope 資訊\n參考資料  Securing your API endpoints  "
},
{
	"uri": "https://laravel5-book.kejyun.com/services/errors-logs/service/errors-log-service-cloudwatch/",
	"title": "CloudWatch Log",
	"tags": [],
	"description": "",
	"content": "CloudWatch Log 參考資料  Using AWS CloudWatch for Laravel Logs on Forge – James Fairhurst – Medium jamesfairhurst/laravel-cloudwatch-logs-lambda-slack: Use AWS CloudWatch Logs \u0026amp; Lambda to post Laravel Log messages to Slack maxbanton/cwh: Amazon Web Services CloudWatch Logs Handler for Monolog library  "
},
{
	"uri": "https://laravel5-book.kejyun.com/services/unit-test/",
	"title": "單元測試",
	"tags": [],
	"description": "",
	"content": "這裏介紹 Laravel 提供的單元測試功能\n"
},
{
	"uri": "https://laravel5-book.kejyun.com/services/errors-logs/service/",
	"title": "日誌服務",
	"tags": [],
	"description": "",
	"content": "這裏介紹 Laravel 提供的日誌服務功能\n參考資料  Understand.io - Online Event and Log Management understand/understand-laravel5 Sentry | Error Tracking Software — JavaScript, Python, PHP, Ruby, more Error reporting, monitoring, and resolution with Bugsnag Error Tracking \u0026amp; Crash Reporting for Software Developers - Rollbar  "
},
{
	"uri": "https://laravel5-book.kejyun.com/services/unit-test/unit-test-change-root-url/",
	"title": "變更請求網址",
	"tags": [],
	"description": "",
	"content": "Unit test 變更請求網址(Root Url) 在單元測試(Unit test)的時候，測試網址預設會抓取 .env 檔案的 APP_URL，但若同個專案有不同的網址時，則需要再寫測試時變更為特定的網址\n可以在 setUp() 函式使用 \\URL::forceRootUrl() 強制轉換網址，這樣就可以使用指定的網址進行測試了\n\u0026lt;?php class TestCase { function setUp(): void { parent::setUp(); $app_url= \u0026#34;http://kejyun.com\u0026#34;; \\URL::forceRootUrl($app_url); } } "
},
{
	"uri": "https://laravel5-book.kejyun.com/services/",
	"title": "服務",
	"tags": [],
	"description": "",
	"content": "這裏介紹一些 Laravel 提供的一些服務\n"
},
{
	"uri": "https://laravel5-book.kejyun.com/database/model/eloquent-lock/",
	"title": "鎖定資料 Lock",
	"tags": [],
	"description": "",
	"content": "鎖定資料 Lock 鎖定資料有 shared lock (sharedLock) 與 lock for update (lockForUpdate)，兩者都可以避面同一行資料被其他的 transaction update\n在 Laravel 鎖定資料庫資料 範例 sharedLock DB::table(\u0026#39;users\u0026#39;) -\u0026gt;where(\u0026#39;votes\u0026#39;, \u0026#39;\u0026gt;\u0026#39;, 100) -\u0026gt;sharedLock() -\u0026gt;get(); select * from `users` where `votes` \u0026gt; \u0026#39;100\u0026#39; lock in share mode DB::table(\u0026#39;tasks\u0026#39;) -\u0026gt;select(\u0026#39;details\u0026#39;, \u0026#39;created_at\u0026#39;) -\u0026gt;whereDate(\u0026#39;created_at\u0026#39;, \u0026#39;=\u0026#39;, \u0026#39;2011-11-11\u0026#39;) -\u0026gt;sharedLock() -\u0026gt;get(); select `details`, `created_at` from `tasks` where date(`created_at`) = \u0026#39;2011-11-11\u0026#39; lock in share mode 可以使用 -\u0026gt;sharedLock() 或 -\u0026gt;lock(false) 去做 sharedLock\n lockForUpdate DB::table(\u0026#39;users\u0026#39;)-\u0026gt;where(\u0026#39;votes\u0026#39;, \u0026#39;\u0026gt;\u0026#39;, 100)-\u0026gt;lockForUpdate()-\u0026gt;get(); select * from `users` where `votes` \u0026gt; \u0026#39;100\u0026#39; for update DB::table(\u0026#39;tasks\u0026#39;) -\u0026gt;select(\u0026#39;details\u0026#39;, \u0026#39;created_at\u0026#39;) -\u0026gt;whereDate(\u0026#39;created_at\u0026#39;, \u0026#39;\u0026gt;\u0026#39;, \u0026#39;2016-11-24\u0026#39;) -\u0026gt;lockForUpdate() -\u0026gt;get(); select `details`, `created_at` from `tasks` where date(`created_at`) = \u0026#39;2016-11-24\u0026#39; for update 可以使用 -\u0026gt;lockForUpdate() 或 -\u0026gt;lock(true) 去做 lockForUpdate\n 不同的地方 定義  sharedLock locks only for write, lockForUpdate also prevents them from being selected\n shared lock (sharedLock) 與 lock for update (lockForUpdate) 兩者都是鎖定類型的 transaction，但這兩個鎖定類型的 transaction 不會避免非鎖定的 transaction 去讀取到資料。\nsharedLock 其他的 Session 可以 Select，但無法 Update 資料\n如果 Session_1 使用 sharedLock 去讀取資料並對資料進行修改，而 Session_2 也使用 sharedLock 去讀取資料並對資料進行修改，則 Session_2 會等到 Session_1 commit 之後，才能對資料進行 update，若 Session_1 與 Session_2 都有修改到同樣欄位資料，則會變成最後修改的 Session_2 的資料。\n使用情境\n有 parent 及 child 兩個資料表，而兩者資料是有關聯性的，當要新增資料至 child 資料表時，必須確保 parent 資料表有資料，才不會讓 child 找不到他的 parent，此時可以使用 sharedLock 去避免資料被異動（刪除、更新）\nSELECT * FROM parent WHERE NAME = \u0026#39;Jones\u0026#39; FOR SHARE;  lockForUpdate 可以避免被其他鎖定型 transaction 進行 Select\n當需要對同一欄位確保資料 update 是正確的，如計數器，則必須使用 lockForUpdate 來鎖定資料\n當 parent 內有一個計數器欄位紀錄總共有多少 child，則為了數字正確更新，必須避免其他鎖定型的 transaction 進行資料異動\nSELECT counter_field FROM child_codes FOR UPDATE; UPDATE child_codes SET counter_field = counter_field + 1; 參考資料  Database: Query Builder - Laravel - The PHP Framework For Web Artisans Laravel 5: Query Builder Helpers – locks – Jeff\u0026rsquo;s Reference Pessimistic Locking in Laravel 5 使用 Laravel sharedLock 与 lockForUpdate 进行数据表行锁 - Laravel - 大象笔记 MySQL :: MySQL 8.0 Reference Manual :: 15.5.2.4 Locking Reads transactions - MySQL InnoDB: Difference Between FOR UPDATE and LOCK IN SHARE MODE - Stack Overflow MySQL InnoDB Transaction – 交易指南 (SELECT … FOR UPDATE) – YIDAS Code Pessimistic vs Optimistic Locking in Laravel – Ali AslRousta – Medium  "
},
{
	"uri": "https://laravel5-book.kejyun.com/hosting/redis/hosting-install-redis/",
	"title": "安裝 Redis",
	"tags": [],
	"description": "",
	"content": "安裝 Redis 設定 Redis 套件資源庫 sudo add-apt-repository ppa:chris-lea/redis-server sudo apt-get update 安裝 sudo apt-get install redis-server 設定 Redis Redis 設定檔放在/etc/redis/redis.conf\nsudo vim /etc/redis/redis.conf 設定設定檔\nrequirepass 你的 Redis 連線密碼 #bind 127.0.0.1 不要限定只有本機才能連線 maxmemory-policy noeviction appendonly yes appendfilename redis-staging-ao.aof  重新啟動 Redis sudo service redis-server restart 這樣我們就完成 Redis 的安裝了！！\n參考資料  How To Configure a Redis Cluster on Ubuntu 14.04 | DigitalOcean  "
},
{
	"uri": "https://laravel5-book.kejyun.com/resource/resource-article/",
	"title": "文章",
	"tags": [],
	"description": "",
	"content": "文章 部落格  MattStauffer.co  文件  Awesome Laravel  除錯  Debugging Queries in Laravel  IoC  神奇的服务容器  事件  Step by Step Guide to Installing Socket.io and Broadcasting Events with Laravel 5.1  "
},
{
	"uri": "https://laravel5-book.kejyun.com/package/tool/",
	"title": "工具",
	"tags": [],
	"description": "",
	"content": "工具套件 這裏會介紹一些 Laravel 常用的一些套件工具\n"
},
{
	"uri": "https://laravel5-book.kejyun.com/package/auth/oauth/package-auth-oauth2-access-token-authentication/",
	"title": "驗證 Access Token",
	"tags": [],
	"description": "",
	"content": "驗證 Access Token 路由設定 OAuth middleware 在我們想要保護的資源中，我們可以加入 oauth 的 middleware 中介層，這樣\n// 保護的資源設定 oauth middleware Route::get(\u0026#39;/user-private-resource\u0026#39;, [\u0026#39;middleware\u0026#39;=\u0026gt;\u0026#39;oauth\u0026#39;, function() { // 取得資源擁有者編號，若經過 Password Grant 驗證的 Token 則為使用者的編號 $user_id = Authorizer::getResourceOwnerId(); $data = [ \u0026#39;user_id\u0026#39;=\u0026gt; $user_id ]; // 回傳受保護的資源 return Response::json($data); }]);  透過 Access Token 取的受保護的資源 在我們取得受保護資源的請求 Header 中填入，這樣 OAuth2 就會取得我們傳入的 Access Token，並驗證我們有沒有存取權限，若有存取權限，則會直接回傳該受保護的資源\n   欄位名稱 資料     Authorization Bearer rXXoWMg5UXzQpxAynCnYYOQiZQ0xDcAjT0ywGvke    路由設定包含 Scope 的 OAuth middleware 若我們限制此路由需要有特定 Scope 的存取權限的 Access Token 才可以存取，我們可以在 middleware 後面加上允許的 Scope 名稱，若同時需要擁有多個 Scope 權限，則用 加號（+） 把 Scope 連接起來即可\n e.g. \u0026lsquo;oauth:user_profile+user_likes\u0026rsquo;\n // 保護的資源設定 oauth middleware Route::get(\u0026#39;/user-private-resource\u0026#39;, [\u0026#39;middleware\u0026#39;=\u0026gt;\u0026#39;oauth:user_profile+user_likes\u0026#39;, function() { }]); 這樣這個路由就會被指定的 Scope 所保護著了～\n參考資料  Securing your API endpoints  "
},
{
	"uri": "https://laravel5-book.kejyun.com/services/errors-logs/",
	"title": "錯誤與日誌 Log",
	"tags": [],
	"description": "",
	"content": "這裏介紹 Laravel 提供的錯誤與日誌 Log 功能\n"
},
{
	"uri": "https://laravel5-book.kejyun.com/api/",
	"title": "API",
	"tags": [],
	"description": "",
	"content": "這裏介紹一些 Laravel 提供的 API 功能\n"
},
{
	"uri": "https://laravel5-book.kejyun.com/database/model/eloquent-tips/",
	"title": "Eloquent 小技巧",
	"tags": [],
	"description": "",
	"content": "Eloquent 小技巧 取得主鍵名稱 - getKeyName() User Eloquent 物件\n\u0026lt;?php use Illuminate\\Database\\Eloquent\\Model; class User extends Model { protected $table = \u0026#39;user\u0026#39;; protected $primaryKey = \u0026#39;user_id\u0026#39;; } 取得主鍵名稱\n\u0026lt;?php $User = new User; $primary_key_name = $User-\u0026gt;getKeyName(); // user_id "
},
{
	"uri": "https://laravel5-book.kejyun.com/design-pattern/",
	"title": "設計模式",
	"tags": [],
	"description": "",
	"content": "這裏介紹一些 Laravel 的設計模式\n"
},
{
	"uri": "https://laravel5-book.kejyun.com/resource/resource-packages/",
	"title": "套件",
	"tags": [],
	"description": "",
	"content": "套件 清單  Packalyst :: Packages for Laravel Packagist - tag laravel Laravel Collective Arsenal :: Cartalyst Built with Laravel  時間  Carbon - A simple PHP API extension for DateTime.  編輯器  Laravel Markdown  檔案  Laravel Flysystem  除錯  The missing tail command for Laravel 5 Laravel Exceptions Laravel Debugbar  條碼  Simple QrCode   社群  Laravel GitHub  CMS  Wardrobe Bootstrap CMS TypiCMS PHPHub Cachet Paperwork  Open Source  laravel-tricks  "
},
{
	"uri": "https://laravel5-book.kejyun.com/hosting/lets-encrypt/hosting-install-lets-encrypt/",
	"title": "安裝 Memcached",
	"tags": [],
	"description": "",
	"content": "安裝 Let\u0026rsquo;s Encrypt 為了推廣 SSL 憑證，Let\u0026rsquo;s Encrypt 提供了免費的 SSL 憑證，可以讓你們的主機也有 SSL 加密的保障\n但是 Let\u0026rsquo;s Encrypt 提供的憑證有效期限每次只有 90 天的效期，若過期之後需要重新更新憑證方可繼續使用\n下載 wget https://dl.eff.org/certbot-auto chmod a+x certbot-auto 安裝 SSL 憑證 在安裝 SSL 憑證時需要將您的 Nginx 主機服務關閉，才能進行憑證驗證\nHow would you like to authenticate with the ACME CA? ------------------------------------------------------------------------------- 1: Place files in webroot directory (webroot) 2: Spin up a temporary webserver (standalone) ------------------------------------------------------------------------------- Select the appropriate number [1-2] then [enter] (press \u0026#39;c\u0026#39; to cancel): 用 nginx 選擇 standalone，若是 apache 則選擇用 webroot\n 輸入驗證 SSL 的網址 Please enter in your domain name(s) (comma and/or space separated) (Enter \u0026#39;c\u0026#39; to cancel): kejyun.dev 憑證檔案 安裝完的憑證會依照你申請的 domain 當作資料夾名稱放到 /etc/letsencrypt/live/ 目錄下\n如果我同時申請了 kejyun.dev 與 www.kejyun.dev，那麼憑證檔案就會分別放在 /etc/letsencrypt/live/kejyun.dev/ 及 /etc/letsencrypt/live/www.kejyun.dev/ 目錄下\n憑證檔案分別會有 4 個\n   檔案名稱 說明     cert.pem 申請網域的憑證   chain.pem Let\u0026rsquo;s Encrypt 的憑證   fullchain.pem cert.pem 及 chain.pem 合併檔案   privkey.pem 申請網域的憑證密鑰     設定 nginx 使用 SSL 憑證 server { # 設定監聽的 port 為 443 listen 443 ssl; # 設定憑證檔案 ssl_certificate /etc/letsencrypt/live/kejyun.dev/fullchain.pem; ssl_certificate_key /etc/letsencrypt/live/kejyun.dev/privkey.pem; ssl_protocols TLSv1 TLSv1.1 TLSv1.2; ssl_prefer_server_ciphers on; ssl_ciphers 'EECDH+AESGCM:EDH+AESGCM:AES256+EECDH:AES256+EDH'; } 設定 nginx 80 port 自動轉址導向 SSL 443 port server { listen 80; server_name kejyun.dev; return 301 https://$host$request_uri; } 重新啟動 Nginx sudo service nginx restart 設定完成後就可以看到自己的網站有做 SSL 加密了！\n自動更新 Let\u0026rsquo;s Encrypt 憑證 自動更新憑證 ./path/to/certbot renew --pre-hook \u0026#34;service nginx stop\u0026#34; --post-hook \u0026#34;service nginx start\u0026#34; 在更新憑證的時候，還是需要把 web server 停掉，所以可以在 --pre-hook 更新前關掉 nginx，在 --post-hook 更新後啟動 nginx\n加入 Cronjob 排程執行憑證更新 編輯 crontab\nsudo crontab -e 設定每個禮拜一的凌晨 2:30 進行一次憑證的檢查及更新\n30 2 * * 1 ./path/to/certbot renew --pre-hook \u0026#34;service nginx stop\u0026#34; --post-hook \u0026#34;service nginx start\u0026#34; \u0026gt;\u0026gt; /var/log/letsencrypt-renewal.log 這樣我們就有了一個半永久的 SSL 憑證了！！\n參考資料  Certbot - Nginx on Ubuntu 14.04 Certbot documentation - Renewing certificates letsencrypt/letsencrypt How To Secure Nginx with Let\u0026rsquo;s Encrypt on Ubuntu 14.04 | DigitalOcean  "
},
{
	"uri": "https://laravel5-book.kejyun.com/package/design-pattern/",
	"title": "設計模式",
	"tags": [],
	"description": "",
	"content": "這裏會介紹一些 Laravel 不錯的設計模式套件\nEntity 資料顯示  laracasts/presenter  "
},
{
	"uri": "https://laravel5-book.kejyun.com/services/encryption/encryption-intro/",
	"title": "加密（encryption）",
	"tags": [],
	"description": "",
	"content": "加密（encryption） 使用情境 我們若需要在資料庫儲存一些敏感資料（像是信用卡的資料），但我們又為了避免資料庫遭到入侵，而導致所有使用者相關的敏感資料全都被竊取，我們可以使用 Laravel 提供的「加密與解密」演算法，將我們的敏感資料加密儲存到資料庫，待我們讀取資料的時候，再將其資料解密出來處理。\n設定 在 Laravel 做「加密與解密」演算法時，會使用 config/app.php 中的 key 值去當作加解密的 salt，自己的應用需要設定自己的 key 值，若沒有設定的話被加密過的值還是有可能被暴力破解出來，所以要記得去設定，而這個 key 值若變更了，雜湊的驗證也不會相同喔～\n使用 // 加密 $original_data = \u0026#39;需要加密的資料\u0026#39;; $encrypt_data = Crypt::encrypt($original_data); // 解密 $decrypted = Crypt::decrypt($encrypt_data);  備註 重複加密相同的資料得到的密文不會一樣，所以不要使用像 md5 的方式去比對密文資料是否相同\n使用 md5 比較密文 $original_data = \u0026#39;需要加密的資料\u0026#39;; // 第 1 次使用 md5 加密的資料 $first_md5_hash_data = md5($original_data); // 第 2 次使用 md5 加密的資料 $second_md5_hash_data = md5($original_data); // 資料相同 // true var_dump($first_md5_hash_data === $second_md5_hash_data); 使用加密演算法比較密文 $original_data = \u0026#39;需要加密的資料\u0026#39;; // 第 1 次使用加密演算法加密的資料 $first_encrypt_data = Crypt::encrypt($original_data); // 第 2 次使用加密演算法加密的資料 $second_encrypt_data = Crypt::encrypt($original_data); // 資料不相同 // false var_dump($first_encrypt_data === $second_encrypt_data); 參考資料  加密 - Laravel.tw  "
},
{
	"uri": "https://laravel5-book.kejyun.com/database/model/eloquent-sub-query/",
	"title": "子查詢",
	"tags": [],
	"description": "",
	"content": "子查詢 當我想要計算子查詢的數量時，會想要執行像下方的 SQL 查詢語法\nSELECT count(*) FROM ( SELECT UID FROM `posts` WHERE `status` = 1 GROUP BY `user_id` ) sub 在 Eloquent 可以用下面方式達到子查詢的目的\n\u0026lt;?php // Eloquent Builder instance $SubQuery = Posts::where(\u0026#39;status\u0026#39;, 1) -\u0026gt;groupBy(\u0026#39;user_id\u0026#39;); $count = DB::table( DB::raw(\u0026#34;({$SubQuery-\u0026gt;toSql()}) as sub\u0026#34;) ) -\u0026gt;mergeBindings($SubQuery-\u0026gt;getQuery()) -\u0026gt;count(); 記得當你的子查詢結束後，若有更多的條件需要執行，則必須將查詢條件放在 mergeBindings() 方法後方，否則原本 SubQuery 的查詢資料順序會綁定錯誤\n$count = DB::table( DB::raw(\u0026#34;({$SubQuery-\u0026gt;toSql()}) as sub\u0026#34;) ) // -\u0026gt;where(..) 這裡會出錯 -\u0026gt;mergeBindings($SubQuery-\u0026gt;getQuery()) // -\u0026gt;where(..) 正確 -\u0026gt;count();  Laravel v5.6.12 (2018-03-14) 之後，加入了 fromSub() 及 fromRaw() 的方法可以直接產生子查詢語法\n\u0026lt;?php DB::query()-\u0026gt;fromSub(function ($query) { $query-\u0026gt;from(\u0026#39;posts\u0026#39;) -\u0026gt;where(\u0026#39;status\u0026#39;, 1) -\u0026gt;groupBy(\u0026#39;user_id\u0026#39;); }, \u0026#39;sub\u0026#39;)-\u0026gt;count(); // select count(*) as aggregate from (select * from `abc` group by `col1`) as `a` 參考資料  sql - How to select from subquery using Laravel Query Builder? - Stack Overflow  "
},
{
	"uri": "https://laravel5-book.kejyun.com/structure/",
	"title": "程式架構規範",
	"tags": [],
	"description": "",
	"content": "這裏介紹一些 Laravel 的程式架構規範\n"
},
{
	"uri": "https://laravel5-book.kejyun.com/resource/resource-learning-video/",
	"title": "教學影片",
	"tags": [],
	"description": "",
	"content": "教學影片 English 初學  Laravel 5 Fundamentals What\u0026rsquo;s New in Laravel 5.1 Laravel Basics Course Laravel From Scratch  進階  The Best Laravel and PHP Screencasts PHP Academy Anthony Vipond muukrls Lynda Laravel Tuts+ Code Courses - Laravel  繁體中文  Laravel 台灣 - Youtube  "
},
{
	"uri": "https://laravel5-book.kejyun.com/resource/resource-laravel-service/",
	"title": "服務工具",
	"tags": [],
	"description": "",
	"content": "佈署程式  Laravel Forge  ForgeRecipes   Envoyer - Zero Downtime PHP Deployment Laravel hosting in the cloud Rocketeer  "
},
{
	"uri": "https://laravel5-book.kejyun.com/package/html/",
	"title": "HTML",
	"tags": [],
	"description": "",
	"content": "HTML DOM 解析  PHP Simple HTML DOM Parser: Manual sunra/php-simple-html-dom-parser: PHP Simple HTML DOM Parser adaptation for Composer and PSR-0 sunra/php-simple-html-dom-parser - Packagist  "
},
{
	"uri": "https://laravel5-book.kejyun.com/package/",
	"title": "套件",
	"tags": [],
	"description": "",
	"content": "這裏介紹一些 Laravel 一些常用的套件\n"
},
{
	"uri": "https://laravel5-book.kejyun.com/services/hashing/hashing-intro/",
	"title": "雜湊（Hashing）",
	"tags": [],
	"description": "",
	"content": "雜湊（Hashing） 使用情境 使用者輸入的密碼，通常我們將其加密再存到資料庫中，但這類的資料我們通常不需要反解回來處理，所以我們不需要使用加密的演算法去加密資料\n因為加密演算法需要完整的解回原先的資料，所以若資料越長密文也會越長，但雜湊不需要解回原先的資料，只需要驗證原先的資料，經過再雜湊的檢查是相同的就好（輸入的密碼雜湊驗證與原先存在資料庫的雜湊資料相同），所以雜湊的資料可以有固定的長度，像是 md5 的雜湊資料長度固定為 32，而 Laravel 提供的 Hash 雜湊演算法，資料長度固定為 60。\n設定 在 Laravel 做「雜湊」演算法時，會使用 config/app.php 中的 key 值去當作雜湊的 salt，自己的應用需要設定自己的 key 值，若沒有設定的話被加密過的值還是有可能被暴力破解出來，所以要記得去設定，而這個 key 值若變更了，雜湊的驗證也不會相同喔～\n 使用 雜湊 // 雜湊 $original_password = \u0026#39;密碼明碼\u0026#39;; $hash_password = Hash::make($original_password); 驗證 // 雜湊 $original_password = \u0026#39;密碼明碼\u0026#39;; $hash_password = Hash::make($original_password); // 驗證 $check_result = Hash::check($original_password, $hash_password); // true var_dump($check_result); 備註 重複雜湊相同的資料得到的密文不會一樣，所以不要使用像 md5 的方式去比對密文資料是否相同\n 使用 md5 比較密文 $original_password = \u0026#39;密碼明碼\u0026#39;; // 第 1 次使用 md5 加密的資料 $first_md5_hash_password = md5($original_password); // 第 2 次使用 md5 加密的資料 $second_md5_hash_password = md5($original_password); // 資料相同 // true var_dump($first_md5_encrypt_password === $second_md5_encrypt_password); 雖然每次雜湊的結果都不一樣，但你可以放心的將任何一次雜湊的資料存放到資料庫中，因為雖然密文不同，但 Laravel 的雜湊演算法，還是可以比對出來是不是由相同的資料去做雜湊的\n使用雜湊演算法比較資料是否相同 $original_password = \u0026#39;密碼明碼\u0026#39;; // 第 1 次使用雜湊演算法雜湊的資料 $first_hash_password = Hash::make($original_password); // 第 2 次使用雜湊演算法雜湊的資料 $second_hash_password = Hash::make($original_password); // 資料不相同 // false var_dump($first_encrypt_password === $second_encrypt_password); // 驗證雜湊資料 true $first_check_result = Hash::check($original_password, $first_hash_password); $second_check_result = Hash::check($original_password, $second_hash_password); 參考資料  雜湊 - Laravel.tw  "
},
{
	"uri": "https://laravel5-book.kejyun.com/resource/resource-learning-website/",
	"title": "教學網站",
	"tags": [],
	"description": "",
	"content": "教學網站 英文  Laravel Recipes Laravel-Tricks.com Web development, design, and other nerdy topics! | Dayle Rees Laravel Book PHP: The Right Way  中文  Laravel 初體驗 - 實作 Blog 系統 | Laravel Dojo PHP: The Right Way 繁體中文  "
},
{
	"uri": "https://laravel5-book.kejyun.com/package/text/",
	"title": "文字",
	"tags": [],
	"description": "",
	"content": "文字處理 文字發音  Laravel-pinyin  "
},
{
	"uri": "https://laravel5-book.kejyun.com/software/",
	"title": "軟體",
	"tags": [],
	"description": "",
	"content": "這裏介紹一些 Laravel 一些常用的軟體\n"
},
{
	"uri": "https://laravel5-book.kejyun.com/services/response/response-intro/",
	"title": "回應（Response）",
	"tags": [],
	"description": "",
	"content": "回應（Response） 強制回應 JSON 建立 Middleware\nnamespace App\\Http\\Middleware; use Closure; class ForceJsonMiddleware { /** * Handle an incoming request. * * @param \\Illuminate\\Http\\Request $request * @param \\Closure $next * @return mixed */ public function handle($request, Closure $next) { $request-\u0026gt;headers-\u0026gt;set(\u0026#39;accept\u0026#39;, \u0026#39;application/json\u0026#39;); return $next($request); } } 在 Kernel.php 加入此 Middleware\n\u0026#39;force-json-response\u0026#39; =\u0026gt; \\App\\Http\\Middleware\\ForceJsonMiddleware::class, 設定使用 Middleware\nRoute::group([\u0026#39;middleware\u0026#39; =\u0026gt; [\u0026#39;force-json-response\u0026#39;, \u0026#39;auth:api\u0026#39;]], function () { }); 參考資料  Laravel 响应：永远返回 JSON 响应 | Laravel China 社区  "
},
{
	"uri": "https://laravel5-book.kejyun.com/resource/resource-editor-tool/",
	"title": "編輯開發",
	"tags": [],
	"description": "",
	"content": "Sublime  Pro Workflow in Laravel and Sublime Text - Tuts+ Code Tutorial  "
},
{
	"uri": "https://laravel5-book.kejyun.com/package/api/",
	"title": "API",
	"tags": [],
	"description": "",
	"content": "API 套件 "
},
{
	"uri": "https://laravel5-book.kejyun.com/hosting/",
	"title": "主機環境建置",
	"tags": [],
	"description": "",
	"content": "主機環境建置 程式寫完後，我們要上線測試時，還是需要一個完整的正式環境可以執行 Laravel，這裡會介紹大家如何不使用 Homestead，在正式主機把 Laravel 執行環境建置起來\n環境  Ubuntu 14.04 LTS\n  Nginx\n  MySQL 5.7\n  PHP 7.0\n  Redis\n  Memcached\n  Let\u0026rsquo;s Encrypt SSL\n "
},
{
	"uri": "https://laravel5-book.kejyun.com/services/scheduling/scheduling-intro/",
	"title": "任務排程（Scheduling）",
	"tags": [],
	"description": "",
	"content": "任務排程（Scheduling） 我們通常會把一些每小時、每 6 小時、每日、每週、每月等等之類固定時間要做的工作丟到 Linux 系統的 crontab 中去執行，通常像是每日要統計昨天網站的活動資訊做數據分析之類的工作，這類的工作通常會花費比較久的時間\n在 Linux 設定排程工作 我們通常會在命令列用 $ crontab -e 的方式去編輯排程工作\n$ crontab -e 在用到 crontab 的時候，我們需要瞭解怎麼設定排程工作的執行時間，整個的 crontab 的設定可能會像這樣：\n# 每天凌晨 3 點統計昨天的 Pageview 0 3 * * * /usr/bin/php /home/kejyun/laravel4/artisan cronjob:statisticYesterdayPageview 在前方可以看到有 5 個數字可以做設定，依序分別代表的意思為：\n 分鐘 (0-59) 小時 (0-23) 每個月第幾天 (1-31) 月份 (1-12) 每週的第幾天 (0-6) 0：星期日 1：星期一 2：星期二 3：星期三 4：星期四 5：星期五 6：星期六  這 5 個參數之間用空白隔開，每個參數除了設定單一個數字，也可以用逗號(,)去隔開設定相同單位的時間設定，像是：\n# 每天凌晨 4 點及 16 點寄送廣告信 0 4,16 * * * /usr/bin/php /home/kejyun/laravel4/artisan cronjob:sendCommercialMail  這裏有一些相關的設定範例可以當作參考：\n# 每小時的第 18 分鐘執行 18 * * * * # 8 點 10 分執行 10 8 * * * # 8 點的每分鐘執行一次（共執行 60 次） * 8 * * * # 在每個禮拜二每小時的第 18 分鐘執行 18 * * * 2 # 你也可以每隔一段時間去執行 crontab # 如果我們每 15 分鐘要去執行，你可以用這樣的格式 */15 # 這樣的意思是將分鐘數，切割成（除以）每 15 分鐘執行 */15 * * * * # 每 2 小時執行 0 */2 * * * # 每 2 小時又 20 分鐘執行 */20 */2 * * * 小提醒\n 系統的 crontab 運作方式是每分鐘會到設定的 crontab 找看看有沒有符合現在這個時間的排程工作，所以像是 * 8 * * * 這樣的設定，因為沒有明確指定分鐘，在 8 點每分鐘檢查的 60 次都符合條件，所以會執行 60 次，若僅要 8 點時執行一次，請明確設定要執行的分鐘條件，像是 0 8 * * *\n  使用 Laravel 5.2 Scheduling 設定排程工作 因為 Linux 每分鐘都會去檢查當時是否有排程需要執行的工作，符合條件的時間就會執行，Laravel 利用這個特性，告訴排程每分鐘都要執行 Laravel 的 schedule:run 的指令\n* * * * * php /path/to/artisan schedule:run \u0026gt;\u0026gt; /dev/null 2\u0026gt;\u0026amp;1 之後 Laravel 每分鐘就會執行 app/Console/Command/Kernal@schedule 的程式，Laravel 會依照 schedule 裡面的設定時間，執行符合條件的排程工作\n排程範例 假如我們有一個排程每分鐘都會紀錄他執行的時間，程式碼會放在 app/Console/Command/TestLog.php，程式碼會像是：\n\u0026lt;?php namespace App\\Console\\Commands; use Illuminate\\Console\\Command; use File; class TestLog extends Command { // 命令名稱  protected $signature = \u0026#39;test:Log\u0026#39;; // 說明文字  protected $description = \u0026#39;[測試] Log 檔案\u0026#39;; public function __construct() { parent::__construct(); } // Console 執行的程式  public function handle() { // 檔案紀錄在 storage/test.log  $log_file_path = storage_path(\u0026#39;test.log\u0026#39;); // 記錄當時的時間  $log_info = [ \u0026#39;date\u0026#39;=\u0026gt;date(\u0026#39;Y-m-d H:i:s\u0026#39;) ]; // 記錄 JSON 字串  $log_info_json = json_encode($log_info) . \u0026#34;\\r\\n\u0026#34;; // 記錄 Log  File::append($log_file_path, $log_info_json); } } 以上排程的命令是 php artisan test:Log，執行之後就會記錄當時執行的時間\n排程程式建立好之後，在 app/Console/Command/Kernal.php 定義此排程的工作，並設定每分鐘執行一次，程式碼會像是：\n\u0026lt;?php namespace App\\Console; use Illuminate\\Console\\Scheduling\\Schedule; use Illuminate\\Foundation\\Console\\Kernel as ConsoleKernel; class Kernel extends ConsoleKernel { // 定義應用程式的 Artisan 指令  protected $commands = [ \\App\\Console\\Commands\\TestLog::class, ]; // 定義應用程式的排程  protected function schedule(Schedule $schedule) { // 每分鐘執行 Artisan 命令 test:Log  $schedule-\u0026gt;command(\u0026#39;test:Log\u0026#39;)-\u0026gt;everyMinute(); } } 這樣你就可以在 storage/test.log 每分鐘看到像這樣的紀錄，這樣就表示你的排程設定成功了！！\n{\u0026quot;date\u0026quot;:\u0026quot;2016-01-11 22:12:05\u0026quot;} {\u0026quot;date\u0026quot;:\u0026quot;2016-01-11 22:13:05\u0026quot;} {\u0026quot;date\u0026quot;:\u0026quot;2016-01-11 22:14:05\u0026quot;} {\u0026quot;date\u0026quot;:\u0026quot;2016-01-11 22:15:05\u0026quot;} {\u0026quot;date\u0026quot;:\u0026quot;2016-01-11 22:16:05\u0026quot;} {\u0026quot;date\u0026quot;:\u0026quot;2016-01-11 22:17:07\u0026quot;} {\u0026quot;date\u0026quot;:\u0026quot;2016-01-11 22:18:09\u0026quot;} {\u0026quot;date\u0026quot;:\u0026quot;2016-01-11 22:19:05\u0026quot;}  你也可以使用其他 Laravel 提供的時間方法去定義要執行的時間\n   方法 說明     -\u0026gt;cron('* * * * * *'); 自訂 Cron 排成時間   -\u0026gt;everyMinute(); 每分鐘執行   -\u0026gt;everyFiveMinutes(); 每 5 分鐘執行   -\u0026gt;everyTenMinutes(); 每 10 分鐘執行   -\u0026gt;everyThirtyMinutes(); 每 30 分鐘執行   -\u0026gt;hourly(); 每小時執行   -\u0026gt;daily(); 每天執行   -\u0026gt;dailyAt(\u0026lsquo;13:00\u0026rsquo;); 每天 13:00 執行   -\u0026gt;twiceDaily(1, 13); 每天 1:00 及 13:00 執行   -\u0026gt;weekly(); 每週執行   -\u0026gt;monthly(); 每月執行   -\u0026gt;yearly(); 每年執行   -\u0026gt;sundays() 每週日執行   -\u0026gt;mondays() 每週一執行   -\u0026gt;tuesdays() 每週二執行   -\u0026gt;wednesdays() 每週三執行   -\u0026gt;thursdays() 每週四執行   -\u0026gt;fridays() 每週五執行   -\u0026gt;saturdays() 每週六執行   -\u0026gt;when(Closure) 每當符合條件就執行（return true）     避免重複執行排程 排程預設每次符合條件就要執行，但若我們執行一個需要跑很久的程式，在下一次符合條件的時間若上一個同樣的工作還沒有執行完，我們就不執行的話，我們可以用 -\u0026gt;withoutOverlapping() 方法去避免排程程式重複執行，像是\n$schedule-\u0026gt;command(\u0026#39;emails:send\u0026#39;)-\u0026gt;withoutOverlapping(); 輸出執行結果 我們的在執行 Artisan 指令時，我們通常會在畫面上列印一些執行狀態，像是 $this-\u0026gt;info('把我顯示在畫面上');，如果我們想要知道排程執行時，這些顯示在畫面的文字記錄下來，我們可以用\n   方法 說明     -\u0026gt;sendOutputTo($filePath); 將結果輸出到檔案（複寫該檔案）   -\u0026gt;appendOutputTo($filePath); 將結果附加在檔案後面（不複寫檔案）   -\u0026gt;emailOutputTo('foo@example.com'); 將結果寄送到指定 Email    *** 將結果輸出到檔案（複寫該檔案） ***\n$schedule-\u0026gt;command(\u0026#39;emails:send\u0026#39;) -\u0026gt;daily() -\u0026gt;sendOutputTo($filePath); *** 將結果附加在檔案後面（不複寫檔案） ***\n$schedule-\u0026gt;command(\u0026#39;emails:send\u0026#39;) -\u0026gt;daily() -\u0026gt;appendOutputTo($filePath); *** 將結果寄送到指定 Email ***\n$schedule-\u0026gt;command(\u0026#39;foo\u0026#39;) -\u0026gt;daily() -\u0026gt;sendOutputTo($filePath) -\u0026gt;emailOutputTo(\u0026#39;foo@example.com\u0026#39;);  排程觸發 我們可以在排程執行前後，分別使用 -\u0026gt;before() 或 -\u0026gt;after() 去執行排程其他的工作\n$schedule-\u0026gt;command(\u0026#39;emails:send\u0026#39;) -\u0026gt;daily() -\u0026gt;before(function () { // 在排程執行前觸發 }) -\u0026gt;after(function () { // 在排程執行完成後觸發 }); 參考資料  crontab.guru - the cron schedule expression editor A visual crontab editor Task Scheduling - Laravel 5.2  "
},
{
	"uri": "https://laravel5-book.kejyun.com/resource/resource-hosting/",
	"title": "主機",
	"tags": [],
	"description": "",
	"content": "主機 Hosting  Amazon Web Services (AWS) Google Cloud Computing Services (GCP) Microsoft Azure DigitalOcean Linode Heroku OpenShift Vultr  教學  Run Laravel 5.1 on OpenShift Installing a Laravel app on Heroku Laravel 5 - Pagoda Box Documentation  "
},
{
	"uri": "https://laravel5-book.kejyun.com/qa/",
	"title": "其他常見問題",
	"tags": [],
	"description": "",
	"content": "這裏會介紹一些在開發 Laravel 遇到的常見問題\n Call to undefined method getCachedCompilePath()  "
},
{
	"uri": "https://laravel5-book.kejyun.com/editor/",
	"title": "編輯器",
	"tags": [],
	"description": "",
	"content": "編輯器  PhpStorm: Lightning-Smart IDE for PHP Programming by JetBrains Visual Studio Code - Code Editing. Redefined Sublime Text - A sophisticated text editor for code, markup and prose Atom  "
},
{
	"uri": "https://laravel5-book.kejyun.com/package/view/",
	"title": "視圖",
	"tags": [],
	"description": "",
	"content": "視圖 View 解析  yangqi/Htmldom - Simple HTML Dom Parser  最小化  Laravel-HTMLMin HTML Minifier in Laravel 5.*  "
},
{
	"uri": "https://laravel5-book.kejyun.com/services/laravel-mix/",
	"title": "Laravel Mix",
	"tags": [],
	"description": "",
	"content": "這裏介紹 Laravel 提供的 Laravel Mix 功能\n"
},
{
	"uri": "https://laravel5-book.kejyun.com/resource/resource-laravel-case/",
	"title": "成功案例",
	"tags": [],
	"description": "",
	"content": "案例  VDemocracy.tw - 群眾募資‧群眾集資網站 Crowdfunding Platform in Taiwan Builtwithlaravel.com  "
},
{
	"uri": "https://laravel5-book.kejyun.com/resource/",
	"title": "學習資源",
	"tags": [],
	"description": "",
	"content": "學習資源  KeJyun學習日誌: Laravel 4  "
},
{
	"uri": "https://laravel5-book.kejyun.com/package/mail/",
	"title": "郵件",
	"tags": [],
	"description": "",
	"content": "郵件 Mailchimp  spatie/laravel-newsletter: Manage newsletters in Laravel ★ Easily integrate MailChimp in Laravel 5 - Freek Van der Herten\u0026rsquo;s blog on PHP and Laravel  "
},
{
	"uri": "https://laravel5-book.kejyun.com/services/compass/compass-intro/",
	"title": "Compass",
	"tags": [],
	"description": "",
	"content": "Compass 安裝 RVM 1. 安裝 GPG keys\n$ gpg --keyserver hkp://keys.gnupg.net --recv-keys 409B6B1796C275462A1703113804BB82D39DC0E3 7D2BAF1CF37B13E2069D6956105BD0E739499BDB 2. 安裝 RVM\n\\curl -sSL https://get.rvm.io | bash 使用 RVM 安裝 Ruby 列出所有可以安裝的版本\nrvm list known 安裝指定版本\nrvm install 2.3.1  必須使用管理者權限安裝過以下套件：\n  autoconf, automake, bison, libffi-dev, libgdbm-dev, libncurses5-dev, libsqlite3-dev, libtool, libyaml-dev, pkg-config, sqlite3, zlib1g-dev, libgmp-dev, libreadline6-dev\n  安裝 Compass gem update --system gem install compass 監控 Compass gulp watch 參考資料  RVM: Ruby Version Manager - Installing RVM Install the Compass Stylesheet Authoring Framework | Compass Documentation creationix/nvm: Node Version Manager - Simple bash script to manage multiple active node.js versions  "
},
{
	"uri": "https://laravel5-book.kejyun.com/package/social/",
	"title": "社群",
	"tags": [],
	"description": "",
	"content": "社群 Youtube  GitHub - alaouy/Youtube: 🔥 Laravel PHP Facade/Wrapper for the Youtube Data API  YouTube | Google Developers YouTube Data API | Google Developers Obtain API key from Google API Console    "
},
{
	"uri": "https://laravel5-book.kejyun.com/package/dashboard/",
	"title": "Dashboard",
	"tags": [],
	"description": "",
	"content": "Dashboard 套件  GitHub - LaravelDaily/laravel-roles-permissions-manager: Laravel 5.5 adminpanel starter boilerplate project with roles-permissions management. GitHub - Labs64/laravel-boilerplate: Laravel 5 Boilerplate / Starter kit with Gentelella Admin Theme Voyager - The Missing Laravel Admin GitHub - z-song/laravel-admin: Build a full-featured administrative interface in ten minutes  權限  GitHub - spatie/laravel-permission: Associate users with roles and permissions  樣板  GitHub - jeroennoten/Laravel-AdminLTE: Easy AdminLTE integration with Laravel Free Laravel Admin Templates · CoreUI for laravel 34 Free Bootstrap Admin Dashboard Templates 2018 - Colorlib Free Bootstrap Admin Template | AdminLTE.IO Gentelella Alela! | [Throughput · Laravel 5 Boilerplate | Waffle.io](Throughput · Laravel 5 Boilerplate | Waffle.io)  工具  DataTables | Table plug-in for jQuery  "
},
{
	"uri": "https://laravel5-book.kejyun.com/package/platform/",
	"title": "平台",
	"tags": [],
	"description": "",
	"content": "平台  Laravel Enso | Documentation laravel-enso/Enso: Laravel Vue SPA, Bulma themed. For demo login use admin@laravel-enso.com \u0026amp; password.  "
},
{
	"uri": "https://laravel5-book.kejyun.com/package/auth/",
	"title": "認證",
	"tags": [],
	"description": "",
	"content": "認證套件 這裏會介紹一些在 Laravel 5 會用到的認證套件\n參考資料  10 Things You Should Know about Tokens CSRF Token necessary when using Stateless(= Sessionless) Authentication? Where to Store Your JWTs - Cookies vs HTML5 Web Storage Cookies are bad for you: Improving web application security  "
},
{
	"uri": "https://laravel5-book.kejyun.com/",
	"title": "首頁",
	"tags": [],
	"description": "",
	"content": "Laravel 5 學習筆記 "
},
{
	"uri": "https://laravel5-book.kejyun.com/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://laravel5-book.kejyun.com/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]
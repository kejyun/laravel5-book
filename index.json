[
{
	"uri": "https://kejyun.github.io/laravel5-book/database/redis/aws-cluster/aws-cluster/",
	"title": "AWS Redis 設定",
	"tags": [],
	"description": "",
	"content": "AWS Redis 設定  Laravel 版本：5.2\n AWS Redis Cluster Mode Enable 啟用群集模式 建立 Redis AWS Cluster Mode Enable 群集 建立 AWS Cluster Mode Enable 群集，將「Cluster Mode enabled」打勾，在下方的「Number of Shareds」設定資料分片數量，以及在「Replicas per Shared」設定每個分片數量要有幾個備援。\n取得群集端點（Endpoint） 建立完群集之後，在列表中取得群集端點（Configuration Endpoint）\n將群集端點設定到 database.php，並將 cluster 設定為 true，在設定檔加入 options 選項為 ['cluster' =\u0026gt; 'redis']，並設定預設的 default 連線。\n// 檔案位置：config/database.php return [ \u0026#39;redis\u0026#39; =\u0026gt; [ \u0026#39;cluster\u0026#39; =\u0026gt; true, \u0026#39;options\u0026#39; =\u0026gt; [\u0026#39;cluster\u0026#39; =\u0026gt; \u0026#39;redis\u0026#39;], \u0026#39;default\u0026#39; =\u0026gt; [ \u0026#39;host\u0026#39; =\u0026gt; env(\u0026#39;REDIS_HOST\u0026#39;, \u0026#39;localhost\u0026#39;), \u0026#39;password\u0026#39; =\u0026gt; env(\u0026#39;REDIS_PASSWORD\u0026#39;, null), \u0026#39;port\u0026#39; =\u0026gt; env(\u0026#39;REDIS_PORT\u0026#39;, 6379), // \u0026#34;persistent\u0026#34; =\u0026gt; \u0026#39;cache\u0026#39;, \u0026#39;database\u0026#39; =\u0026gt; 0, ], \u0026#39;session\u0026#39; =\u0026gt; [ \u0026#39;host\u0026#39; =\u0026gt; env(\u0026#39;REDIS_HOST\u0026#39;, \u0026#39;localhost\u0026#39;), \u0026#39;password\u0026#39; =\u0026gt; env(\u0026#39;REDIS_PASSWORD\u0026#39;, null), \u0026#39;port\u0026#39; =\u0026gt; env(\u0026#39;REDIS_PORT\u0026#39;, 6379), // \u0026#34;persistent\u0026#34; =\u0026gt; \u0026#39;cache\u0026#39;, \u0026#39;database\u0026#39; =\u0026gt; 0, ], \u0026#39;queue\u0026#39; =\u0026gt; [ \u0026#39;host\u0026#39; =\u0026gt; env(\u0026#39;REDIS_HOST\u0026#39;, \u0026#39;localhost\u0026#39;), \u0026#39;password\u0026#39; =\u0026gt; env(\u0026#39;REDIS_PASSWORD\u0026#39;, null), \u0026#39;port\u0026#39; =\u0026gt; env(\u0026#39;REDIS_PORT\u0026#39;, 6379), // \u0026#34;persistent\u0026#34; =\u0026gt; \u0026#39;cache\u0026#39;, \u0026#39;database\u0026#39; =\u0026gt; 0, ], ] ]; 因為 AWS Redis Cluster Enabled 的模式，database 的數量固定只有第 0 個，所以若有用其他的 database 的話，記得要把所有的 database 改為 0。\n"
},
{
	"uri": "https://kejyun.github.io/laravel5-book/http/request/request/",
	"title": "HTTP 請求",
	"tags": [],
	"description": "",
	"content": "HTTP 請求 這裏會介紹如何在 Laravel 5 驗證 HTTP 請求的資料\n建立新的請求驗證 如果我們有文章（Article）的模型，我們在每次請求過程中想要驗證傳入的資料，我們可以使用系列指令建立要驗證的請求：\n$ php artisan make:request CreateArticleRequest 請求驗證的檔案會被建立在 app\\Http\\Requests 目錄下，建立的檔案內容如下\n\u0026lt;?php namespace App\\Http\\Requests; // app\\Http\\Requests\\CreateArticleRequest.php use App\\Http\\Requests\\Request; class CreateArticleRequest extends Request { /** * Determine if the user is authorized to make this request. * 驗證使用者是否要登入狀態 * * @return bool */ public function authorize() { return true; } /** * Get the validation rules that apply to the request. * 驗證請求的資料規則 * * @return array */ public function rules() { return [ // 使用 | 設定驗證規則  \u0026#39;title\u0026#39; =\u0026gt; \u0026#39;required|min:3\u0026#39;, \u0026#39;body\u0026#39; =\u0026gt; \u0026#39;required|min:30\u0026#39;, // 使用陣列設定驗證規則  \u0026#39;published_at\u0026#39; =\u0026gt; [ \u0026#39;required\u0026#39;, \u0026#39;date\u0026#39;, ], ]; } } 在驗證請求的 CreateArticleRequest 中的 rules() 函式，除了僅回傳驗證規則外，你也可以判斷不同的狀況去加入不同的規則再回傳，像是：\n\u0026lt;?php namespace App\\Http\\Requests; // app\\Http\\Requests\\CreateArticleRequest.php use App\\Http\\Requests\\Request; class CreateArticleRequest extends Request { public function rules() { $rules = [ // 使用 | 設定驗證規則  \u0026#39;title\u0026#39; =\u0026gt; \u0026#39;required|min:3\u0026#39;, \u0026#39;body\u0026#39; =\u0026gt; \u0026#39;required|min:30\u0026#39;, // 使用陣列設定驗證規則  \u0026#39;published_at\u0026#39; =\u0026gt; [ \u0026#39;required\u0026#39;, \u0026#39;date\u0026#39;, ], ]; // 其他條件判斷  if ($condition) { $rules[\u0026#39;something_else\u0026#39;] = \u0026#39;required\u0026#39;; } return $rules; } } 指定 Controller 函式處理指定的請求驗證 在我們使用 Controller 去處理請求時，我們可以再傳入變數內設定要怎麼處理請求：\nclass ArticleController extends Controller { // 新增文章 public function store(App\\Http\\Requests\\CreateArticleRequest $request) { Article::create(Request:all()); // OR // Article::create($request-\u0026gt;all()); return redirect(\u0026#39;articles\u0026#39;); } } 這樣設定之後，所有的 HTTP 請求的 Input 資料都會經過 App\\Http\\Requests\\CreateArticleRequest 驗證，如果有經過驗證才會繼續執行後面的新增文章動作，否則的話則會丟出驗證錯誤的物件到原頁面。\n驗證錯誤訊息 這裏要注意到，視圖（View）的每一頁 Laravel 都會將驗證錯誤物件（Illuminate\\Support\\ViewErrorBag）包成 $errors 變數，所以你可以在每一頁去印出 $errors 值，$errors 變數儲存的是任何資料驗證錯誤的結果\n判斷是否有任何的錯誤並顯示錯誤訊息\n// 任一 blade 視圖（View）皆可以接收此錯誤變數 @if($errors-\u0026gt;any()) // 有錯誤訊息 \u0026lt;ul\u0026gt; $foreach ($errors-\u0026gt;all() as $error) \u0026lt;li\u0026gt;{{ $error }}\u0026lt;/li\u0026gt; @endforeach \u0026lt;/ul\u0026gt; @endif 使用 Controller 內建的 validate 驗證請求的資料 除了建立驗證 Request 物件，也可以直接使用 Controller 內建的 validate 去驗證請求\n如果不想要使用內建處理 HttpResponseException 的例外，你也可以自己 try catch 並自己處理例外狀況\nclass ArticleController extends Controller { // 新增文章 public function store(Requests $request) { try { $this-\u0026gt;validate($request, [ \u0026#39;title\u0026#39; =\u0026gt; \u0026#39;required|min:3\u0026#39;, \u0026#39;body\u0026#39; =\u0026gt; \u0026#39;required|min:30\u0026#39;, \u0026#39;published_at\u0026#39; =\u0026gt; \u0026#39;required|date\u0026#39;, ]); } catch (Exception $e) { // 自己處理例外狀況 } Article::create(Request:all()); // OR // Article::create($request-\u0026gt;all()); return redirect(\u0026#39;articles\u0026#39;); } } 使用者資料 取得 User Agent、Referrer\n\u0026lt;?php // User Agent request()-\u0026gt;server(\u0026#39;HTTP_USER_AGENT\u0026#39;); // Referrer request()-\u0026gt;server(\u0026#39;HTTP_REFERER\u0026#39;) 參考資料  Form Requests and Controller Validation - Laracasts  !INCLUDE \u0026ldquo;../../kejyun/book/laravel-5-for-beginner.md\u0026rdquo;\n"
},
{
	"uri": "https://kejyun.github.io/laravel5-book/database/postgresql/install-odbc-driver/",
	"title": "安裝 PostgreSQL ODBC driver",
	"tags": [],
	"description": "",
	"content": " 環境：OS X\n  日期：2015-03-29\n  PHP：5.6\n 在我們在 Laravel 使用 PostgreSQL 去做 Migration 的時候，我們會看到像下面這樣的錯誤訊息：\n$ php artisan migrate [PDOException] could not find driver $ 這表示我們沒有相關的連線驅動程式去連線到 PostgreSQL，所以我們需要安裝我們所需要的驅動程式\n在 OS X 的 PHP 相關環境我是用 brew 去安裝的，如果你也是用 brew 去安裝，可以先看看自己的套件是用哪一個版本的 PHP\n$ brew list autoconf git libpng mhash php56 readline zlib freetype icu4c libtool nvm php56-mcrypt unixodbc gettext jpeg mcrypt openssl postgresql wget 然後搜尋現在 brew 支援的 PostgreSQL 驅動程式\n$ brew search pgsql osm2pgsql\tphp54-pdo-pgsql php55-pdo-pgsql php56-pdo-pgsql 我們找到我們 php 5.6 版本的驅動程式了，可以用下面的指令去安裝\n$ brew install php56-pdo-pgsql 安裝完成後就可以正常的使用 Migration 或相關的 DB 指令去存取 PostgreSQL 了～～！！\n參考資料  Laravel: Error [PDOException]: Could not Find Driver in PostgreSQL  "
},
{
	"uri": "https://kejyun.github.io/laravel5-book/structure/service-repository-structure-principle/",
	"title": "Service &amp; Repository 架構設計準則（2017 年版本）",
	"tags": [],
	"description": "",
	"content": "Service \u0026amp; Repository 架構設計準則（2017 年版本） 傳統的 MVC（Model, View, Controller） 框架，當 Controller 收到請求之後，我們會在 Controller 內直接透過 Model 去撈取資料庫的資料，並在 Controller 做資料驗證、整合、快取、商業邏輯判斷\u0026hellip;等等的工作。\n當系統越來越大，會發現很多類似的商業邏輯的程式都散在各地，沒有辦法重複再利用，當程式需要異動或修改的時候，就要去搜尋所有程式碼，把許多相同商業邏輯的程式碼去做異動，但需要修改的地方若太多，往往會東漏西漏，導致系統出現錯誤，並造成往後開發的時間成本增加。\n所以我們會想要做到 減少重複的程式碼、提高維護開發的效率，所以將程式碼依照分類及分層抽出獨立控管，讓不同類型的程式專心處理自己相關的商業邏輯，讓開發維護更容易。\n隨著程式架構的演進會發展出更多不同的架構，所以這個設計架構準則也是會隨著時間做演進的。\n資料層級需求分析 Service (服務)\n我們原本在 Controller 處理請求時，會針對使用者的請求，做不同商業邏輯的處理，而同樣的商業邏輯可能會被不同的 Controller 存取，為了讓同個商業邏輯程式能夠重複使用，所以我會分出一層 Service (服務) ，將這些商業邏輯放在裡面，供不同的 Controller 存取。\n在 Service 方法中，會針對目前商業邏輯的資料進行蒐集與彙整，處理過後再回傳給 Controller\nRepository (資源庫)\n在不同 Service 可能會需要對資料庫撈取同樣的資料，為了避免撈取資料的邏輯重複出現在不同的地方，我們會分出一層 Repository (資源庫)，將同樣撈取 Model (模型) 資料的邏輯都寫在一起，供不同的 Service 存取。\n在 Repository 中，會在 function 名稱中指出這個方法是要撈什麼樣的資料，這樣方法可以重用，也可以讓程式有可讀性，不需要再去看 Model sql 條件的邏輯，判斷是在做什麼樣的處理\n e.g. PostRepository-\u0026gt;getWeekTopPosts(); // 取得本週熱門文章\n Model (模型)\n在 Model 中我們僅會寫對資料表對 Eloquent 相關的設定，像是 primaryKey (主鍵名稱) 或 table (資料表名稱)，讓 Model 能夠越乾淨越好，將一些撈取資料的邏輯都往 Repository 集中整理。\nPresenter (資料呈現)\n在 Model 我們有一些資料可能會想要有不同的呈現方式，像是文章發布時間 created_at 我們可能會想要呈現出像是 5 秒前、15 分鐘前、6 小時前 這樣的資料，這些資料因為是隨著時間不同而去動態變化，所以需要用程式去計算與 created_at 的時間差，再去看要如何呈現這筆資料。\n為了能夠讓這些不同資料呈現方式的邏輯能夠重複使用，且不污染 Model 的程式，所以我會分出一層 Presenter (資料呈現)  去輔助 Model 資料的呈現\n e.g. Post-\u0026gt;presenter()-\u0026gt;created_at_human_time;\n  laracasts/Presenter  Cache (快取)\n在使用 Repositoy 去對 Model 做存取得時候，如果我們資料沒有做異動，我們會將資料存放在快取中，直接讀取快取的資料，而減少對資料庫的存取，提高資料的存取效率\n而我們需要對 資料快取的設定、清除 及 快取鍵值 去做管理，快取像是協助 Repository 做資料的存取，所以我會分出一層 Cache (快取)  去輔助 Repository 做快取的處理\nChecker (檢查器)\n而每個商業邏輯需要驗證的資料不同，有些欄位在不同商業邏輯會有必填與非必填不同的差異，像是在做使用者身份驗證時，若有 Email 驗證及手機驗證，在 Email 驗證時，手機欄位為非必填欄位，在做手機驗證時， Email 為非必填欄位，但兩者皆為使用者的資料，無法強制使用者兩個欄位資料皆為必填，但在某些商業頁邏輯是必要的，但基本的資料驗證規則還是一樣，像是資料最長長度、email 格式\u0026hellip;等等。\n所以為了能夠重複使用共用的驗證器規則，所以建構了一個 Checker（檢查器） 的結構，去呼叫不同的 Validator 去檢查資料，像是同一個 Controller 處理的資料可能含有「會員」、「商品」資料，所以同時需要呼叫 會員驗證器（UserValidator） 及 商品驗證器（GoodsValidator） 的驗證規則去驗證資料，所以就透過 Checker（檢查器） 去呼叫不同的驗證器，來達到驗證不同資料的功能，輔助 Controller 做資料驗證。\nValidator (驗證器)\n為了讓資料驗證方法能夠重複使用，不需要在不同的地方去驗證相同的東西，這樣會造成驗證邏輯重複出現，若有需要異動驗證規則時，會難以維護。\n所以我沒有選擇將這些驗證的邏輯寫在 Services、Repository 或 Model 中。\n所以我會分出一層 Validator (驗證器) 輔助 Checker（檢查器） 做資料驗證。\nConcrete (服務組合)\n我們會在 Controller 去呼叫各個不同的 Service 去做資料的判斷處理，有時候不同的 Controller 會有相同呼叫 Service 的邏輯順序及組合的資料，為了減少重複程式，所以我會分出一層 Concrete (服務組合) 去協助 Controller 去做不同 Service 資料的整合撈取\n像是我們在許多 Controller 方法中，我們都要使用 $PostService-\u0026gt;find($post_id); 去找文章資料，並用 $UserService-\u0026gt;find($post_user_id); 去找文章作者相關資訊，這些在 Controller 重複出現的呼叫 Service 邏輯我們就可以寫在 Concrete 中去做呼叫\nConstant (常數)\n我們在做 Model 資料的撈取或是條件判斷時，可能會需要用 Post::where('status', 1)-\u0026gt;get() 或 $Post-\u0026gt;status == 1 去做資料的存取，但像 status 為 1 這種資料對我們是難以做閱讀的，需要知道 1 代表是什麼意思才知道此段程式的邏輯。\n所以我會分出一層 Constant (常數) 輔助做資料的識別，我會將狀態設為可識別的靜態變數，像是 PostConstant::STATUS_PUBLISH = 1;，所以在做程式判斷時，可以用 Post::where('status', PostConstant::STATUS_PUBLISH)-\u0026gt;get() 或 $Post-\u0026gt;status == PostConstant::STATUS_PUBLISH 去做判斷。\n 在 Constant 的變數皆為靜態變數，所以可以供任何類別去做存取。\n Support (支援)\n我可能會對一資源的資料做簡單的邏輯判斷，不需要依賴任何的 資料控制結構，像是 Service、Repository 或 Model，所以我會分出一層 Support (常數) 去做共用的輔助方法。\n像是我們可以用 PostSupport::getAllPostStatus() 去撈取文章的所有狀態，或者用 GoogleAnalyticSupport::api() 去對 GA 的 API 做存取。\n 在 Support 的方法皆為靜態方法，所以可以供任何類別去做存取。\n ExceptionCode (例外代碼)\n我們在做 API 的資料存取時，會針對不同的例外狀況回傳不同的 錯誤代碼 (error_code)，而同一個錯誤代碼可能在不同的 Controller 或 Service 被回傳，像是文章找不到我們會回傳錯誤代碼 10000001，為了管理及閱讀性方便，我會分出一層 ExceptionCode (例外代碼) 去做共用的例外代碼管理。\n像是找不到文章的代碼我會設為 PostExceptionCode::POST_NOT_FOUND = 10000001;，所以在程式中只要看到 PostExceptionCode::POST_NOT_FOUND 就可以馬上知道這個是找不到文章的錯誤代碼。\n 在 ExceptionCode 的變數皆為靜態變數，所以可以供任何類別去做存取。\n 資料層級結構 資料控制結構  Controller (控制器)  Concrete (服務組合)  Service (服務)  Repository (資源庫)  Model (模型) Presenter (資料呈現)   Cache (快取)     Checker (檢查器)  Validator (驗證器)      獨立結構  Constant (常數) Support (支援) ExceptionCode (例外代碼)  架構圖 結構說明 資料控制結構\n   結構名稱 說明     Controller (控制器) 控制要使用哪些 Service 或 Concrete 的商業邏輯，去組合出使用者請求需要的資料，並做資料的資料交易控制 (transaction) ，並使用 Checker 去檢查任何使用者傳進來的資料，確保資料的正確性   Service (服務) 做資料的驗證，並組合不同的 Repository 資料成商業邏輯，供 Controller 或 Concrete 存取   Repository (資源庫) 撈取屬於自己 Model 不同條件下的資料，並做快取控制，供 Service 存取   Model (模型) 資料表存取相關設定   Presenter (資料呈現) 協助 Model 做資料呈現處理   Cache (快取) 協助 Repository 做快取資料的控制   Checker (檢查器) 協助 Controller 做資料驗證   Validator (驗證器) 協助 Checker 做資料驗證   Concrete (服務組合) 協助 Controller 組合不同 Service 的資料成商業邏輯    獨立結構\n   結構名稱 說明     Constant (常數) 共用變數名稱設定   Support (支援) 共用方法   ExceptionCode (例外代碼) 共用例外代碼設定    架構使用原則 資料控制結構 存取限制 不能跨 2 階層以上存取\n Controller 不能存取 Repository Controller 不能存取 Validator Service 不能存取 Model  低階層的不能存取高階層的資料\n Model 不能存取 Repository Repository 不能存取 Service Validator 不能存取 Checker  同一個資料類型，不能互相呼叫\n避免同一類型類別呼叫，造成 new 物件的時候有無窮迴圈\nPostService 存取 UserService，UserService 存取 PostsService 造成無窮迴圈\n Concrete 不能呼叫 Concrete Service 不能呼叫 Service Checker 不能呼叫 Checker Validator 不能呼叫 Validator Repository 不能呼叫 Repository Cache 不能呼叫 Cache     結構名稱 可存取 可被存取     Controller (控制器) Checker、Concrete、Service、DB transaction -   Concrete (服務組合) Service Controller   Service (服務) Repository、Validator Controller、Concrete   Checker (檢查器) Validator Controller   Validator (驗證器) - Checker   Repository (資源庫) 自己的 Model、自己的 Cache Service   Cache (服務) - Repository   Model (模型) 自己的 Presenter Repository   Presenter (資料呈現) - Model    View (視圖) 使用限制 View 的職責是負責顯示資料，所有的資料應由 Controller 準備好再傳給 View，所以不要在 View 內有複雜的程式判斷邏輯，在 View 裡面只有 if, for, foreach 跟 echo 列印 的程式，僅需要將資料呈現在對的 HTML 裡面，不要再對資料重複處理過。\n像是文章的網址可能會因為類型不同會有不同的網址，像是一般文章網址可能為 http://kejyun.com/post/1，而影音文章網址可能為 http://kejyun.com/video/2，兩者的資料皆為 Post 資料表的資料，在 View 中要顯示網址應為 echo $Post-\u0026gt;post_url; 將網址印出，post_url 則是在傳給 View 之前就經過邏輯判斷的資料，而不是在 View 中判斷不同文章類型（PostConstant::POST_TYPE_NORMAL, PostConstant::POST_TYPE_VIDEO）在 View 中顯示不同的網址資料。\n之後若文章網址邏輯需要修改，則需要到各個 View 中去修改，很容易漏改道造成系統程式出錯\n\u0026lt;a href=\u0026#34;{{ $Post-\u0026gt;post_url }}\u0026#34;\u0026gt; {{ $Post-\u0026gt;Title }}\u0026lt;/a\u0026gt; 結構範例說明 Controller (控制器)  可以存取結構：Checker、Concrete、Service、DB transaction\n  可以被存取結構：無\n 處理 HTTP 請求的入口，依照需求呼叫 Concrete 或 Service 去做資料的存取，大部分情況呼叫 Service 去組合需要的資料就好，若相同的組合邏輯在不同的 Controller 都有用到，那就使用 Concrete 去組合不同的 Service\n要確保所有 Service 商業邏輯都正確跑完才允許對資料做異動，並避免 Transaction 在 Controller 及 Service 被重複呼叫，導致無法正確鎖定資料狀態，所以使用 Controller 當作資料交易（Transaction）的控制點\n\u0026lt;?php class PostController extends Controller { public function __construct( PostConcrete $PostConcrete, PostService $PostService, CommentService $CommentService, PostChecker $PostChecker ) { $this-\u0026gt;PostConcrete = $PostConcrete; $this-\u0026gt;PostService = $PostService; $this-\u0026gt;CommentService = $CommentService; $this-\u0026gt;PostChecker = $PostChecker; } // 顯示文章  public function show($post_id) { try { // 驗證資料  $input = [ \u0026#39;post_id\u0026#39; =\u0026gt; $post_id ]; $this-\u0026gt;PostChecker-\u0026gt;checkShow($input); // 撈取文章  $Post = $this-\u0026gt;PostConcrete-\u0026gt;findPost($post_id); // 撈取文章留言  $Comment = $this-\u0026gt;CommentService-\u0026gt;getCommentByPostId(post_id); } catch (Exception $exception) { throw $exception } } // 更新文章  public function update($post_id) { try { // 驗證資料  $input = request()-\u0026gt;all(); $input[\u0026#39;post_id\u0026#39;] = $post_id; $this-\u0026gt;PostChecker-\u0026gt;checkUpdate($input); // 交易開始  DB::beginTransaction(); // 更新文章  $Post = $this-\u0026gt;PostService-\u0026gt;update($post_id, $input); // 交易結束  DB::commit(); } catch (Exception $exception) { // 交易失敗  DB::rollBack(); throw $exception } } } Concrete (服務組合)  可以存取結構：Service\n  可以被存取結構：Controller\n 使用不同 Service 撈取資料，將不同資料組合成商業邏輯，供 Controller 做存取\n\u0026lt;?php class PostConcrete { public function __construct( PostService $PostService, UserService $UserService ) { $this-\u0026gt;PostService = $PostService; $this-\u0026gt;UserService = $UserService; } // 撈取文章資料  public function findPost($post_id){ try { // 撈取文章  $Post = $this-\u0026gt;PostService-\u0026gt;findPost($post_id); // 撈取文章作者資料  $user_id = $Post-\u0026gt;user_id; $Post-\u0026gt;user = $this-\u0026gt;UserService-\u0026gt;findUser($user_id); return $Post; } catch (Exception $exception) { throw $exception } } } Service (服務)  可以存取結構：Repository\n  可以被存取結構：Controller、Concrete\n 透過 Validator 驗證傳入的資料，並使用不同的 Repository 撈取資料，將不同資料組合成商業邏輯 使用 Repository 的 Cache 清除 Service 中撈取資料的快取\n\u0026lt;?php class PostService { public function __construct( PostRepository $PostRepository, PostTagRepository $PostTagRepository ) { $this-\u0026gt;PostRepository = $PostRepository; $this-\u0026gt;PostTagRepository = $PostTagRepository; } // 撈取文章  public function findPost($post_id) { try { // 撈取文章  $Post = $this-\u0026gt;PostRepository-\u0026gt;find($post_id); // 撈取文章標籤  $Post-\u0026gt;tag = $this-\u0026gt;PostTagRepository-\u0026gt;getByPostId($post_id); return $Post; } catch (Exception $exception) { throw $exception } } public function clearPostCache($post_id) { try { $Post = $this-\u0026gt;findPost($post_id); // 清除文章快取  $this-\u0026gt;PostRepository-\u0026gt;cache()-\u0026gt;clearPostCache($Post); // 清除文章標籤快取  $this-\u0026gt;PostTagCache-\u0026gt;clearPostTagCache($Post-\u0026gt;tag); } catch (Exception $exception) { throw $exception } } } Checker (檢查器)  可以存取結構：Validator\n  可以被存取結構：Controller\n 協助 Controller 驗證資料的正確性，若驗證錯誤則丟處例外，Controller 根據例外代碼去做處理\n\u0026lt;?php class PostValidator { public function checkFindPost($input){ // 驗證文章資料  $this-\u0026gt;PostValidator-\u0026gt;validatePostId($input); $this-\u0026gt;PostValidator-\u0026gt;validatePostContent($input); // 驗證會員資料  $this-\u0026gt;MemberValidator-\u0026gt;validateMemberId($input); } } Validator (驗證器)  可以存取結構：無\n  可以被存取結構：Checker\n 協助 Checker 驗證資料的正確性，若驗證錯誤則丟處例外，Checker 根據例外代碼去做處理\n\u0026lt;?php class PostValidator { public function validatePostId($input){ // 設定驗證規則  $rules = [ \u0026#39;post_id\u0026#39; =\u0026gt; [ \u0026#39;required\u0026#39;, \u0026#39;max:20\u0026#39;, ], ]; // 開始驗證  $this-\u0026gt;validator = Validator::make($input, $rules); if ($this-\u0026gt;validator-\u0026gt;fails()) { throw new Exception( \u0026#39;文章編號格式錯誤\u0026#39;, PostExceptionCode::POST_ID_FORMAT_ERROR ); } } } Repository (資源庫)  可以存取結構：自己的 Model、自己的 Cache\n  可以被存取結構：Service\n 僅能撈取屬於自己的 Model 資料，像 PostRepository 僅能存取 Post Model (模型) 的資料，並使用不同條件撈取 Model 的資料，供 Service 做存取\n\u0026lt;?php class PostRepository { public function __construct( Post $Post, PostCache $PostCache ) { $this-\u0026gt;Post = $Post; $this-\u0026gt;PostCache = $PostCache; } public function cache() { return $this-\u0026gt;PostCache; } public function find($post_id) { try { $cache_key = $this-\u0026gt;cache()-\u0026gt;getPostCacheKey($post_id); if (Cache::has($cache_key)) { // 有快取資料  $Post = Cache::get($cache_key); return $Post; } // 撈取資料庫文章資料  $Post = $this-\u0026gt;Post-\u0026gt;find($post_id); if(!is_null($Post)) { // 紀錄快取  $this-\u0026gt;cache()-\u0026gt;putPost($Post); } return $Post; } catch (Exception $exception) { throw $exception } } public function findLatestPost() { try { $cache_key = $this-\u0026gt;cache()-\u0026gt;getLatestPostCacheKey($post_id); if (Cache::has($cache_key)) { // 有快取資料  $$Posts = Cache::get($cache_key); return $Post; } // 撈取資料庫文章資料  $Post = $this-\u0026gt;Post -\u0026gt;order(\u0026#39;created_at\u0026#39;, \u0026#39;desc\u0026#39;) -\u0026gt;first(); if(!is_null($Post)) { // 紀錄快取  $this-\u0026gt;cache()-\u0026gt;putLatestPost($Post); } return $Post; } catch (Exception $exception) { throw $exception } } } Cache (快取)  可以存取結構：無\n  可以被存取結構：Repository\n 協助 Repository 做快取資料的控制，快取鍵值的管理、資料讀取及清除\n\u0026lt;?php class PostCache { public function getPostCacheKey($post_id) { // 撈取文章快取鍵值  } public function putPost(Post $Post) { // 紀錄文章快取  } public function clearPostCache(Post $Post) { // 清除文章快取  } } Model (模型)  可以存取結構：無\n  可以被存取結構：Repository\n Eloquent 存取資料表相關設定，使用 Eloquent 直接存取資料表資料\n\u0026lt;?php class Post extends Model { protected $table = \u0026#39;post\u0026#39;; protected $fillable = []; protected $primaryKey = \u0026#39;id\u0026#39;; protected $dates = [\u0026#39;created_at\u0026#39;, \u0026#39;updated_at\u0026#39;]; protected $presenter = \u0026#39;PostPresenter\u0026#39;; } Presenter (資料呈現)  可以存取結構：無\n  可以被存取結構：Model\n 提供 Model 的資料用其他方式呈現\n\u0026lt;?php class PostPresenter extends Presenter { public function created_at_human_time() { return $this-\u0026gt;created_at-\u0026gt;diffForHumans(); } } Constant (常數)  可以存取結構：無\n  可以被存取結構：無限制\n 資料皆為靜態變數，可以供所有資料層級 (e.g. Controller、Service、Repository) 做存取\n\u0026lt;?php class PostConstant { const POST_TYPE_PUBLIC = \u0026#39;P\u0026#39;; const POST_TYPE_DELETE = \u0026#39;D\u0026#39;; } Support (支援)  可以存取結構：無\n  可以被存取結構：無限制\n 方法皆為靜態變數，可以供所有資料層級 (e.g. Controller、Service、Repository) 做存取\n若有其他可供全域共用的方法皆寫在 Support 靜態方法供大家存取\n\u0026lt;?php class PostSupport { // 撈取所有文章類型  public static function getAllPostType() { $all_post_type = [ PostConstant::POST_TYPE_PUBLIC, PostConstant::POST_TYPE_DELETE, ]; return $all_post_type; } } ExceptionCode (例外代碼)  可以存取結構：無\n  可以被存取結構：無限制\n 資料皆為靜態變數，可以供所有資料層級 (e.g. Controller、Service、Repository) 做存取\n\u0026lt;?php class PostExceptionCode { const POST_ID_FORMAT_ERROR = 10000001; const POST_NOT_FOUND = 10000002; const POST_TAG_NOT_FOUND = 10000003; } "
},
{
	"uri": "https://kejyun.github.io/laravel5-book/services/laravel-mix/laravel-mix-intro/",
	"title": "Laravel Mix 介紹",
	"tags": [],
	"description": "",
	"content": "Laravel Mix 介紹 安裝 確認系統有安裝 node 及 npm\nnode -v npm -v 套件安裝除錯 在安裝過程中出現 node_modules/pngquant-bin/vendor/pngquant binary doesn't seem to work correctly 的訊息，如下：\n$ npm install \u0026gt; pngquant-bin@4.0.0 postinstall /home/web-laravel55/node_modules/pngquant-bin \u0026gt; node lib/install.js ⚠ The `/home/web-laravel55/node_modules/pngquant-bin/vendor/pngquant` binary doesn't seem to work correctly ⚠ pngquant pre-build test failed ℹ compiling from source ✔ pngquant pre-build test passed successfully ✖ Error: pngquant failed to build, make sure that libpng-dev is installed at Promise.all.then.arr (/home/web-laravel55/node_modules/pngquant-bin/node_modules/bin-build/node_modules/execa/index.js:231:11) at process._tickCallback (internal/process/next_tick.js:68:7) npm WARN ajv-keywords@3.4.1 requires a peer of ajv@^6.9.1 but none is installed. You must install peer dependencies yourself. npm WARN optional SKIPPING OPTIONAL DEPENDENCY: fsevents@1.2.9 (node_modules/fsevents): npm WARN notsup SKIPPING OPTIONAL DEPENDENCY: Unsupported platform for fsevents@1.2.9: wanted {\u0026quot;os\u0026quot;:\u0026quot;darwin\u0026quot;,\u0026quot;arch\u0026quot;:\u0026quot;any\u0026quot;} (current: {\u0026quot;os\u0026quot;:\u0026quot;linux\u0026quot;,\u0026quot;arch\u0026quot;:\u0026quot;x64\u0026quot;}) npm ERR! code ELIFECYCLE npm ERR! errno 1 npm ERR! pngquant-bin@4.0.0 postinstall: `node lib/install.js` npm ERR! Exit status 1 npm ERR! npm ERR! Failed at the pngquant-bin@4.0.0 postinstall script. npm ERR! This is probably not a problem with npm. There is likely additional logging output above. npm ERR! A complete log of this run can be found in: npm ERR! /home/kejyun/.npm/_logs/2019-07-30T04_22_17_230Z-debug.log 可以在 Ubuntu 安裝 libpng-dev 套件，即可正常安裝此套件\nsudo apt-get install libpng-dev npm install -g pngquant-bin npm run dev 參考資料  Compiling Assets (Laravel Mix) - Laravel - The PHP Framework For Web Artisans node_modules/pngquant-bin/vendor/pngquant` binary doesn\u0026rsquo;t seem to work correctly · Issue #78 · imagemin/pngquant-bin · GitHub  "
},
{
	"uri": "https://kejyun.github.io/laravel5-book/services/errors-logs/packages/errors-log-packages-log-viewer/",
	"title": "Log Viewer",
	"tags": [],
	"description": "",
	"content": "Log Viewer 參考資料  ARCANEDEV/LogViewer: Provides a log viewer for Laravel 5 Laravel Log Viewer using LogViewer Package in Laravel 5.6 - Learn Infinity - YouTube [Package] LogViewer (For Laravel 5)  "
},
{
	"uri": "https://kejyun.github.io/laravel5-book/services/unit-test/unit-test-post-csrf/",
	"title": "POST CSRF 錯誤",
	"tags": [],
	"description": "",
	"content": "POST CSRF 錯誤 當我們在使用 Unit test 做 POST 測試時，測試的程式可能像：\n\u0026lt;?php class UserTest extends TestCase { /** * 測試註冊 */ public function testSignup() { $parameters = [ \u0026#39;email\u0026#39;=\u0026gt;\u0026#39;kejyun@gmail.com\u0026#39;, \u0026#39;name\u0026#39;=\u0026gt;\u0026#39;KeJyun\u0026#39; ]; // 傳送參數  $response = $this-\u0026gt;call(\u0026#39;POST\u0026#39;, \u0026#39;/signup\u0026#39;, $parameters); $this-\u0026gt;assertEquals(200, $response-\u0026gt;getStatusCode()); } } 在執行單元測試後，你會收到一個 TokenMismatchException 的例外錯誤，這個部分是 Middleware VerifyCsrfToken 的驗證錯誤\n這是因為 Laravel 5 在所有的 POST、PUT、DELETE 的路由方法中，都會預設加入 CSRF Token 的檢查，他會檢查 POST 過來的資料中 _token 的資料值與 Session 中的 token 是否相符，或是驗證標頭中的 X-CSRF-TOKEN 是否相符。\n所以在我們每一次做 POST、PUT、DELETE 的請求時，我們都必須要將 CSRF Token 帶入檢查，才能執行後面的程式動作，我們可以用這樣的方式帶入 CSRF Token：\n\u0026lt;?php class UserTest extends TestCase { /** * 測試註冊 */ public function testSignup() { // 開啟 Session  Session::start(); // 參數加入 CSRF token  $parameters = [ \u0026#39;_token\u0026#39;=\u0026gt;csrf_token(), \u0026#39;email\u0026#39;=\u0026gt;\u0026#39;kejyun@gmail.com\u0026#39;, \u0026#39;name\u0026#39;=\u0026gt;\u0026#39;KeJyun\u0026#39; ]; // 傳送參數  $response = $this-\u0026gt;call(\u0026#39;POST\u0026#39;, \u0026#39;/signup\u0026#39;, $parameters); $this-\u0026gt;assertEquals(200, $response-\u0026gt;getStatusCode()); } } 在使用 csrf_token() 方法時，都必須要先使用 Session::start(); 將 Session 開啟，以紀錄當時的 CSRF Token 做驗證，並將 _token 當作參數傳送到 POST、PUT、DELETE 的路由當中，就可以正常執行單元測試了！\n參考資料  HTTP 路由 - Laravel.tw Testing Laravel 5 Routes with CSRF Protection Using PHPUnit  "
},
{
	"uri": "https://kejyun.github.io/laravel5-book/http/request/",
	"title": "Request 請求",
	"tags": [],
	"description": "",
	"content": "這裏會介紹如何在 Laravel 5 處理 HTTP Request 請求。\n"
},
{
	"uri": "https://kejyun.github.io/laravel5-book/services/errors-logs/packages/errors-log-packages-slack-log/",
	"title": "Slack Log",
	"tags": [],
	"description": "",
	"content": "Slack Log Slack Logging  版本：Laravel 5.6 內建 Slack Logging\n 1. 加入 Slack App\n加入新的 App 到 Slack\n2. 搜尋 Slack App Incoming Webhook\n搜尋 Incoming Webhook，讓 Laravel 可以發送訊息到 Slack\n3. Slack App Incoming Webhook 加入設定\n4. 取得 Slack App Incoming Webhook 網址\n5. 設定 log 方式\n在 config/logging.php 檔案中的 stack 加入 slack 設定，這樣 Log 資料會記錄到 Log File 及 Slack\n// config/logging.php return [ \u0026#39;default\u0026#39; =\u0026gt; env(\u0026#39;LOG_CHANNEL\u0026#39;, \u0026#39;stack\u0026#39;), \u0026#39;channels\u0026#39; =\u0026gt; [ \u0026#39;stack\u0026#39; =\u0026gt; [ \u0026#39;driver\u0026#39; =\u0026gt; \u0026#39;stack\u0026#39;, \u0026#39;channels\u0026#39; =\u0026gt; [\u0026#39;single\u0026#39;, \u0026#39;slack\u0026#39;], ], \u0026#39;slack\u0026#39; =\u0026gt; [ \u0026#39;driver\u0026#39; =\u0026gt; \u0026#39;slack\u0026#39;, \u0026#39;url\u0026#39; =\u0026gt; env(\u0026#39;LOG_SLACK_WEBHOOK_URL\u0026#39;), \u0026#39;username\u0026#39; =\u0026gt; \u0026#39;Laravel Log\u0026#39;, \u0026#39;emoji\u0026#39; =\u0026gt; \u0026#39;:boom:\u0026#39;, \u0026#39;level\u0026#39; =\u0026gt; \u0026#39;debug\u0026#39;, ], ], ]; 設定 .env 檔案，將 Slack Incoming Webhook 網址 設定到 LOG_SLACK_WEBHOOK_URL\nLOG_SLACK_WEBHOOK_URL=https://hooks.slack.com/services/XXXXXXXXXX 6. 檢視 Slack Laravel Log\n當程式使用 Log::error('WFT Error Log'); 去紀錄 Log 或有任何的 Exception 就可以在 Slack 看到了\nLaravel Slack Log  版本：Laravel 5.5 套件 cr0wst/laravel-slack-log: Utilizes Laravel\u0026rsquo;s notifications to provide logging to slack at various levels. Inspired by Log4j.\n 1. 安裝套件\ncomposer require smcrow/laravel-slack-log 2. 設定 config/app.php\n\u0026lt;?php // config/app.php return [ \u0026#39;aliases\u0026#39; =\u0026gt; [ \u0026#39;SlackLog\u0026#39; =\u0026gt; \\Smcrow\\SlackLog\\Facades\\SlackLog::class ], ]; 3. 建立設定檔\nphp artisan vendor:publish 4. 丟出例外 Slack Log\n\u0026lt;?php try { throw new Exception(\u0026#39;Hello Error Message\u0026#39;); } catch (Exception $exception) { SlackLog::debug($exception); SlackLog::debug($exception); SlackLog::trace($exception); SlackLog::info($exception); SlackLog::warn($exception); SlackLog::error($exception); } 5. Log 等級及顯示方式\n DEBUG TRACE INFO WARN ERROR  1. DEBUG\n2. TRACE\n3. INFO\n4. WARN\n5. ERROR\n參考資料 Laravel 5.3\n Sending Slack Notifications from Your Laravel App – Olayinka Omole – Medium  Laravel 5.5\n gpressutto5/laravel-slack: Slack notification for Laravel as it should be. Easy, fast, simple and highly testable. cr0wst/laravel-slack-log: Utilizes Laravel\u0026rsquo;s notifications to provide logging to slack at various levels. Inspired by Log4j.  Laravel 5.6\n Enviando logs para o Slack no Laravel - YouTube Logging - Laravel - The PHP Framework For Web Artisans Notifications - Laravel - The PHP Framework For Web Artisans  不限 Laravel 版本\n maknz/slack: A simple PHP package for sending messages to Slack, with a focus on ease of use and elegant syntax. Laravel Slack - Laravel Tips \u0026lsquo;N Tricks  Slack\n Slack Imcoming webhooks  CloudWatch Slack\n jamesfairhurst/laravel-cloudwatch-logs-lambda-slack: Use AWS CloudWatch Logs \u0026amp; Lambda to post Laravel Log messages to Slack Using AWS CloudWatch for Laravel Logs on Forge – James Fairhurst – Medium  討論文章\n L5 Monolog with Slack integration  "
},
{
	"uri": "https://kejyun.github.io/laravel5-book/services/errors-logs/service/errors-log-service-understand-io/",
	"title": "Understand.io",
	"tags": [],
	"description": "",
	"content": "Understand.io  紀錄 Laravel Log\n 在 understand/understand-laravel5 套件 github，依照步驟安裝 Understand.io\n1.安裝套件\ncomposer require understand/understand-laravel5 2.加入套件設定\n在 config/app.php 檔案中加入設定\n\u0026lt;?php // config/app.php return [ \u0026#39;providers\u0026#39; =\u0026gt; [ Understand\\UnderstandLaravel5\\UnderstandLaravel5ServiceProvider::class, ], ] 3.設定 .env 檔案\nUNDERSTAND_ENABLED=true UNDERSTAND_TOKEN=\u0026lt;API TOKEN 放這裡\u0026gt; 4.紀錄 Log\n\u0026lt;?php \\Log::error(\u0026#39;Understand.io test error\u0026#39;); 參考資料  Understand.io - Online Event and Log Management understand/understand-laravel5  "
},
{
	"uri": "https://kejyun.github.io/laravel5-book/services/mail/mail-gmail/",
	"title": "使用 Gmail 寄信",
	"tags": [],
	"description": "",
	"content": "使用 Gmail 寄信 在測試機測試的時候，為了節省郵件服務的開銷，我們可以使用 Gmail 當作我們測試的郵件服務，所以我們來介紹如何使用 Gmail 寄信\n設定 config/mail.php  driver 設為 smtp\n  host 設為 smtp.gmail.com\n  port 設為 587\n  username 設為你要用來寄信的 Gmail 帳號 kejyun@gmail.com\n  password 設為 Gmail 帳號的密碼\n  pretend 設為 true，這樣才可以正常使用 Gmail 寄送\n 設定完後會像這樣：\n// config/mail.php return [ \u0026#39;driver\u0026#39; =\u0026gt; \u0026#39;smtp\u0026#39;, \u0026#39;host\u0026#39; =\u0026gt; \u0026#39;smtp.gmail.com\u0026#39;, \u0026#39;port\u0026#39; =\u0026gt; 587, \u0026#39;from\u0026#39; =\u0026gt; [\u0026#39;address\u0026#39; =\u0026gt; \u0026#39;kejyun@gmail.com\u0026#39;, \u0026#39;name\u0026#39; =\u0026gt; \u0026#39;KeJyun\u0026#39;], \u0026#39;encryption\u0026#39; =\u0026gt; \u0026#39;tls\u0026#39;, \u0026#39;username\u0026#39; =\u0026gt;\u0026#39;kejyun@example.com\u0026#39;, \u0026#39;password\u0026#39; =\u0026gt; \u0026#39;abcdefghijklmnopqrstuvwxyz123456\u0026#39;, \u0026#39;sendmail\u0026#39; =\u0026gt; \u0026#39;/usr/sbin/sendmail -bs\u0026#39;, \u0026#39;pretend\u0026#39; =\u0026gt; false, ]; 測試使用 Gmail 寄信 Mail::raw(\u0026#39;測試使用 Laravel 5 的 Gmail 寄信服務\u0026#39;, function($message) { $message-\u0026gt;to(\u0026#39;kejyun@example.com\u0026#39;); }); 這樣我們就可以使用 Gmail 去當作我們的郵件寄送服務了！！！\n參考資料  Attempting to get Email to work in Laravel 5 郵件 - Laravel.tw  "
},
{
	"uri": "https://kejyun.github.io/laravel5-book/services/errors-logs/errors-show-exception-in-cli/",
	"title": "在單元測試顯示例外",
	"tags": [],
	"description": "",
	"content": "在單元測試顯示例外（Show Exception in CLI） 在 Laravel 5 做單元測試時，使用 try catch 丟出例外時，Laravel 5 會自動地將例外的錯誤訊息處理成網頁的樣式呈現，這樣的好處是在網頁中做操作發生例外狀況時，可以直接看到例外的錯誤訊息，但是在寫單元測試 (Unit test) 時，他只會將這些錯誤先記錄在 log 檔案裡面（storage/log/laravel-yyyy-mm-dd.log），我們要看到這些錯誤的狀況必須要再另開終端機去執行 php artisan tail 去觀看這些 例外 Log 的狀況，這樣在做測試的時候是相當麻煩的。\n在 Laravel 5 中所有的例外（Exception）都會被丟到 app/Exceptions/Handler.php 中的 render() 去處理\n\u0026lt;?php // app/Exceptions/Handler.php  class Handler extends ExceptionHandler { /** * Render an exception into an HTTP response. * 將例外錯誤轉為 HTTP 回應 * * @param \\Illuminate\\Http\\Request $request * @param \\Exception $e * @return \\Illuminate\\Http\\Response */ public function render($request, Exception $e) { return parent::render($request, $e); } } 我們如果需要在 CLI 就顯示例外錯誤訊息的話，必須修改 render() 函式，而我想要保有原本在網頁做除錯的彈性，所以我在環境變數 .env 檔案中加入例外處理（Exception）顯示的開關，當有設定開啟時，才直接顯示例外訊息。\n\u0026lt;!-- .env --\u0026gt; EXCEPTION_DISPLAY_SWITCH=true .env 設定好後，就將 render() 函式修改為這樣\n\u0026lt;?php // app/Exceptions/Handler.php  class Handler extends ExceptionHandler { /** * Render an exception into an HTTP response. * 將例外錯誤轉為 HTTP 回應 * * @param \\Illuminate\\Http\\Request $request * @param \\Exception $e * @return \\Illuminate\\Http\\Response */ public function render($request, Exception $e) { // 預設不直接顯示例外訊息  $exception_display_switch = env(\u0026#39;EXCEPTION_DISPLAY_SWITCH\u0026#39;, false); if ($exception_display_switch) { throw $e; } return parent::render($request, $e); } } 這樣設定完後，也保留原本系統處理例外狀況的彈性，也可以讓我在單元測試（Unit test）中可以正常的去顯示例外訊息了！！\n參考資料  錯誤與日誌 - laravel.tw how do I create custom error page in laravel 5 Laravel 5.0 - Custom Error Pages  "
},
{
	"uri": "https://kejyun.github.io/laravel5-book/services/helpers/custom-helpers/",
	"title": "自定義輔助方法",
	"tags": [],
	"description": "",
	"content": "自定義輔助方法 Laravel 中有提供許多的輔助方法（Helpers），但有時候我們會想要自訂自己的輔助方法，我們可以這樣做\n加入自定義引用的 Helpers.php 檔案到 /app/Support/Helpers/Helpers.php 路徑下 \u0026lt;?php // /app/Support/Helpers/Helpers.php  // Helper 檔案路徑 $helpers = [ \u0026#39;CustomHelper.php\u0026#39; ]; // 載入 Helper 檔案 foreach ($helpers as $helperFileName) { include __DIR__ . \u0026#39;/\u0026#39; .$helperFileName; } 以後若有其他的 Helper 需要加入，僅需要加到 Helpers.php 檔案中的 $helpers 變數當中即可\n在 composer.json 中自動載入加入該 Helper.php /*composer.json*/ { \u0026#34;autoload\u0026#34;: { \u0026#34;classmap\u0026#34;: [ \u0026#34;database\u0026#34; ], \u0026#34;psr-4\u0026#34;: { \u0026#34;App\\\\\u0026#34;: \u0026#34;app/\u0026#34; }, \u0026#34;files\u0026#34;: [ \u0026#34;app/Support/Helpers/helpers.php\u0026#34; ] } } 重新編譯 autoload.php $ composer dump-autoload Generating autoload files 這樣我們就可以自動的載入我們自定義的 Helper 函式了！！\n Best practices for custom helpers on Laravel 5  "
},
{
	"uri": "https://kejyun.github.io/laravel5-book/view/view-intro/",
	"title": "視圖介紹",
	"tags": [],
	"description": "",
	"content": "視圖介紹 這裏會介紹如何在 Laravel 5 處理視圖（View）\nLaravel 的視圖是放在 resource/views 目錄內\n建立共用的視圖 我們網頁常常會出現 header 跟 footer 在不同的視圖中為相同的狀況，唯一有變的只有中間的內容隨著不同的請求而有變動，如果有這樣的設計需求，我們可以替所有視圖建立共用的視圖，假設我們把這個共用的視圖放在 resource/view/app.blade.php 下，其內容可能是：\n\u0026lt;!-- resource/view/app.blade.php --\u0026gt; \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;zh-TW\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;我的網站\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#34;container\u0026#34;\u0026gt; @yield(\u0026#39;content\u0026#39;) \u0026lt;/div\u0026gt; @yield(\u0026#39;other_info\u0026#39;) \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 如果我們要顯示文章的資訊在 content 中，文章的說明在 other_info 中，我們可以在 blade 中這樣設定：\n\u0026lt;!-- resource/view/article.blade.php --\u0026gt; @extend(\u0026#39;app\u0026#39;) @section(\u0026#39;content\u0026#39;) \u0026lt;h1\u0026gt;文章標題\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt; Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. \u0026lt;/p\u0026gt; @stop @section(\u0026#39;other_info\u0026#39;) 其他資訊 @stop 這樣 Laravel 就會幫我們把相對應的資訊塞到 app.blade.php 當中相對應的位置\n引入共用的視圖 假如我們要在特定的某幾頁使用 Facebook 留言板，像是：\n\u0026lt;div id=\u0026#34;fb-root\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;script\u0026gt;(function(d, s, id) { var js, fjs = d.getElementsByTagName(s)[0]; if (d.getElementById(id)) return; js = d.createElement(s); js.id = id; js.src = \u0026#34;//connect.facebook.net/zh_TW/sdk.js#xfbml=1\u0026amp;version=v2.3\u0026amp;appId=12345566\u0026#34;; fjs.parentNode.insertBefore(js, fjs); }(document, \u0026#39;script\u0026#39;, \u0026#39;facebook-jssdk\u0026#39;));\u0026lt;/script\u0026gt; \u0026lt;div class=\u0026#34;fb-comments\u0026#34; data-href=\u0026#34;http://laravel5-book.kejyun.com/\u0026#34; data-numposts=\u0026#34;5\u0026#34; data-colorscheme=\u0026#34;light\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; 但我們不想要這些相同的程式碼片段散落在各個不同的視圖中，我們可以把它整理在 resource/views/vendor/_fbcomment.blade.php 當中\n然後在文章視圖當中我們就可以這樣去引入 Facebook 留言板：\n\u0026lt;!-- resource/view/article.blade.php --\u0026gt; @extend(\u0026#39;app\u0026#39;) @section(\u0026#39;content\u0026#39;) \u0026lt;h1\u0026gt;文章標題\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt; Lorem ipsum dolor sit amet \u0026lt;/p\u0026gt; @include(\u0026#39;vendor/_fbcomment\u0026#39;) @include(\u0026#39;vendor._fbcomment\u0026#39;) @stop @section(\u0026#39;other_info\u0026#39;) 其他資訊 @stop 傳入變數到引用的視圖當中 在我們新增與編輯文章的視圖當中，幾乎所有的視圖都是一樣的，不一樣的地方可能只有「表單處理的 action 不同（create \u0026amp; edit）」、「送出的按鈕文字不同（新增違章 \u0026amp; 編輯文章）」\n但我們還是希望兩個視圖能夠一起被引用，把其他不同的地方當作變數傳入，就可以達到視圖重構的效果，避免類似的視圖重複出現在不同地方，像是：\n\u0026lt;!-- resource/view/partials/articles/_form.blade.php --\u0026gt; {!! Form::label(\u0026#39;title\u0026#39;,\u0026#39;標題\u0026#39;) !!} {!! Form::text(\u0026#39;title\u0026#39;, null) !!} {!! Form::label(\u0026#39;content\u0026#39;,\u0026#39;內文\u0026#39;) !!} {!! Form::text(\u0026#39;content\u0026#39;, null) !!} {!! Form::submit($submitButtonText) !!} 當我們要引用表單的視圖，則必須把按鈕的文字傳送給表單，像是：\n\u0026lt;!-- resource/view/article.blade.php --\u0026gt; @extend(\u0026#39;app\u0026#39;) @section(\u0026#39;content\u0026#39;) @include(\u0026#39;partials/articles/_form\u0026#39;, [\u0026#39;submitButtonText\u0026#39; =\u0026gt; \u0026#39;新增文章\u0026#39;]) @include(\u0026#39;partials/articles/_form\u0026#39;, [\u0026#39;submitButtonText\u0026#39; =\u0026gt; \u0026#39;編輯文章\u0026#39;]) @stop @section(\u0026#39;other_info\u0026#39;) 其他資訊 @stop 備註 引用或載入視圖路徑 在使用 blade 中的 @extend() 或 @include() 函數，他所參照的視圖相對位置是從 resource/views/ 開始的\n所以如果你的視圖是放在 resource/views/partials/other.blade.php 中，你要引用或載入的話則可以用 . 或 / 去指定相對的視圖位置，像是：\n\u0026lt;!-- 引用 --\u0026gt; @extend(\u0026#39;partials._other\u0026#39;) @extend(\u0026#39;partials/_other\u0026#39;) \u0026lt;!-- 載入 --\u0026gt; @include(\u0026#39;partials._other\u0026#39;) @include(\u0026#39;partials/_other\u0026#39;) 設計模式 樣板檔案名稱 通常若不是完整的視圖，僅是部分的視圖，通常會將檔案名稱最前面加上底線 _，用來告知團隊程式設計師這個 blade 視圖不是完整的視圖\n參考資訊  View Partials and Form Reuse - Laracasts  "
},
{
	"uri": "https://kejyun.github.io/laravel5-book/services/auth/auth-login/",
	"title": "認證登入",
	"tags": [],
	"description": "",
	"content": "認證登入（Auth） 設定 Laravel 內建認證的設定檔案放在 config/auth.php 中，預設會使用 App\\User 的類別當作驗證的 Eloquent 模型\n[ \u0026#39;model\u0026#39; =\u0026gt; App\\User::class, ] 如果我們用Model 模型設計模式去設計我們的程式架構，我們 User 實體模型的程式可能會放在 App\\KeJyunApp\\User\\Entities\\User.php 中，這時候我們的認證模型設定可以設定成像這樣（依照命名空間去設定）：\n[ \u0026#39;model\u0026#39; =\u0026gt; App\\KeJyunApp\\User\\Entities\\User::class, ] 這樣 Laravel 內建的認證就可以用我們指定的實體模型去進行認證了！！\n手動登入認證 Laravel 內建的認證使用 Auth 去進行身份認證，如果我們要用使用者的「email」及「密碼」做登入，我們的登入程式可能會像：\n$email = \u0026#39;kejyun@gmail.com\u0026#39;; $password = \u0026#39;1234\u0026#39;; if (Auth::attempt([\u0026#39;email\u0026#39; =\u0026gt; $email, \u0026#39;password\u0026#39; =\u0026gt; $password])) { // 已登入成功！！！ } 使用 Auth:attempt() 的方式去驗證使用者時，Laravel 會先到 User 資料表透過 Email 抓取使用者的資料，產生出來的 SQL 會像：\nSELECT * FROM \u0026#34;users\u0026#34; WHERE \u0026#34;email\u0026#34; = \u0026#39;kejyun@gmail.com\u0026#39; LIMIT 1; 抓取完使用者之料後再將 password 欄位用雜湊的 Hash::check() 方式去比對驗證密碼是否正確，再記錄使用者的 SESSION 資料\n如果我們的使用者有限制啟用帳號的人才可以登入，所以我們要用使用者的「email」、「密碼」及「啟用狀態」做登入，我們的登入程式可能會像：\n$email = \u0026#39;kejyun@gmail.com\u0026#39;; $password = \u0026#39;1234\u0026#39;; $status = \u0026#39;active\u0026#39;; if (Auth::attempt([\u0026#39;email\u0026#39; =\u0026gt; $email, \u0026#39;password\u0026#39; =\u0026gt; $password, \u0026#39;status\u0026#39; =\u0026gt; $status])) { // 已登入成功！！！ } 產生出來的 SQL 會像：\nSELECT * FROM \u0026#34;users\u0026#34; WHERE \u0026#34;email\u0026#34; = \u0026#39;kejyun@gmail.com\u0026#39; AND \u0026#34;status\u0026#34; = \u0026#39;active\u0026#39; LIMIT 1; Laravel 一樣是先抓取使用者資料後，再做密碼驗證的動作！\n使用記住我的方式登入 $email = \u0026#39;kejyun@gmail.com\u0026#39;; $password = \u0026#39;1234\u0026#39;; $remember_me = true; if (Auth::attempt([\u0026#39;email\u0026#39; =\u0026gt; $email, \u0026#39;password\u0026#39; =\u0026gt; $password], $remember_me)) { // 已使用記住我登入成功！！！ }  如果你是自己建立自己 User 資料表的 Migration，記得在自己的 Migration 中加入 $table-\u0026gt;rememberToken(); 的設定，加入 remember_token 欄位，這個欄位可以讓 Laravel 使用 記住我 的方式去記住使用者的 session token\n 判斷使用者是否已登入 我們可以使用 Auth::check() 的方式，判斷使用者是否已登入\nif (Auth::check()) { // 已登入 } 取得登入使用者的物件 $user = Auth::user(); // KeJyun var_dump($user-\u0026gt;name); 使用特定使用者的 ID 登入 $user_id = \u0026#39;1\u0026#39;; Auth::loginUsingId($user_id); 登出 Auth::logout(); 登出其他裝置使用者  Laravel 5.6 or higher\n Auth::logoutOtherDevices($password); 參考資料  認證 - Laravel.tw Authentication - Laravel - The PHP Framework For Web Artisans  "
},
{
	"uri": "https://kejyun.github.io/laravel5-book/services/auth/",
	"title": "認證（Auth）",
	"tags": [],
	"description": "",
	"content": "這裏介紹一些 Laravel 提供的認證（Auth）功能\n"
},
{
	"uri": "https://kejyun.github.io/laravel5-book/services/queue/queue-intro/",
	"title": "隊列介紹",
	"tags": [],
	"description": "",
	"content": "隊列介紹 Laravel 隊列的設定檔在 config/queue.php，在這裡你可以設定你想要用什麼樣的隊列（Queue）服務去執行你的隊列，而 Laravel 預設有支援 database、Beanstalkd、IronMQ、Amazon SQS、Redis 這幾種隊列的服務。\n我們通常會將一些需要花比較久時間處理的工作丟給隊列去背景執行，讓使用者能夠快速的的到網站的回應，像是我們在寄送帳號認證信件時，因為透過郵件伺服器去寄送可能會花費比較久的時間，所以我們會將這類的工作丟到隊列去執行，所以使用者的認證信件就會延遲的發送到他們的信箱，但是使用者在瀏覽網站時卻可以有更好的體驗！\n指令 在使用 Queue 去幫我們做工作的時候，我們在系統背景需要執行傾聽 Queue 是否有工作的指令，像是 php artisan queue:listen，這樣 Queue 中有新工作需要做，才能夠正常的去執行。\n$ php artisan queue:listen 執行 Queue 指令有一些相關的參數，可以依照自己的環境去調校\n$php artisan queue:listen [--queue[=\u0026quot;...\u0026quot;]] [--delay[=\u0026quot;...\u0026quot;]] [--memory[=\u0026quot;...\u0026quot;]] [--timeout[=\u0026quot;...\u0026quot;]] [--sleep[=\u0026quot;...\u0026quot;]] [--tries[=\u0026quot;...”]]    參數 說明 指令     queue 設定優先執行的工作順序 php artisan queue:listen --queue=high,low   delay 在執行的工作發生錯誤時，要延遲多久重新執行（單位：秒），預設 0 秒 php artisan queue:listen --delay=10   memory 執行工作最多能夠使用的記憶體上限（單位：MB），預設 128 MB php artisan queue:listen --memory=1024   timeout 執行的工作做長執行的時間是多長（單位：秒），預設 60 秒 php artisan queue:listen --timeout=3600   sleep 在沒有找到可以做的工作時，需要間隔多少秒再去檢查有無新的工作（單位：秒），預設 3 秒 php artisan queue:listen --sleep=10   tries 工作執行失敗時，最多重新嘗試執行幾次（單位：次數），預設 0，不重新嘗試 php artisan queue:listen --tries=3    "
},
{
	"uri": "https://kejyun.github.io/laravel5-book/environment/dot-env-file/",
	"title": ".env 檔案",
	"tags": [],
	"description": "",
	"content": ".env 檔案 Laravel 4 .env 檔案 在 Laravel 4 的時候，我們通常會在 /bootstrap/start.php 中，去設定我們的 hostname 是屬於哪一種開發環境，再針對不同的開發環境有不同的設定檔（.env.*.php）\n\u0026lt;?php $env = $app-\u0026gt;detectEnvironment(array( \u0026#39;local\u0026#39; =\u0026gt; array( \u0026#39;KeJyun-Macbook\u0026#39; ), \u0026#39;dev\u0026#39; =\u0026gt; [], \u0026#39;testing\u0026#39; =\u0026gt; [], \u0026#39;staging\u0026#39; =\u0026gt; [], )); .env.*.php 設定檔通常放在根目錄下，這些檔案不會在版本控制當中\napp/ bootstrap/ public/ vendor/ .env.php .env.local.php .env.dev.php .env.testing.php .env.staging.php 在 Laravel 4 .env 設定檔案長的會像是這樣：\n\u0026lt;?php return [ \u0026#39;DB_USERNAME\u0026#39; =\u0026gt; \u0026#39;root\u0026#39;, \u0026#39;DB_PASSWORD\u0026#39; =\u0026gt; \u0026#39;password\u0026#39;, ]; 我們的 config 檔案就可以使用 $_ENV 去讀取當前環境的設定檔資料\n\u0026lt;?php $_ENV[\u0026#39;DB_USERNAME\u0026#39;] $_ENV[\u0026#39;DB_PASSWORD\u0026#39;] Laravel 5 .env 檔案 在 Laravel 5 使用 .env 檔案的方式跟 Laravel 4 有很大的不同，在 Laravel 5 中就只有 .env 與 .env.example 這兩個檔案而已，.env 檔案不會在版本控制中，.env.example 則會在版本控制中\n自己可以根據自己的環境設定目前的 .env 狀況，而 .env.example 則是可以讓大家參考 .env 的範例用的，自己根據自己目前的環境設定是什麼樣到開發還境（local、dev、stage、production\u0026hellip;etc）。\n在 Laravel 5 .env 設定檔案長的會像是這樣：\nAPP_ENV=local APP_DEBUG=true APP_KEY=VDqhX1LiHKEReHH16YNEzxUZziOdZVtT DB_HOST=localhost DB_DATABASE=homestead DB_USERNAME=homestead DB_PASSWORD=secret CACHE_DRIVER=file SESSION_DRIVER=file 然後我們在設定檔中，我們可以使用 env() 函式去取得我們設定檔案中的設定，會設定像是這樣的設定\n// config/app.php [ \u0026#39;debug\u0026#39; =\u0026gt; env(\u0026#39;APP_DEBUG\u0026#39;, false), ] // config/database.php [ \u0026#39;pgsql\u0026#39; =\u0026gt; [ \u0026#39;driver\u0026#39; =\u0026gt; \u0026#39;pgsql\u0026#39;, \u0026#39;host\u0026#39; =\u0026gt; env(\u0026#39;DB_HOST\u0026#39;, \u0026#39;localhost\u0026#39;), \u0026#39;database\u0026#39; =\u0026gt; env(\u0026#39;DB_DATABASE\u0026#39;, \u0026#39;forge\u0026#39;), \u0026#39;username\u0026#39; =\u0026gt; env(\u0026#39;DB_USERNAME\u0026#39;, \u0026#39;forge\u0026#39;), \u0026#39;password\u0026#39; =\u0026gt; env(\u0026#39;DB_PASSWORD\u0026#39;, \u0026#39;\u0026#39;), \u0026#39;charset\u0026#39; =\u0026gt; \u0026#39;utf8\u0026#39;, \u0026#39;prefix\u0026#39; =\u0026gt; \u0026#39;\u0026#39;, \u0026#39;schema\u0026#39; =\u0026gt; \u0026#39;public\u0026#39;, ], ] env() 中第一個參數是 .env 檔案中的設定鍵值名稱，第二個參數是預設值，若讀取不到環境設定鍵值則會使用預設值\n這樣在每個人的開發環境只要去管理自己的 .env 檔案就好，不需要像 Laravel 4 需要在 config 資料夾中建立各種環境變數設定的資料夾，像是 config/local/database.php 或 config/stage/database.php。\n參考資料  Environments and Configuration - Laravel 5 Fundamentals  "
},
{
	"uri": "https://kejyun.github.io/laravel5-book/api/api-intro/",
	"title": "API 介紹",
	"tags": [],
	"description": "",
	"content": "API 介紹 throttle middleware 在 app/Http/Kernel.php 檔案中會看到 api 的 $middlewareGroups 有一個 'throttle:60,1'，這邊的意思是 每 1 分鐘同個 ip 可以請求 60 次，可以針對你的 API 請求需求，去限制 API 請求次數，已保護你的 API 不會被隨意無限制的存取\n\u0026lt;?php namespace App\\Http; use Illuminate\\Foundation\\Http\\Kernel as HttpKernel; class Kernel extends HttpKernel { /** * The application\u0026#39;s route middleware groups. * * @var array */ protected $middlewareGroups = [ \u0026#39;web\u0026#39; =\u0026gt; [ \\App\\Http\\Middleware\\EncryptCookies::class, \\Illuminate\\Cookie\\Middleware\\AddQueuedCookiesToResponse::class, \\Illuminate\\Session\\Middleware\\StartSession::class, // \\Illuminate\\Session\\Middleware\\AuthenticateSession::class,  \\Illuminate\\View\\Middleware\\ShareErrorsFromSession::class, \\App\\Http\\Middleware\\VerifyCsrfToken::class, \\Illuminate\\Routing\\Middleware\\SubstituteBindings::class, ], \u0026#39;api\u0026#39; =\u0026gt; [ \u0026#39;throttle:60,1\u0026#39;, \u0026#39;bindings\u0026#39;, ], ]; } 詳情可以參考 Illuminate\\Routing\\Middleware\\ThrottleRequests 檔案\nLaravel 5.6 throttle middleware 在 Laravel 5.6 的 throttle middleware 提供動態的限制使用者存取數量，在 Middleware 可以設定 throttle:rate_limit,1\nRoute:middleware(\u0026#39;throttle:rate_limit,1\u0026#39;)-\u0026gt;get(\u0026#39;/\u0026#39;, function(){ return \u0026#39;Test Rate Limit\u0026#39;; }); 然後在使用者 Model 加入 public $rate_limit 屬性，限制使用者最多可以存取多少次\n\u0026lt;?php namespace App; use Illuminate\\Notifications\\Notifiable; use Illuminate\\Contracts\\Auth\\MustVerifyEmail; use Illuminate\\Foundation\\Auth\\User as Authenticatable; class User extends Authenticatable { use Notifiable; public $rate_limit = 3; } 這樣登入的使用者就可以按照設定的次數限制去限制請求次數了\n 沒有登入的使用者，將限制只能存取一次\n "
},
{
	"uri": "https://kejyun.github.io/laravel5-book/database/model/eloquent-config/",
	"title": "Eloquent 設定",
	"tags": [],
	"description": "",
	"content": "Eloquent 設定 設定可以大量新增的欄位 Eloquent 為了避免特定欄位（像是 id, created_at \u0026hellip;）被使用者故意傳入大量（Mass）資料去進行修改，所以 Eloquent 會自動保護欄位不被大量異動（Mass Assignment），像是：\n// 新增 App\\User::Create([ \u0026#39;first_name\u0026#39;=\u0026gt; \u0026#39;KeJyun\u0026#39;, \u0026#39;last_name\u0026#39; =\u0026gt; \u0026#39;Hong\u0026#39;, \u0026#39;email\u0026#39; =\u0026gt; \u0026#39;kejyun@gmail.com\u0026#39;, ]); // 更新 $user = App\\User::find(\u0026#39;1\u0026#39;); $user-\u0026gt;update([ \u0026#39;email\u0026#39; =\u0026gt; \u0026#39;hello@gmail.com\u0026#39;, ]); 如果我們需要異動這些欄位，需要在 Model 裡面設定 $fillable 的欄位，這樣就可以使用大量資料的方式，去新增或異動資料表欄位資料。\nclass User extends Model { protected $fillable = [\u0026#39;first_name\u0026#39;, \u0026#39;last_name\u0026#39;, \u0026#39;email\u0026#39;]; } 設定需要被保護的欄位 我們也可以使用 $guarded 指定某些欄位需要被保護，能被大量新增或異動\nclass User extends Model { protected $guarded = [\u0026#39;id\u0026#39;, \u0026#39;password\u0026#39;]; } 我們也可以設定所有欄位都不能被大量新增或異動\nclass User extends Model { protected $guarded = [\u0026#39;*\u0026#39;]; } 設定欄位為時間資料欄位 我們可以很簡單的使用 Carbon 去做時間的資料處理，預設的 created_at 與 updated_at 是使用 Carbon 當作儲存的資料格式\n$article = \\App\\Article::find(1); // created_at = \u0026#39;2014-03-18 23:59:59\u0026#39; // 取得 created_at 年份 // 2014 dd($article-\u0026gt;created_at-\u0026gt;year); // 取得 created_at 月份 // 03 dd($article-\u0026gt;created_at-\u0026gt;month); // 取得 created_at 6 天後的時間 // 2014-03-24 23:59:59 dd($article-\u0026gt;created_at-\u0026gt;addDays(6)); // 取得 created_at 格式化為 Y-m 的時間 // 2014-03 dd($article-\u0026gt;created_at-\u0026gt;format(\u0026#39;Y-m\u0026#39;)); // 取得 created_at 格式化為人可閱讀的時間 // 1 year ago dd($article-\u0026gt;created_at-\u0026gt;diffForHumans()); 若我們自己新增了時間的欄位像是 published_at，則 Model 沒有自動將此欄位的資料設為 Carbon 的資料格式\n我們可以在 Model 中設定 $dates 欄位中的資料，可以指定欄位資料格式為 Carbon 的資料格式\nclass Article extends Model { protected $dates = [\u0026#39;published_at\u0026#39;]; } 設定資料庫的連線 我們也可以使用 $connection 指定模型需要用哪個資料庫連線去做查詢\nclass User extends Model { protected $connection = \u0026#39;custom_connection_name\u0026#39;; } 設定主鍵不要自動新增 使用 Eloquent 去建立模型（Model）時，預設主鍵會使用自動新增（Auto-increment）的方式去新增，若要自行定義主鍵時，則要設定 $incrementing 為 false，將自動新增的功能關閉～\nclass User extends Model { public $incrementing = false; } 設定主鍵欄位名稱 使用 Eloquent 去建立模型（Model）時，預設會將主鍵欄位名稱設為 id，若有需要異動主鍵欄位名稱的話，則要設定 $primaryKey 變數，設為自行定義的欄位名稱\nclass User extends Model { protected $primaryKey = \u0026#39;my_primary_column_name\u0026#39;; } 參考資料  Eloquent 101 - Laracast Dates, Mutators, and Scopes - Laracast Eloquent ORM - Laravel.tw  "
},
{
	"uri": "https://kejyun.github.io/laravel5-book/database/migration/",
	"title": "Migration (遷移)",
	"tags": [],
	"description": "",
	"content": "Migration 這裏會介紹如何在 Laravel 5 使用 Migration 管理資料庫\nMigration 指令 建立 Migration $ php artisan make:migration create_users_table --create=\u0026#34;users\u0026#34; Migration 建立之後的檔案會放在 database/migrations/2015_04_11_134630_create_users_table.php\n Migration 檔案最前面的日期會依照你建立 Migration 的時間自動產生，所以每個人看到的檔名皆會不同 在後面加了 --create 的參數可以告訴 Migration，我們要做建立 user 資料表的動作，檔案內容會像這樣：\n \u0026lt;?php // database/migrations/2015_04_11_134630_create_users_table.php  use Illuminate\\Database\\Schema\\Blueprint; use Illuminate\\Database\\Migrations\\Migration; class CreateUsersTable extends Migration { /** * Run the migrations. * * @return void */ㄒ public function up() { Schema::create(\u0026#39;users\u0026#39;, function(Blueprint $table) { $table-\u0026gt;increments(\u0026#39;id\u0026#39;); $table-\u0026gt;timestamp(); }); } /** * Reverse the migrations. * * @return void */ public function down() { Schema::drop(\u0026#39;users\u0026#39;); } } 異動資料表欄位資料 如果我們要在 users 資料表中加欄位（或是其他改變資料表結構），我們可以用這樣的指令去建立 Migration\n$ php artisan make:migration add_email_to_users_table --table=\u0026#34;users\u0026#34;  在後面加了 --table 的參數可以告訴 Migration，我們要做異動 user 資料表的動作，檔案內容會像這樣：\n \u0026lt;?php // database/migrations/2015_04_12_154720_add_email_to_users_table.php  use Illuminate\\Database\\Schema\\Blueprint; use Illuminate\\Database\\Migrations\\Migration; class AddEmailToUsersTable extends Migration { /** * Run the migrations. * * @return void */ public function up() { Schema::table(\u0026#39;users\u0026#39;, function(Blueprint $table) { $table-\u0026gt;string(\u0026#39;email\u0026#39;, 180); }); } /** * Reverse the migrations. * * @return void */ public function down() { Schema::table(\u0026#39;users\u0026#39;, function(Blueprint $table) { $table-\u0026gt;dropColumn(\u0026#39;email\u0026#39;); }); } }  原先的建立資料表會用 Schema::create()，而異動資料表則會用 Schema::table() 去做異動\n 列出目前所有 Migration 狀態 $ php artisan migrate:status 執行 Migration $ php artisan migrate 恢復上一版本的 Migration $ php artisan migrate:rollback 清除所有版本的 Migration $ php artisan migrate:reset 清除所有版本的 Migration 並重新執行 $ php artisan migrate:refresh 備註 欄位異動 若做欄位異動 Migration 後需要 rollback，若丟出例外錯誤時，則使用 composer 安裝 doctrine/dbal 後即可解決 rollback 的問題\n$ composer require doctrine/dbal 安全性 在剛開始開發產品的時候，有時候資料表有做小小的修改或異動，為了圖方便，我們常常會使用 migrate:reset 或 migrate:refresh 去清空我們的資料，重建資料表。\n但如果產品已經上線了，這個指令就會是一個非常危險的指令，企業產品最重要的資產就是資料，這個指令會導致所有的資料都被清除，所以請上線後小心謹慎去使用。\n參考資料  遷移和資料填充 - Laravel.tw Migrations - Laracasts  "
},
{
	"uri": "https://kejyun.github.io/laravel5-book/design-pattern/service-container/",
	"title": "服務容器（Service Container）",
	"tags": [],
	"description": "",
	"content": "服務容器（Service Container） Laravel 的服務容器就像 IoC 容器一樣，可以讓你很容易的反轉控制物件\n假如我們沒有注入類別去進行反轉控制，則我們每次使用 Mail 類別去寄送郵件時都要去 new 它，如果這個 Mail 類別在裡面是會被很頻繁的使用時，這樣會讓我們很惱人。\n// 通知類別 class Notification { // 通知會員有新訊息 public function noticeNewMessage() { $mail = new Mail(); $mail-\u0026gt;send(); } // 通知會員有新文章 public function noticeNewArticle() { $mail = new Mail(); $mail-\u0026gt;send(); } } 為了能夠讓通知類別 Notification 能夠隨時取用 Mail 類別，我們會希望將此類別直接注入，讓通知類別可以直接去進行反轉控制。\n在我們使用反轉控制（IoC）時，我們時常需要在建構子 __construct() 或方法 function() 中注入需要反轉控制的類別，讓被注入的類別可以直接控制其物件，就像：\n// 通知類別 class Notification { public $mail; public function __construct (Mail $mail) { $this-\u0026gt;mail = $mail; } // 通知會員有新訊息 public function noticeNewMessage() { $this-\u0026gt;mail-\u0026gt;send(); } // 通知會員有新文章 public function noticeNewArticle() { $this-\u0026gt;mail-\u0026gt;send(); } } 我們在通知類別 Notification 建構子中注入 Mail 類別給內部 mail 變數，之後要使用此 Mail 類別時，就直接使用傳送信件 send() 的功能即可。\n我們也可以在個別的函式中分別注入需要反轉控制的類別，就像：\n// 通知類別 class Notification { // 通知會員有新訊息 public function noticeNewMessage(Mail $mail) { $mail-\u0026gt;send(); } // 通知會員有新文章 public function noticeNewArticle(Mail $mail) { $mail-\u0026gt;send(); } } 但是在 Laravel 4 要注入類別之前，必須先對類別名稱對 app 進行綁定，讓 Laravel 4 認得這個要注入的類別是什麼物件\nApp::bind(\u0026#39;Mail\u0026#39;, function($app) { return new SomeEmailService; }); 但是在 Laravel 5 除了可以用這樣手動綁定類別的方式，也有提供強大的自動綁定功能，你不需要在 app 內事先定義所有的類別，當 Laravel 5 在 app 內找不到該類別的時候，就會自動找所有引入（include）的類別中有沒有此類別，自動進行注入綁定！\n參考資料  The Service Container - Laracast 服務容器 - Laravel.tw IoC 容器 Dependency Injection with Laravel’s IoC  "
},
{
	"uri": "https://kejyun.github.io/laravel5-book/environment/",
	"title": "環境",
	"tags": [],
	"description": "",
	"content": "這裏會介紹一些 Laravel 會用到的機器環境相關問題\n"
},
{
	"uri": "https://kejyun.github.io/laravel5-book/database/qa/cannot-get-querylog/",
	"title": "資料庫常見問題：無法取得查詢 Log",
	"tags": [],
	"description": "",
	"content": "資料庫常見問題：無法取得查詢 Log 在 Laravel 4 為了要確定下的 SQL 語法有符合我們預期，我們常常在做完資料庫查詢後，使用 DB::getQueryLog(); 去取得做資料庫查詢的 Qeury Log，但因為 Laravel 會把這些 Log 都記錄在記憶體中，如果做了大量的新增的查詢，記憶體會使用過多可能會造成系統 Crash。\n所以 Laravel 5 預設把記錄 Query Log 的機制關閉，若需要做 Query Debug，需要自行打開 Qeury Log 功能\n\u0026lt;?php // 啟用 Query Log 功能 DB::connection()-\u0026gt;enableQueryLog(); 這樣我們就可以使用 DB::getQueryLog(); 去取得做資料庫查詢的 Qeury Log 摟！！ 要得到執行過的查詢紀錄陣列，你可以使用 getQueryLog 方法：\n\u0026lt;?php // 取得資料庫查詢的 Qeury Log $queries = DB::getQueryLog(); var_dump($queries); 參考資料  資料庫使用基礎 查詢日誌記錄 - Laravel.tw How to get the query executed in Laravel 5 ? DB::getQueryLog returning empty array  "
},
{
	"uri": "https://kejyun.github.io/laravel5-book/http/request/request-cookie/",
	"title": "Cookie",
	"tags": [],
	"description": "",
	"content": "Cookie 這裏會介紹如何在 Laravel 5 驗證 HTTP 請求的資料\n建立新的請求驗證 如果我們有文章（Article）的模型，我們在每次請求過程中想要驗證傳入的資料，我們可以使用系列指令建立要驗證的請求：\n$ php artisan make:request CreateArticleRequest 請求驗證的檔案會被建立在 app\\Http\\Requests 目錄下，建立的檔案內容如下\n\u0026lt;?php namespace App\\Http\\Requests; // app\\Http\\Requests\\CreateArticleRequest.php use App\\Http\\Requests\\Request; class CreateArticleRequest extends Request { /** * Determine if the user is authorized to make this request. * 驗證使用者是否要登入狀態 * * @return bool */ public function authorize() { return true; } /** * Get the validation rules that apply to the request. * 驗證請求的資料規則 * * @return array */ public function rules() { return [ // 使用 | 設定驗證規則  \u0026#39;title\u0026#39; =\u0026gt; \u0026#39;required|min:3\u0026#39;, \u0026#39;body\u0026#39; =\u0026gt; \u0026#39;required|min:30\u0026#39;, // 使用陣列設定驗證規則  \u0026#39;published_at\u0026#39; =\u0026gt; [ \u0026#39;required\u0026#39;, \u0026#39;date\u0026#39;, ], ]; } } 在驗證請求的 CreateArticleRequest 中的 rules() 函式，除了僅回傳驗證規則外，你也可以判斷不同的狀況去加入不同的規則再回傳，像是：\n\u0026lt;?php namespace App\\Http\\Requests; // app\\Http\\Requests\\CreateArticleRequest.php use App\\Http\\Requests\\Request; class CreateArticleRequest extends Request { public function rules() { $rules = [ // 使用 | 設定驗證規則  \u0026#39;title\u0026#39; =\u0026gt; \u0026#39;required|min:3\u0026#39;, \u0026#39;body\u0026#39; =\u0026gt; \u0026#39;required|min:30\u0026#39;, // 使用陣列設定驗證規則  \u0026#39;published_at\u0026#39; =\u0026gt; [ \u0026#39;required\u0026#39;, \u0026#39;date\u0026#39;, ], ]; // 其他條件判斷  if ($condition) { $rules[\u0026#39;something_else\u0026#39;] = \u0026#39;required\u0026#39;; } return $rules; } } 指定 Controller 函式處理指定的請求驗證 在我們使用 Controller 去處理請求時，我們可以再傳入變數內設定要怎麼處理請求：\nclass ArticleController extends Controller { // 新增文章 public function store(App\\Http\\Requests\\CreateArticleRequest $request) { Article::create(Request:all()); // OR // Article::create($request-\u0026gt;all()); return redirect(\u0026#39;articles\u0026#39;); } } 這樣設定之後，所有的 HTTP 請求的 Input 資料都會經過 App\\Http\\Requests\\CreateArticleRequest 驗證，如果有經過驗證才會繼續執行後面的新增文章動作，否則的話則會丟出驗證錯誤的物件到原頁面。\n驗證錯誤訊息 這裏要注意到，視圖（View）的每一頁 Laravel 都會將驗證錯誤物件（Illuminate\\Support\\ViewErrorBag）包成 $errors 變數，所以你可以在每一頁去印出 $errors 值，$errors 變數儲存的是任何資料驗證錯誤的結果\n判斷是否有任何的錯誤並顯示錯誤訊息\n// 任一 blade 視圖（View）皆可以接收此錯誤變數 @if($errors-\u0026gt;any()) // 有錯誤訊息 \u0026lt;ul\u0026gt; $foreach ($errors-\u0026gt;all() as $error) \u0026lt;li\u0026gt;{{ $error }}\u0026lt;/li\u0026gt; @endforeach \u0026lt;/ul\u0026gt; @endif 使用 Controller 內建的 validate 驗證請求的資料 除了建立驗證 Request 物件，也可以直接使用 Controller 內建的 validate 去驗證請求\n如果不想要使用內建處理 HttpResponseException 的例外，你也可以自己 try catch 並自己處理例外狀況\nclass ArticleController extends Controller { // 新增文章 public function store(Requests $request) { try { $this-\u0026gt;validate($request, [ \u0026#39;title\u0026#39; =\u0026gt; \u0026#39;required|min:3\u0026#39;, \u0026#39;body\u0026#39; =\u0026gt; \u0026#39;required|min:30\u0026#39;, \u0026#39;published_at\u0026#39; =\u0026gt; \u0026#39;required|date\u0026#39;, ]); } catch (Exception $e) { // 自己處理例外狀況 } Article::create(Request:all()); // OR // Article::create($request-\u0026gt;all()); return redirect(\u0026#39;articles\u0026#39;); } } 使用者資料 取得 User Agent、Referrer\n\u0026lt;?php // User Agent request()-\u0026gt;server(\u0026#39;HTTP_USER_AGENT\u0026#39;); // Referrer request()-\u0026gt;server(\u0026#39;HTTP_REFERER\u0026#39;) 參考資料  Form Requests and Controller Validation - Laracasts  !INCLUDE \u0026ldquo;../../kejyun/book/laravel-5-for-beginner.md\u0026rdquo;\n"
},
{
	"uri": "https://kejyun.github.io/laravel5-book/services/unit-test/unit-test-ajax-request-json-response/",
	"title": "Ajax Request &amp; JSON Response",
	"tags": [],
	"description": "",
	"content": "Ajax Request \u0026amp; JSON Response 在 Unit test 需要模擬 Ajax 請求時，可以在 $server 參數設定下列設定\n$server = [ 'HTTP_X-Requested-With' =\u0026gt; 'XMLHttpRequest', // Ajax Request 'HTTP_ACCEPT'=\u0026gt; 'application/json', // 請求 JSON Response ]; \u0026lt;?php class ServerTest { public function testAjaxRequestAndJsonResponse() { $uri = \u0026#39;/test/ajax\u0026#39;; $server = [ \u0026#39;HTTP_X-Requested-With\u0026#39; =\u0026gt; \u0026#39;XMLHttpRequest\u0026#39;, // Ajax Request  \u0026#39;HTTP_ACCEPT\u0026#39;=\u0026gt; \u0026#39;application/json\u0026#39;, // 請求 JSON Response  ]; $res = $this-\u0026gt;call(\u0026#39;POST\u0026#39;, $uri, $parameters, $cookies, $files, $server); } } 當設定完 HTTP_X-Requested-With 為 XMLHttpRequest 時，Laravel 會把這個請求視為 Ajax 請求，所以在呼叫 request()-\u0026gt;ajax() 方法時會回傳 true\nrequest()-\u0026gt;ajax(); // true 當設定完 HTTP_ACCEPT 為 application/json 時，Laravel 會把這個請求需要回傳的資訊視為需要 JSON 格式資料，所以在呼叫 request()-\u0026gt;wantsJson() 方法時會回傳 true\nrequest()-\u0026gt;wantsJson(); // true 參考資料  How to simulate xmlHttpRequests in a laravel testcase? - Stack Overflow  "
},
{
	"uri": "https://kejyun.github.io/laravel5-book/services/queue/queue-database/",
	"title": "Database Queue",
	"tags": [],
	"description": "",
	"content": "資料庫隊列（Database Queue） 我們可以使用 database 的隊列設定，在自己的資料庫建立隊列資料表\n產生隊列資料表 我們可以使用 php artisan queue:table 指令去產生隊列的 Migration\n$ php artisan queue:table 所以執行命令後，你可以找到像是 database/migrations/2015_05_26_225627_create_queue_jobs_table.php 這樣的隊列 Migration 檔案\n Migration 檔名日期 2015_05_26_225627 每個人皆不同，會依照你建立當時的時間去產生\n 產生的隊列 Migration 會長的像這樣：\n\u0026lt;?php use Illuminate\\Database\\Schema\\Blueprint; use Illuminate\\Database\\Migrations\\Migration; class CreateQueueJobsTable extends Migration { /** * Run the migrations. * * @return void */ public function up() { Schema::create(\u0026#39;jobs\u0026#39;, function(Blueprint $table) { $table-\u0026gt;bigIncrements(\u0026#39;id\u0026#39;); $table-\u0026gt;string(\u0026#39;queue\u0026#39;); $table-\u0026gt;text(\u0026#39;payload\u0026#39;); $table-\u0026gt;tinyInteger(\u0026#39;attempts\u0026#39;)-\u0026gt;unsigned(); $table-\u0026gt;tinyInteger(\u0026#39;reserved\u0026#39;)-\u0026gt;unsigned(); $table-\u0026gt;unsignedInteger(\u0026#39;reserved_at\u0026#39;)-\u0026gt;nullable(); $table-\u0026gt;unsignedInteger(\u0026#39;available_at\u0026#39;); $table-\u0026gt;unsignedInteger(\u0026#39;created_at\u0026#39;); }); } /** * Reverse the migrations. * * @return void */ public function down() { Schema::drop(\u0026#39;jobs\u0026#39;); } } 建立隊列資料表 執行 php artisan migrate 將隊列資料表新增至資料庫\n設定隊列驅動 在 config/queue.php 檔案中設定資料庫隊列驅動設定，設定如下：\n// config/queue.php return [ \u0026#39;default\u0026#39; =\u0026gt; \u0026#39;database\u0026#39;, \u0026#39;connections\u0026#39; =\u0026gt; [ \u0026#39;database\u0026#39; =\u0026gt; [ \u0026#39;driver\u0026#39; =\u0026gt; \u0026#39;database\u0026#39;, \u0026#39;table\u0026#39; =\u0026gt; \u0026#39;jobs\u0026#39;, \u0026#39;queue\u0026#39; =\u0026gt; \u0026#39;default\u0026#39;, \u0026#39;expire\u0026#39; =\u0026gt; 60, \u0026#39;connection_name\u0026#39;=\u0026gt;\u0026#39;\u0026#39;, ], ], ]; 建立隊列工作 我們可以使用 \\Queue::push('App\\Commands\\SendEmail@fire', $queue_data); 的方法去新增要執行的隊列\n第一個參數是執行隊列需要呼叫的類別名稱位置（App\\Commands\\SendEmail）及方法（fire）\n類別名稱需要正確的指定類別的命名空間（namespace），可以指定這個隊列要執行的類別方法，只要將方法使用 @ 加在後方即可（@customMethod）\n若沒有指定用哪個方法，Laravel 預設會執行 fire 的類別方法（@fire）\n我們使用隊列來寄送 Email，設定隊列的方式大概像這樣：\n// 需要傳送給隊列處理的資料 $queue_data = [ \u0026#39;email\u0026#39; =\u0026gt; \u0026#39;kejyun@gmail.com\u0026#39;, \u0026#39;name\u0026#39; =\u0026gt; \u0026#39;KeJyun\u0026#39;, ]; // 建立隊列 $queue_id = \\Queue::push(\u0026#39;App\\Commands\\SendEmail@fire\u0026#39;, $queue_data); 在 App\\Commands\\Sendmail.php 檔案大概會像這樣：\n\u0026lt;?php namespace App\\Commands; class SendEmail { /** * 執行隊列 * * @return void */ public function fire($job, $data) { // 寄送 Email  \\Mail::send(\u0026#39;emails.welcome\u0026#39;, [], function($message) use ($data) { $message-\u0026gt;to($data[\u0026#39;email\u0026#39;], $data[\u0026#39;name\u0026#39;])-\u0026gt;subject(\u0026#39;歡迎使用 Laravel 5 資料庫隊列寄送 Email!!!\u0026#39;); }); // 執行成功，刪除隊列  $job-\u0026gt;delete(); } } fire 方法中的 $job 變數會接受該隊列的實例，$data 變數會接收建立隊列時傳入的資料\n像我要使用隊列寄送 Email，則會將使用者的相關資訊傳送到這個隊列來，讓隊列能正確的發送正確的 Email 資訊給使用者！\n在隊列執行完成無誤後，我們必須要使用 $job-\u0026gt;delete(); 將隊列資料刪除，若沒有刪除 Laravel 下次再出理到該資料時，則會視為隊列處理失敗，進而嘗試重新處理\n監聽隊列工作 我們會在 shell 中執行 php artisan queue:listen 去持續的監聽隊列資料的狀況，若有新增隊列到資料表時，Laravel 則會開始處理隊列的資料\n$ php artisan queue:listen 也可以針對 queue 去設定相關參數及優先權\n$ php artisan artisan queue:work --queue=instant,high,medium,default,low --delay=1 --memory=512 --sleep=15 --tries=1 --env=dev --daemon 這樣我們就可以正常的使用隊列去幫我們寄信摟！！\n參考資料  隊列 - Laravel.tw Queues in Laravel with Redis  "
},
{
	"uri": "https://kejyun.github.io/laravel5-book/services/laravel-mix/laravel-mix-live-reload/",
	"title": "LiveReload",
	"tags": [],
	"description": "",
	"content": "LiveReload 使用 Live Reload 可以在我們異動 css 的時候，自動幫我們重新在瀏覽器重新刷新頁面，這樣我們在做畫面設計的時候，就可以更快的設計除錯\n 安裝 webpack-livereload-plugin  npm install webpack-livereload-plugin@1 --save-dev 設定 webpack.mix.js  var LiveReloadPlugin = require(\u0026#39;webpack-livereload-plugin\u0026#39;); // LiveReload 設定 mix.webpackConfig({ plugins: [ new LiveReloadPlugin() ] }); // 產生 sass 檔案 mix.sass(\u0026#39;public/assets/scss/app.scss\u0026#39;, \u0026#39;public/assets/css/\u0026#39;); 安裝 Chrome LiveReload 套件  在 LiveReload - Chrome 線上應用程式商店 安裝此套件\n設定 LiveReload 至 blade 樣板  @if(config('app.env') == 'local') \u0026lt;script src=\u0026quot;http://localhost:35729/livereload.js\u0026quot;\u0026gt;\u0026lt;/script\u0026gt; @endif 監控 LiveReload 運作  npm run watch 參考資料  LiveReload | Laravel Mix Documentation LiveReload - Chrome 線上應用程式商店 webpack-livereload-plugin/README.md at master · statianzo/webpack-livereload-plugin  "
},
{
	"uri": "https://kejyun.github.io/laravel5-book/http/route/",
	"title": "Route 路由",
	"tags": [],
	"description": "",
	"content": "這裏會介紹如何在 Laravel 處理 Route 路由。\n"
},
{
	"uri": "https://kejyun.github.io/laravel5-book/services/errors-logs/service/errors-log-service-sentry-io/",
	"title": "Sentry.io",
	"tags": [],
	"description": "",
	"content": "Sentry.io  紀錄 Laravel Exception\n 1.安裝套件\ncomposer require sentry/sentry-laravel 2.加入套件設定\n在 config/app.php 檔案中加入設定\n\u0026lt;?php // config/app.php return [ \u0026#39;providers\u0026#39; =\u0026gt; [ Sentry\\SentryLaravel\\SentryLaravelServiceProvider::class, ], \u0026#39;aliases\u0026#39; =\u0026gt; [ \u0026#39;Sentry\u0026#39; =\u0026gt; Sentry\\SentryLaravel\\SentryFacade::class, ], ] 3.錯誤處理加入 Sentry 設定\n在 config/app.php 檔案中加入設定\n\u0026lt;?php class Handler extends ExceptionHandler { public function report(Exception $e) { if (app()-\u0026gt;bound(\u0026#39;sentry\u0026#39;) \u0026amp;\u0026amp; $this-\u0026gt;shouldReport($e)) { app(\u0026#39;sentry\u0026#39;)-\u0026gt;captureException($e); } return parent::report($e); } } 4.發佈設定\nphp artisan vendor:publish --provider=\u0026#34;Sentry\\SentryLaravel\\SentryLaravelServiceProvider\u0026#34; 5.設定 .env 檔案\nSENTRY_LARAVEL_DSN=https://\u0026lt;SENTRY_DSN_URL\u0026gt; 參考資料  Sentry | Error Tracking Software — JavaScript, Python, PHP, Ruby, more  "
},
{
	"uri": "https://kejyun.github.io/laravel5-book/services/mail/mail-mailgun/",
	"title": "使用 Mailgun 寄信",
	"tags": [],
	"description": "",
	"content": "使用 Mailgun 寄信 Mailgun 對於初期的產品是一個不錯的郵件服務，每個月可以免費寄送 10000 封信，對於初期的應用應該是綽綽有餘，而且 Laravel 5 預設有支援 Mailgun 的服務，所以我們來介紹如何使用 Mailgun 寄信\n設定 config/mail.php  driver 設為 mailgun\n  host 設為 smtp.mailgun.org\n  port 設為 587\n  username 設為 postmaster@mailgun.kejyun.com，這個帳號可以登入後到 Domains 頁選擇你設定的 Domains，找到 Default SMTP Login 就可以看到這個帳號\n  password 設為你自己的密碼，Mailgun 顯次的欄位為 Default Password，密碼長度為 32 碼\n  pretend 設為 true，這樣才可以正常使用 Mailgun 寄送\n 設定完後會像這樣：\n// config/mail.php return [ \u0026#39;driver\u0026#39; =\u0026gt; \u0026#39;mailgun\u0026#39;, \u0026#39;host\u0026#39; =\u0026gt; \u0026#39;smtp.mailgun.org\u0026#39;, \u0026#39;port\u0026#39; =\u0026gt; 587, \u0026#39;from\u0026#39; =\u0026gt; [\u0026#39;address\u0026#39; =\u0026gt; \u0026#39;kejyun@example.com\u0026#39;, \u0026#39;name\u0026#39; =\u0026gt; \u0026#39;KeJyun\u0026#39;], \u0026#39;encryption\u0026#39; =\u0026gt; \u0026#39;tls\u0026#39;, \u0026#39;username\u0026#39; =\u0026gt;\u0026#39;postmaster@mailgun.kejyun.com\u0026#39;, \u0026#39;password\u0026#39; =\u0026gt; \u0026#39;abcdefghijklmnopqrstuvwxyz123456\u0026#39;, \u0026#39;sendmail\u0026#39; =\u0026gt; \u0026#39;/usr/sbin/sendmail -bs\u0026#39;, \u0026#39;pretend\u0026#39; =\u0026gt; false, ]; 設定 config/services.php  domain 設定為你自己定義的 domain，若沒有自己定義 domain 的話，可以使用 Mailgun 替你產生的 domain，可以看看 Default SMTP Login 後面的 sandboxXXXXXX.mailgun.org，這個為 Mailgun 產生的 domain\n  secret 設為 Mailgun 提供的 API Key，會長的像 key-abcdefghijklmnopqrstuvwxyz123456\n 設定完後會像這樣：\n// config/services.php [ \u0026#39;mailgun\u0026#39; =\u0026gt; [ \u0026#39;domain\u0026#39; =\u0026gt; \u0026#39;mailgun.kejyun.com\u0026#39;, \u0026#39;secret\u0026#39; =\u0026gt; \u0026#39;key-abcdefghijklmnopqrstuvwxyz123456\u0026#39;, ], ] 測試使用 Mailgun 寄信 Mail::raw(\u0026#39;測試使用 Laravel 5 的 Mailgun 寄信服務\u0026#39;, function($message) { $message-\u0026gt;to(\u0026#39;kejyun@example.com\u0026#39;); }); 這樣我們就可以使用 Mailgun 去當作我們的郵件寄送服務了！！！\n參考資料  Mailgun Setting up Mailgun with Laravel 5 郵件 - Laravel.tw  "
},
{
	"uri": "https://kejyun.github.io/laravel5-book/view/view-inject-class/",
	"title": "將 Class 綁定到視圖",
	"tags": [],
	"description": "",
	"content": "將 Class 綁定到視圖 \u0026lt;?php namespace App; class Shop { // 顯示商店名稱  public function name() { return \u0026#39;KJ Shop\u0026#39;; } } View Composer View::composer(\u0026#39;shop\u0026#39;, function($view){ $view-\u0026gt;with(\u0026#39;shop\u0026#39;, app(\\App\\Shop::class)); }); Blade Inject @inject(\u0026#39;shop\u0026#39;, \\App\\Shop::class) \u0026lt;h1\u0026gt;{{ $shop-\u0026gt;name() }}\u0026lt;/h1\u0026gt; "
},
{
	"uri": "https://kejyun.github.io/laravel5-book/services/errors-logs/errors-log-level/",
	"title": "日誌記錄層級",
	"tags": [],
	"description": "",
	"content": "日誌記錄層級 在系統發生例外錯誤時，我們會希望紀錄當時的例外訊息，以便之後我我們好進行除錯，而 Log 紀錄的訊息會依照日期被放到像 storage/logs/laravel-2015-06-06.log 的地方\nLog 記錄在 Laravel 有七個級別：debug、info、notice、warning、error、critical 和 alert，紀錄的方式會像這樣：\nLog::debug(\u0026#39;=== Log 訊息 ===\u0026#39;); Log::info(\u0026#39;=== Log 訊息 ===\u0026#39;); Log::notice(\u0026#39;=== Log 訊息 ===\u0026#39;); Log::warning(\u0026#39;=== Log 訊息 ===\u0026#39;); Log::error(\u0026#39;=== Log 訊息 ===\u0026#39;); Log::critical(\u0026#39;=== Log 訊息 ===\u0026#39;); Log::alert(\u0026#39;=== Log 訊息 ===\u0026#39;); 他們在 Log 檔紀錄的樣子會像:\n[2015-06-06 16:22:00] testing.DEBUG: === Log 訊息 === [2015-06-06 16:22:00] testing.INFO: === Log 訊息 === [2015-06-06 16:22:00] testing.NOTICE: === Log 訊息 === [2015-06-06 16:22:00] testing.WARNING: === Log 訊息 === [2015-06-06 16:22:00] testing.ERROR: === Log 訊息 === [2015-06-06 16:22:00] testing.CRITICAL: === Log 訊息 === [2015-06-06 16:22:00] testing.ALERT: === Log 訊息 === 我們透過不同的記錄層級，讓我們容易找到層級比較嚴重的 Bug 先進行修復\n參考資料  錯誤與日誌 - Laravel.tw  "
},
{
	"uri": "https://kejyun.github.io/laravel5-book/services/auth/auth-support-laravel-4/",
	"title": "認證支援 Laravel 4 Session",
	"tags": [],
	"description": "",
	"content": "Laravel 5 認證支援 Laravel 4 Session Step1. Laravel 4 加密方式支援 AES Laravel 4 因為加密方式支援 rijndael-128，不支援 AES，所以無法使用 php 7.1 執行 Laravel 4 專案，在 Laravel 4 中的 app/config/app.php 檔案可以看到金鑰及加密方式的設定：\n\u0026lt;?php // Laravel 4 // app/config/app.php return [ \u0026#39;key\u0026#39; =\u0026gt; \u0026#39;randomStringLength32xxxxxxxxxxxx\u0026#39; \u0026#39;cipher\u0026#39; =\u0026gt; MCRYPT_RIJNDAEL_128, ]; Laravel 4 安裝 tomgrohl/laravel4-php71-encrypter 套件支援 AES 加密\ncomposer require tomgrohl/laravel4-php71-encrypter 修改 Nginx 設定使用 PHP 7.1\nserver { root \u0026quot;/home/kejyun/web/laravel-4-project/public\u0026quot;; location ~ [^/]\\.php(/|$) { fastcgi_pass unix:/run/php/php7.1-fpm.sock; } } 修改 Laravel 4 加密方式支援 AES-256\nAES-256 金鑰需要長度 32 的字串，AES-128 需要長度 16 的字串，我們支援 AES-256 所以需要將金鑰長度設定為 32\n\u0026lt;?php // Laravel 4 // app/config/app.php return [ \u0026#39;key\u0026#39; =\u0026gt; \u0026#39;randomStringLength32xxxxxxxxxxxx\u0026#39; \u0026#39;cipher\u0026#39; =\u0026gt; \u0026#39;AES-256-CBC\u0026#39;, ]; Step2. 修改 Laravel 5 金鑰格式 在使用 php artisan key:generate 產生 APP_KEY 時會產生 base64 的金鑰，但這樣格式的金鑰在 Laravel 4 是不支援的\n# .env APP_KEY=base64:z+ldCPR/vzxMBzZ6k+mptblu82qbeSM+kK5ZVKOUdFg= 所以需要將 Laravel 4 的金鑰直接貼到 .env 檔案，不要經過 base64 的加密\n# .env APP_KEY=randomStringLength32xxxxxxxxxxxx Step3. 修改 Laravel 5 Cookie 加密方式 由於 Laravel 4 會將 Cookie 的資料經過 serialize，但 Laravel 5 不會將 Cookie serialize，所以為了讓 Laravel 5 可以正常讀取 Laravel 4 的 Cookie，需要將 Laravel 5 serialize 的功能打開。\n在 app/Http/Middleware/EncryptCookies.php 檔案中可以設定靜態變數 $serialize 為 true 即可。\n\u0026lt;?php // app/Http/Middleware/EncryptCookies.php namespace App\\Http\\Middleware; use Illuminate\\Cookie\\Middleware\\EncryptCookies as Middleware; class EncryptCookies extends Middleware { protected static $serialize = true; } Step4. 修改 Laravel 5 Auth 驗證方式 Laravel 4的驗證 Auth 方法與 Laravel 5 有些許不同，主要是在取得 session 名稱 的方法有點不同，在 Laravel 4 的 vendor/laravel/framework/src/Illuminate/Auth/Guard.php 可以看到 getName() 與 getRecallerName() 函式與 Laravel 5 不同\nLaravel 4 Guard\n vendor/laravel/framework/src/Illuminate/Auth/Guard.php\n \u0026lt;?php namespace Illuminate\\Auth; // Laravel 4 // vendor/laravel/framework/src/Illuminate/Auth/Guard.php  use Illuminate\\Cookie\\CookieJar; use Illuminate\\Events\\Dispatcher; use Symfony\\Component\\HttpFoundation\\Request; use Illuminate\\Session\\Store as SessionStore; use Symfony\\Component\\HttpFoundation\\Response; class Guard { /** * Get a unique identifier for the auth session value. * * @return string */ public function getName() { return \u0026#39;login_\u0026#39;.md5(get_class($this)); } /** * Get the name of the cookie used to store the \u0026#34;recaller\u0026#34;. * * @return string */ public function getRecallerName() { return \u0026#39;remember_\u0026#39;.md5(get_class($this)); } } Laravel 5 Session Guard\n vendor/laravel/framework/src/Illuminate/Auth/SessionGuard.php\n \u0026lt;?php // Laravel 5 // vendor/laravel/framework/src/Illuminate/Auth/SessionGuard.php  namespace Illuminate\\Auth; class SessionGuard implements StatefulGuard, SupportsBasicAuth { /** * Get a unique identifier for the auth session value. * * @return string */ public function getName() { return \u0026#39;login_\u0026#39;.$this-\u0026gt;name.\u0026#39;_\u0026#39;.sha1(static::class); } /** * Get the name of the cookie used to store the \u0026#34;recaller\u0026#34;. * * @return string */ public function getRecallerName() { return \u0026#39;remember_\u0026#39;.$this-\u0026gt;name.\u0026#39;_\u0026#39;.sha1(static::class); } } 為了讓 Laravel 5 支援 Laravel 4 的 Session，則必須要將取得 Session 名稱 方法修改為 Laravel 4 的方式\nLaravel 5 目錄建立 app/Auth/Laravel4SessionGuard.php 檔案，繼承原本 Illuminate\\Auth\\SessionGuard 的方法，並加入 getName() 及 getRecallerName() 方法修改為 Laravel 4 的方法\n\u0026lt;?php namespace App\\Auth; use Auth; use Illuminate\\Auth\\SessionGuard; use Illuminate\\Contracts\\Auth\\Guard; class Laravel4SessionGuard extends SessionGuard implements Guard { protected $laravel4_guard_class_name = \u0026#39;Illuminate\\Auth\\Guard\u0026#39;; /** * Get a unique identifier for the auth session value. * * @return string */ public function getName() { return \u0026#39;login_\u0026#39;.md5($this-\u0026gt;laravel4_guard_class_name); } /** * Get the name of the cookie used to store the \u0026#34;recaller\u0026#34;. * * @return string */ public function getRecallerName() { return \u0026#39;remember_\u0026#39;.md5($this-\u0026gt;laravel4_guard_class_name); } /** * Extend Auth for Laravel 4 */ public static function AuthExtend() { // vendor/laravel/framework/src/Illuminate/Auth/AuthManager.php  // - createSessionDriver  Auth::extend(\u0026#39;laravel4Session\u0026#39;, function ($app, $name, array $config) { $provider = Auth::createUserProvider($config[\u0026#39;provider\u0026#39;]); $guard = new Laravel4SessionGuard($name, $provider, $app[\u0026#39;session.store\u0026#39;]); // When using the remember me functionality of the authentication services we  // will need to be set the encryption instance of the guard, which allows  // secure, encrypted cookie values to get generated for those cookies.  if (method_exists($guard, \u0026#39;setCookieJar\u0026#39;)) { $guard-\u0026gt;setCookieJar($app[\u0026#39;cookie\u0026#39;]); } if (method_exists($guard, \u0026#39;setDispatcher\u0026#39;)) { $guard-\u0026gt;setDispatcher($app[\u0026#39;events\u0026#39;]); } if (method_exists($guard, \u0026#39;setRequest\u0026#39;)) { $guard-\u0026gt;setRequest($app-\u0026gt;refresh(\u0026#39;request\u0026#39;, $guard, \u0026#39;setRequest\u0026#39;)); } return $guard; }); } } 修改 config/auth.php 設定檔案\n\u0026lt;?php return [ \u0026#39;defaults\u0026#39; =\u0026gt; [ // \u0026#39;guard\u0026#39; =\u0026gt; \u0026#39;web\u0026#39;,  \u0026#39;guard\u0026#39; =\u0026gt; \u0026#39;laravel4_web\u0026#39;, \u0026#39;passwords\u0026#39; =\u0026gt; \u0026#39;users\u0026#39;, ], \u0026#39;guards\u0026#39; =\u0026gt; [ \u0026#39;laravel4_web\u0026#39; =\u0026gt; [ \u0026#39;driver\u0026#39; =\u0026gt; \u0026#39;laravel4Session\u0026#39;, \u0026#39;provider\u0026#39; =\u0026gt; \u0026#39;users\u0026#39;, ], ], ]; Laravel 5 使用自訂驗證方法\n在 Laravel 5 中的 app/Providers/AuthServiceProvider.php 檔案中呼叫 Laravel4SessionGuard::AuthExtend(); 方法，之後即可讀取到 Laravel 4 產生的 Session 驗證資料\n\u0026lt;?php // Laravel 5 // app/Providers/AuthServiceProvider.php  namespace App\\Providers; use App\\Auth\\Laravel4SessionGuard; use Illuminate\\Support\\Facades\\Gate; use Illuminate\\Foundation\\Support\\Providers\\AuthServiceProvider as ServiceProvider; class AuthServiceProvider extends ServiceProvider { /** * Register any authentication / authorization services. * * @return void */ public function boot() { $this-\u0026gt;registerPolicies(); // 設定 Laravel 4 Auth  Laravel4SessionGuard::AuthExtend(); } } 參考資料  tomgrohl/laravel4-php71-encrypter: Laravel 4.2 Encrypter for PHP 7.1+ The only supported ciphers are AES-128-CBC and AES-256-CBC · Issue #9080 · laravel/framework Laravel 5.6.30 breaks passport · Issue #795 · laravel/passport Authentication - Laravel - The PHP Framework For Web Artisans How to Create a Custom Authentication Guard in Laravel  "
},
{
	"uri": "https://kejyun.github.io/laravel5-book/services/helpers/request-helpers/",
	"title": "請求資訊",
	"tags": [],
	"description": "",
	"content": "請求資訊輔助方法 取得目前網域 // www.kejyun.com $domain_host = request()-\u0026gt;getHttpHost(); "
},
{
	"uri": "https://kejyun.github.io/laravel5-book/services/mail/",
	"title": "郵件（Mail）",
	"tags": [],
	"description": "",
	"content": "這裏介紹一些 Laravel 提供的一些郵件（Mail）功能\n"
},
{
	"uri": "https://kejyun.github.io/laravel5-book/structure/combination-cache-manager-structure-principle/",
	"title": "Combination &amp; Cache 架構設計準則（2019 年版本）",
	"tags": [],
	"description": "",
	"content": "Combination \u0026amp; Cache 架構設計準則（2019 年版本） 傳統的 MVC（Model, View, Controller） 框架，當 Controller 收到請求之後，我們會在 Controller 內直接透過 Model 去撈取資料庫的資料，並在 Controller 做資料驗證、資料整合、快取、商業邏輯判斷\u0026hellip;等等的工作。\n當系統越來越大，會發現很多類似的商業邏輯的程式都散在各地，沒有辦法重複再利用，當程式需要異動或修改的時候，就要去搜尋所有程式碼，把許多相同商業邏輯的程式碼去做異動，但需要修改的地方若太多，往往會東漏西漏，導致系統出現錯誤，並造成往後開發的時間成本增加。\n所以我們會想要做到 減少重複的程式碼、提高維護開發的效率，所以將程式碼依照分類及分層抽出獨立控管，讓不同類型的程式專心處理自己相關的商業邏輯，讓開發維護更容易。\n隨著程式架構的演進會發展出更多不同的架構，所以這個設計架構準則也是會隨著時間做演進的。\n資料處理邏輯分層 架構圖 架構說明 A. 資料控制結構 * Controller (控制器：控制資料流程) * ServiceManager (服務整合管理：組合管理不同 Service 的商業邏輯) * Service (服務：處理商業邏輯) * Repository (資源庫：資料表資料撈取邏輯) * Model (資料庫模型：資料表設定) * Presenter (資料呈現：資料表資料格式呈現轉換) * Combination（資料整合：整理 Repository 資料成資訊） * CombinationManager（複合資料整合管理：整理多個 Service 的資料成資訊） * Checker (檢查器：根據 Controller 所需商業邏輯，驗證不同資料表欄位資料) * Validator (驗證器：資料表欄位資料驗證)    結構名稱 說明     Controller (控制器) 控制資料流程，控制要使用哪些 Service 或 ServiceManager 的商業邏輯，去組合出使用者請求需要的資料，並做資料的資料交易控制 (transaction) ，並使用 Checker 去檢查任何使用者傳進來的資料，確保資料的正確性   ServiceManager (服務整合管理) 協助 Controller 組合不同 Service 的資料成商業邏輯   Service (服務) 處理商業邏輯，組合不同的 Repository 資料成商業邏輯，提供 Controller 或 ServiceManager 存取   Repository (資源庫) 資料表資料撈取邏輯，撈取屬於自己 Model 不同條件下的資料，提供 Service 存取   Model (資料庫模型) 資料庫模型，資料表存取相關設定   Presenter (資料呈現) 資料呈現，協助 Model 做資料呈現轉換   Checker (檢查器) 協助 Controller 做資料驗證，在資料進入到程式邏輯前，都需要經過 Checker 將資料格式做驗證   Validator (驗證器) 協助 Checker 做資料驗證，Validator 只能驗證單一 Model 資料   CombinationManager (複合資料整合管理) 協助整理不同 Service 的複合式資料，若有資料的邏輯判斷需要不同的資料來源，則由 CombinationManager 負責整合處理   Combination （資料整合） 協助整理 Repository 資料成資訊    B.獨立結構 * CacheManager (快取：管理資源快取鍵值及清除快取) * Constant (常數：定義資料狀態名稱) * Support (支援：協助處理獨立邏輯資料處理) * ExceptionCode (例外代碼：例外錯誤代碼定義)    結構名稱 說明     CacheManager (快取) 協助專案資料做快取資料的控制，可以在任何程式邏輯複雜的地方做快取存取控制，並統一清除快取   Constant (常數) 定義並命名所有資料狀態，確保資料值做異動時，不會影響程式邏輯   Support (支援) 協助處理獨立程式邏輯，邏輯沒有被其他任何的函式綁定，可以獨立完成   ExceptionCode (例外代碼) 定義例外代碼，可以統一管控當例外發生錯誤時，回傳的錯誤代碼    架構存取限制  不能跨 2 階層以上存取  Controller 不能存取 Repository Controller 不能存取 Validator Service 不能存取 Model   低階層的不能存取高階層的資料  Model 不能存取 Repository Repository 不能存取 Service Validator 不能存取 Checker   同一個資料類型，不能互相呼叫  避免同一類型類別呼叫，造成 new 物件的時候有無窮迴圈  PostService 存取 UserService，UserService 存取 PostsService 造成無窮迴圈   ServiceManager 不能呼叫 ServiceManager Service 不能呼叫 Service Checker 不能呼叫 Checker Validator 不能呼叫 Validator Repository 不能呼叫 Repository CacheManager 不能呼叫 CacheManager   獨立結構可以在任何一階層去呼叫  架構設計邏輯範例說明 A. 資料控制結構 Controller (控制器)    項目 說明     用途 控制資料流程   可以存取結構 Checker、ServiceManager、Service、DB transaction，所有獨立結構   可以被存取結構 無    處理 HTTP 請求的入口，依照需求呼叫 ServiceManager 或 Service 去做資料的存取，大部分情況呼叫 Service 去組合需要的資料就好，若相同的組合邏輯在不同的 Controller 都有用到，那就使用 ServiceManager 去組合不同的 Service\n要確保所有 Service 商業邏輯都正確跑完才允許對資料做異動，並避免 Transaction 在 Controller 及 Service 被重複呼叫，導致無法正確鎖定資料狀態，所以使用 Controller 當作資料交易（Transaction）的控制點\n\u0026lt;?php class PostController extends Controller { public function __construct( PostServiceManager $PostServiceManager, PostService $PostService, CommentService $CommentService, PostChecker $PostChecker ) { $this-\u0026gt;PostServiceManager = $PostServiceManager; $this-\u0026gt;PostService = $PostService; $this-\u0026gt;CommentService = $CommentService; $this-\u0026gt;PostChecker = $PostChecker; } // 顯示文章  public function show($post_id) { try { // 驗證資料  $input = [ \u0026#39;post_id\u0026#39; =\u0026gt; $post_id ]; $this-\u0026gt;PostChecker-\u0026gt;checkShow($input); // 撈取文章  $Post = $this-\u0026gt;PostServiceManager-\u0026gt;findPost($post_id); // 撈取文章留言  $Comment = $this-\u0026gt;CommentService-\u0026gt;getCommentByPostId(post_id); } catch (Exception $exception) { throw $exception } } // 更新文章  public function update($post_id) { try { // 驗證資料  $input = request()-\u0026gt;all(); $input[\u0026#39;post_id\u0026#39;] = $post_id; $this-\u0026gt;PostChecker-\u0026gt;checkUpdate($input); // 交易開始  DB::beginTransaction(); // 更新文章  $Post = $this-\u0026gt;PostService-\u0026gt;update($post_id, $input); // 交易結束  DB::commit(); } catch (Exception $exception) { // 交易失敗  DB::rollBack(); throw $exception } } } ServiceManager (服務整合管理)    項目 說明     用途 組合管理不同 Service 的商業邏輯   可以存取結構 Service、所有獨立結構   可以被存取結構 Controller    使用不同 Service 撈取資料，將不同資料組合成商業邏輯，供 Controller 做存取\n\u0026lt;?php class PostServiceManager { public function __construct( PostService $PostService, UserService $UserService ) { $this-\u0026gt;PostService = $PostService; $this-\u0026gt;UserService = $UserService; } // 撈取文章資料  public function findPost($post_id){ try { // 撈取文章  $Post = $this-\u0026gt;PostService-\u0026gt;findPost($post_id); // 撈取文章作者資料  $user_id = $Post-\u0026gt;user_id; $Post-\u0026gt;user = $this-\u0026gt;UserService-\u0026gt;findUser($user_id); return $Post; } catch (Exception $exception) { throw $exception } } } Service (服務)    項目 說明     用途 處理商業邏輯   可以存取結構 Repository、所有獨立結構   可以被存取結構 Controller、ServiceManager    使用不同的 Repository 撈取資料，將不同資料組合成商業邏輯\n\u0026lt;?php class PostService { public function __construct( PostRepository $PostRepository, PostTagRepository $PostTagRepository ) { $this-\u0026gt;PostRepository = $PostRepository; $this-\u0026gt;PostTagRepository = $PostTagRepository; } // 撈取文章  public function findPost($post_id) { try { // 撈取文章  $Post = $this-\u0026gt;PostRepository-\u0026gt;find($post_id); // 撈取文章標籤  $Tag = $this-\u0026gt;PostTagRepository-\u0026gt;getByPostId($post_id); return [$Post, $Tag]; } catch (Exception $exception) { throw $exception } } } Repository (資源庫)    項目 說明     用途 資料表資料撈取邏輯   可以存取結構 Model、所有獨立結構   可以被存取結構 Service    撈取特定 Model 資料，像 PostRepository 可以存取 Post Model (模型) 的 基本資料，並使用不同條件撈取 Model 的資料，供 Service 做存取\n也可以使用 PostRecommendRepository 存取 Post Model (模型) 的 推薦資料\n同一個 Model (模型) 可以用不同的 Repository 去呼叫，但同一 Repository 只能有一個 Model (模型)\n\u0026lt;?php class PostRepository { public function __construct( Post $Post ) { $this-\u0026gt;Post = $Post; } public function find($post_id) { try { // 撈取資料庫文章資料  $Post = $this-\u0026gt;Post-\u0026gt;find($post_id); return $Post; } catch (Exception $exception) { throw $exception } } public function findLatestPost() { try { // 撈取資料庫文章資料  $Post = $this-\u0026gt;Post -\u0026gt;order(\u0026#39;created_at\u0026#39;, \u0026#39;desc\u0026#39;) -\u0026gt;first(); return $Post; } catch (Exception $exception) { throw $exception } } } Model (資料庫模型)    項目 說明     用途 資料表設定   可以存取結構 所有獨立結構   可以被存取結構 Repository    Eloquent 存取資料表相關設定，使用 Eloquent 直接存取資料表資料\n\u0026lt;?php class Post extends Model { protected $table = \u0026#39;post\u0026#39;; protected $fillable = []; protected $primaryKey = \u0026#39;id\u0026#39;; protected $dates = [\u0026#39;created_at\u0026#39;, \u0026#39;updated_at\u0026#39;]; protected $presenter = PostPresenter::class; } Presenter (資料呈現)    項目 說明     用途 資料表資料格式呈現轉換   可以存取結構 所有獨立結構   可以被存取結構 Model    提供 Model 的資料用其他方式呈現\n\u0026lt;?php class PostPresenter extends Presenter { public function created_at_human_time() { return $this-\u0026gt;created_at-\u0026gt;diffForHumans(); } } Checker (檢查器)    項目 說明     用途 根據 Controller 所需商業邏輯，驗證不同資料表欄位資料   可以存取結構 Validator、所有獨立結構   可以被存取結構 Controller    協助 Controller 驗證不同資料表資料的正確性，若驗證錯誤則丟處例外，Controller 根據例外代碼去做處理\n\u0026lt;?php class PostValidator { public function checkFindPost($input){ // 驗證文章資料  $this-\u0026gt;PostValidator-\u0026gt;validatePostId($input); $this-\u0026gt;PostValidator-\u0026gt;validatePostContent($input); // 驗證會員資料  $this-\u0026gt;MemberValidator-\u0026gt;validateMemberId($input); } } Validator (驗證器)    項目 說明     用途 資料表欄位資料驗證   可以存取結構 所有獨立結構   可以被存取結構 Checker    協助 Checker 驗證資料的正確性，若驗證錯誤則丟處例外，Checker 根據例外代碼去做處理\n\u0026lt;?php class PostValidator { public function validatePostId($input){ // 設定驗證規則  $rules = [ \u0026#39;post_id\u0026#39; =\u0026gt; [ \u0026#39;required\u0026#39;, \u0026#39;max:20\u0026#39;, ], ]; // 開始驗證  $this-\u0026gt;validator = Validator::make($input, $rules); if ($this-\u0026gt;validator-\u0026gt;fails()) { throw new Exception( \u0026#39;文章編號格式錯誤\u0026#39;, PostExceptionCode::POST_ID_FORMAT_ERROR ); } } } Combination（資料整合）    項目 說明     用途 整理 Repository 資料成資訊   可以存取結構 所有獨立結構   可以被存取結構 Serivce、CombinationManager    當 Service 從 Repository 取得資料後，協助整理判斷 Repository 資料的屬性狀態，像是可以從 文章編號 取得 文章網址\n\u0026lt;?php class PostsCombination { // 設定整合資訊  public function setCombinationInfo(\u0026amp;$Posts) { if (!($Posts instanceof Posts)) { return false; } // 文章網址  $url = url(\u0026#34;article/{$Posts-\u0026gt;id}\u0026#34;) $Posts-\u0026gt;info-\u0026gt;url = $url; } } CombinationManager（複合資料整合管理）    項目 說明     用途 整理多個 Service 的資料成資訊   可以存取結構 Combination、Serivce、所有獨立結構   可以被存取結構 ServiceManager、Controller    當整合的資料需要經過不同的資料來源去判斷要產生什麼複合資訊，CombinationManager 協助整理不同來源的資料去做資料整合，目前會從 ServiceManager 去取得不同 Service 的資訊，所以將 CombinationManager 放在這一階層去進行呼叫\n\u0026lt;?php class PostsCombinationManager { protected $UserService; public function __construct( UserCombination $UserCombination, ProjectService $ProjectService ) { // 服務  $this-\u0026gt;UserCombination = $UserCombination; } public function setCombinationInfo(\u0026amp;$combination_data) { $Posts = array_get($combination_data, \u0026#39;Posts\u0026#39;); if ($Posts instanceof Posts) { // 設定文章關聯作者資訊  $this-\u0026gt;UserCombination-\u0026gt;setCombinationInfo($Posts-\u0026gt;User); // 是專題文章  if ($Posts-\u0026gt;type == PostsConstant::TYPE_PROJECT) { $Project = $this-\u0026gt;ProjectService-\u0026gt;findProjectByPostId($Posts-\u0026gt;id); $url = url(\u0026#34;project/{$Project-\u0026gt;slug}/{$Posts-\u0026gt;id}\u0026#34;) $Posts-\u0026gt;info-\u0026gt;url = $url; }; } } } B.獨立結構 CacheManager (快取)    項目 說明     用途 管理資源快取鍵值及清除快取   可以存取結構 x   可以被存取結構 無限制    在 複雜 的資料庫查詢（Repository）或是商業邏輯（Service、ServiceManager），想要在一定時間內不要再重複的進行複雜的運算，可以透過快取將運算的結果快取起來\nPostsCacheManager 文章資源庫\nclass PostRepository { public function __construct( Post $Post, PostsCacheManager $PostsCacheManager ) { $this-\u0026gt;Post = $Post; $this-\u0026gt;PostsCacheManager = $PostsCacheManager; } public function find($post_id) { try { $cache_key = $this-\u0026gt;PostsCacheManager-\u0026gt;getPostIdCacheKey($post_id); $Posts = $this-\u0026gt;PostsCacheManager-\u0026gt;getCache($cache_key); if (!is_null($Posts)) { return $Posts; } // 撈取資料庫文章資料 $Posts = $this-\u0026gt;Post-\u0026gt;find($post_id); if (!is_null($Posts)) { // 有該資料，將資料存入快取 $this-\u0026gt;PostsCacheManager-\u0026gt;putCache($Posts, $cache_key); } return $Posts; } catch (Exception $exception) { throw $exception } } public function findLatestPost() { try { // 撈取資料庫文章資料 $Post = $this-\u0026gt;Post -\u0026gt;order(\u0026#39;created_at\u0026#39;, \u0026#39;desc\u0026#39;) -\u0026gt;first(); return $Post; } catch (Exception $exception) { throw $exception } } } PostsCacheManager 文章快取\nclass PostsCacheManager { protected $cache_key = [ // 文章快取 \u0026#39;post_id\u0026#39; =\u0026gt; \u0026#39;[PostById][post_id:{post_id}]\u0026#39;, // 已發布文章快取 \u0026#39;published_post_id\u0026#39; =\u0026gt; \u0026#39;[PublishedPostById][post_id:{post_id}]\u0026#39;, ]; /** * 文章快取 */ public function getPostIdCacheKey($post_id) { $search = [ \u0026#39;{post_id}\u0026#39;, ]; $replace = [ $post_id, ]; $cache_key = str_replace($search, $replace, $this-\u0026gt;cache_key[\u0026#39;post_id\u0026#39;]); return $cache_key; } /** * 已發布文章快取 */ public function getPublishedPostIdCacheKey($post_id) { $search = [ \u0026#39;{post_id}\u0026#39;, ]; $replace = [ $post_id, ]; $cache_key = str_replace($search, $replace, $this-\u0026gt;cache_key[\u0026#39;published_post_id\u0026#39;]); return $cache_key; } /** * 文章快取 */ public function getPostIdCacheKey($post_id) { $search = [ \u0026#39;{post_id}\u0026#39;, ]; $replace = [ $post_id, ]; $cache_key = str_replace($search, $replace, $this-\u0026gt;cache_key[\u0026#39;post_id\u0026#39;]); return $cache_key; } /** * 清除文章快取 */ public function forgetPostsCache($cache_data) { $Posts = array_get($cache_data, \u0026#39;Posts\u0026#39;); if (!is_null($Posts) AND ($Posts instanceof Posts)) { $cache_key = $this-\u0026gt;getPostIdCacheKey($post_id); $is_cache_forget = $Cache::forget($cache_key); $cache_key = $this-\u0026gt;getPublishedPostIdCacheKey($post_id); $is_cache_forget = $Cache::forget($cache_key); // .... 清除文章其他快取 } } } Constant (常數)    項目 說明     用途 定義資料狀態名稱   可以存取結構 x   可以被存取結構 無限制    資料皆為靜態變數，可以供所有資料層級 (e.g. Controller、Service、Repository) 做存取\n\u0026lt;?php class PostConstant { const POST_TYPE_PUBLIC = \u0026#39;P\u0026#39;; const POST_TYPE_DELETE = \u0026#39;D\u0026#39;; } Support (支援)    項目 說明     用途 協助處理獨立邏輯資料處理   可以存取結構 x   可以被存取結構 無限制    方法皆為靜態變數，可以供所有資料層級 (e.g. Controller、Service、Repository) 做存取\n若有其他可供全域共用的方法皆寫在 Support 靜態方法供大家存取\n\u0026lt;?php class PostSupport { // 撈取所有文章類型  public static function getAllPostType() { $all_post_type = [ PostConstant::POST_TYPE_PUBLIC, PostConstant::POST_TYPE_DELETE, ]; return $all_post_type; } } ExceptionCode (例外代碼)    項目 說明     用途 例外錯誤代碼定義   可以存取結構 x   可以被存取結構 x    資料皆為靜態變數，可以供所有資料層級 (e.g. Controller、Service、Repository) 做存取\n\u0026lt;?php class PostExceptionCode { const POST_ID_FORMAT_ERROR = 10000001; const POST_NOT_FOUND = 10000002; const POST_TAG_NOT_FOUND = 10000003; } View (視圖) 使用限制 View 的職責是負責顯示資料，所有的資料應由 Controller 準備好再傳給 View，所以不要在 View 內有複雜的程式判斷邏輯，在 View 裡面只有 if, for, foreach 跟 echo 列印 的程式，僅需要將資料呈現在對的 HTML 裡面，不要再對資料重複處理過。\n像是文章的網址可能會因為類型不同會有不同的網址，像是一般文章網址可能為 http://kejyun.com/post/1，而影音文章網址可能為 http://kejyun.com/video/2，兩者的資料皆為 Post 資料表的資料，在 View 中要顯示網址應為 echo $Post-\u0026gt;post_url; 將網址印出，post_url 則是在傳給 View 之前就經過邏輯判斷的資料，而不是在 View 中判斷不同文章類型（PostConstant::POST_TYPE_NORMAL, PostConstant::POST_TYPE_VIDEO）在 View 中顯示不同的網址資料。\n之後若文章網址邏輯需要修改，則需要到各個 View 中去修改，很容易漏改道造成系統程式出錯\n\u0026lt;a href=\u0026#34;{{ $Post-\u0026gt;info-\u0026gt;post_url }}\u0026#34;\u0026gt; {{ $Post-\u0026gt;Title }}\u0026lt;/a\u0026gt; "
},
{
	"uri": "https://kejyun.github.io/laravel5-book/database/",
	"title": "Database",
	"tags": [],
	"description": "",
	"content": "這裏會介紹一些 Laravel 使用的資料庫\n"
},
{
	"uri": "https://kejyun.github.io/laravel5-book/database/model/",
	"title": "Eloquent Model (模型)",
	"tags": [],
	"description": "",
	"content": "Eloquent Model 這裏會介紹如何在 Laravel 使用 Eloquent Model 管理資料庫\n"
},
{
	"uri": "https://kejyun.github.io/laravel5-book/database/model/eloquent-relationships/",
	"title": "Eloquent 關聯",
	"tags": [],
	"description": "",
	"content": "Eloquent 關聯 假如我們有兩個模型，「文章（Article）」及「使用者（Users）」，假設一個情境，1 個使用者可以寫多篇的文章，但 1 篇文章只能被 1 個使用者發表\n如果我們想要透過關聯關係，從使用者模型去取得使用者的文章，就像：\n// 取得使用者編號 1 的物件 $user = \\App\\Users::find(1); // 取得使用者的所有發表的文章 $user-\u0026gt;articles(); 我們會想要使用者模型內設定這樣的關聯關係，就像：\nclass Users extends Model { // 設定使用者擁有許多文章 public function articles() { return $this-\u0026gt;hasMany(\u0026#39;App\\Article\u0026#39;); } } 如果我們想透過關聯關係，從文章模型去取得是哪一個使用者發表文章，就像：\n// 取得文章編號 1 的物件 $article = \\App\\Article::find(1); // 取得發表文章的使用者資訊 $user = $article-\u0026gt;user(); class Article extends Model { // 設定文章屬於某一的使用者 public function user() { return $this-\u0026gt;belongsTo(\u0026#39;App\\User\u0026#39;); } public function owner() { return $this-\u0026gt;belongsTo(\u0026#39;App\\User\u0026#39;); } public function writer() { return $this-\u0026gt;belongsTo(\u0026#39;App\\User\u0026#39;); } } 設定關聯屬性的函式名稱可以自訂，看自己覺得什麼樣的名稱適合自己就可以了，自訂完後一樣可以使用關聯的方式，撈取出發表文章使用者的資訊\n// 取得文章編號 1 的物件 $article = \\App\\Article::find(1); // 取得發表文章的使用者資訊 $owner_user = $article-\u0026gt;owner(); $writer_user = $article-\u0026gt;writer(); 設定完之後，必須確定文章（Article）資料表有使用者編號（user_id）的外來鍵欄位\n\u0026lt;?php // database/migrations/2015_04_13_154720_create_article_table.php  use Illuminate\\Database\\Schema\\Blueprint; use Illuminate\\Database\\Migrations\\Migration; class CreateArticleTable extends Migration { public function up() { Schema::table(\u0026#39;article\u0026#39;, function(Blueprint $table) { // 發表文章使用者編號  $table-\u0026gt;integer(\u0026#39;user_id\u0026#39;)-\u0026gt;unsigned(); // 設定外來鍵  $table-\u0026gt;foreign(\u0026#39;user_id\u0026#39;) -\u0026gt;references(\u0026#39;id\u0026#39;) -\u0026gt;on(\u0026#39;users\u0026#39;) -\u0026gt;onDelete(\u0026#39;cascade\u0026#39;); }); } public function down() { Schema::drop(\u0026#39;users\u0026#39;); } } 參考資料  Eloquent Relationships - Laracasts  "
},
{
	"uri": "https://kejyun.github.io/laravel5-book/environment/homestead/install-with-homestead/",
	"title": "Homestead",
	"tags": [],
	"description": "",
	"content": "Homestead 常常我我們需要開發Web Application時候，都需要花很長的時間把環境建置起來，而Homestead以讓我們透過簡單的設定檔，輕鬆的建置好整個執行環境，讓我們能夠更專注於在開發上\n OSX El Capitan 10.11.3\n  Laravel 5.2\n  Vagrant 1.8.1\n  Virtualbox 5.0.14\n 安裝 Virtualbox 從 VirtualBox 官方網站 下載並安裝 VirtualBox\n下載連結：http://download.virtualbox.org/virtualbox/5.0.14/VirtualBox-5.0.14-105127-OSX.dmg\n安裝 Vagrant 從 Vagrant 官方網站 下載並安裝 Vagrant\n下載連結：https://releases.hashicorp.com/vagrant/1.8.1/vagrant_1.8.1.dmg\n安裝 Homestead Vagrant Box 在 VirtualBox 及 Vagrant 安裝完後，使用下列指令將 Homestead 加入您的虛擬主機中\nvagrant box add laravel/homestead 使用 Git 複製 Laravel homestead 並建立 Homestead 設定檔 $ git clone https://github.com/laravel/homestead.git Homestead $ cd Homestead ~/Homestead$ bash init.sh 建立ssh key $ ssh-keygen -t rsa -C \u0026#34;kejyun@homestead\u0026#34; 編輯 Homestead 設定檔 $ vim ~/.homestead/Homestead.yaml 確認設定檔中ssh key有對應到正確的路徑\nauthorize: ~/.ssh/id_rsa.pub keys: - ~/.ssh/id_rsa 設定虛擬主機提供者 vagrant 支援 virtualbox, vmware_fusion 或 vmware_workstation 這幾個虛擬主機，我們使用 VirtualBox 所以就填入 virtualbox\nprovider: virtualbox 設定本機程式碼路徑對應到測試環境的路徑共用資料夾  map：本機路徑\n  to：Vagrant測試機路徑\n 程式路徑 folders: - map: ~/Code to: /home/vagrant/Code - map: ~/laravel52 to: /home/vagrant/laravel52 網站路徑 sites: - map: kejyun.app to: /home/vagrant/laravel52/public 設定 /ect/hosts 對應本機網址到 Vagrant $ sudo vim /etc/hosts 加入下列設定\n192.168.10.10 kejyun.app  IP 位址為 Homestead.yaml 設定中的 ip 設定值，kejyun.app 則是參照設定檔中的 sites map 設定有哪些則加進去 hosts 設定檔中\n 啟動 Vagrant ~/Homestead $ vagrant up  在剛剛使用Git複製下來的homestead資料夾中執行vagrant up指令，會自動下載virtualbox相關的虛擬主機設定，並依照設定檔設置虛擬主機。\n 設定完成後可以開啟瀏覽器到 http://kejyun.app 看看Homestead是否有正常啟動，若看到下列畫面表示可以正常運作了！！！\n備註 若要關閉Homestead虛擬機器，則可以使用下列指令關閉\nvagrant halt 若設定檔有修改要重新讀取，則可以使用下列指令重新讀取設定\nvagrant provision SSL read: error:00000000:lib(0):func(0):reason(0), errno 60 若在啟動 homestead 時出現 SSL read 的錯誤訊息的話，可以重新加入新的 homestead vagrand box\n$ vagrant up Bringing machine \u0026#39;default\u0026#39; up with \u0026#39;virtualbox\u0026#39; provider... ==\u0026gt; default: Box \u0026#39;laravel/homestead\u0026#39; could not be found. Attempting to find and install... default: Box Provider: virtualbox default: Box Version: \u0026gt;= 0.4.0 ==\u0026gt; default: Loading metadata for box \u0026#39;laravel/homestead\u0026#39; default: URL: https://atlas.hashicorp.com/laravel/homestead ==\u0026gt; default: Adding box \u0026#39;laravel/homestead\u0026#39; (v0.4.4) for provider: virtualbox default: Downloading: https://atlas.hashicorp.com/laravel/boxes/homestead/versions/0.4.4/providers/virtualbox.box An error occurred while downloading the remote file. The error message, if any, is reproduced below. Please fix this error and try again. SSL read: error:00000000:lib(0):func(0):reason(0), errno 60 加入新的 homestead vagrand box vagrant box add --insecure -c laravel/homestead http://atlas.hashicorp.com/laravel/boxes/homestead $ vagrant box add --insecure -c laravel/homestead http://atlas.hashicorp.com/laravel/boxes/homestead ==\u0026gt; box: Loading metadata for box \u0026#39;http://atlas.hashicorp.com/laravel/boxes/homestead\u0026#39; This box can work with multiple providers! The providers that it can work with are listed below. Please review the list and choose the provider you will be working with. 1) virtualbox 2) vmware_desktop Enter your choice: 1 ==\u0026gt; box: Adding box \u0026#39;laravel/homestead\u0026#39; (v0.4.4) for provider: virtualbox box: Downloading: https://atlas.hashicorp.com/laravel/boxes/homestead/versions/0.4.4/providers/virtualbox.box ==\u0026gt; box: Successfully added box \u0026#39;laravel/homestead\u0026#39; (v0.4.4) for \u0026#39;virtualbox\u0026#39;! 加入完成後，再重新啟動 homestead 即可\n$ vagrant up 變更 Homestead 主機 ip 當我們想要有多台 Homestead 主機時，會因為 Homestead 預設的主機 ip 都為 192.168.10.11 而導致 ip 之間有衝突，所以我們也可以透過置換 ip 去達到同時開不同的 Homestead 主機。\n--- ip: \u0026#34;192.168.99.10\u0026#34; 我們僅需要將 ip 直接換成我們想要的 ip，這裡我將 ip 換成 192.168.99.10，換完 ip 之後，僅需要打 vagrant reload 這樣就可以成功將 ip 置換掉了！\nvagrant reload VT-x is disabled in the BIOS for all CPU modes 在使用 vagrant up 的時候，若出現 VT-x is disabled in the BIOS for all CPU modes 表示你的 BIOS 沒有開啟虛擬化功能\nThere was an error while executing VBoxManage, a CLI used by Vagrant for controlling VirtualBox. The command and stderr is shown below. Command: [\u0026quot;startvm\u0026quot;, \u0026quot;4316329f-815b-4088-b04f-e7ff0c224c4a\u0026quot;, \u0026quot;--type\u0026quot;, \u0026quot;headless\u0026quot;] Stderr: VBoxManage.exe: error: Not in a hypervisor partition (HVP=0) (VERR_NEM_NOT_AVAILABLE). VBoxManage.exe: error: VT-x is disabled in the BIOS for all CPU modes (VERR_VMX_MSR_ALL_VMX_DISABLED) VBoxManage.exe: error: Details: code E_FAIL (0x80004005), component ConsoleWrap, interface IConsole 此時只需要到 BIOS 將虛擬化功能開啟即可\n 虛擬化功能名稱可能會像是：“Intel VT-x,” “Intel Virtualization Technology,” “Virtualization Extensions,” “Vanderpool”，並且放在 “Chipset,” “Northbridge,” “Advanced Chipset Control,” or “Advanced CPU Configuration” 的選單上\n 開啟後重新使用 vagrant up 即可順利開啟虛擬機器\n除錯 安裝 Laravel 過程出現 Could not scan for classes inside \u0026quot;/home/vagrant/Code/blog/vendor/phpunit/php-code-coverage/src/\u0026quot; 訊息 2020/04/05 時在安裝新版 Homestead 時，發現一直出現以下錯誤訊息，一直無法順利安裝 Laravel\n安裝過程是用官網的步驟直接安裝\nvagrant box add laravel/homestead git clone https://github.com/laravel/homestead.git ~/Homestead cd ~/Homestead git checkout release 當前的 Homestead 版本是 release v10.7.0，然後使用標準 composer 指令去安裝 Laravel\ncomposer create-project --prefer-dist laravel/laravel blog 安裝過程最後不斷出現 Could not scan for classes inside \u0026quot;/home/vagrant/Code/blog/vendor/phpunit/php-code-coverage/src/\u0026quot; 的訊息\nPackage jakub-onderka/php-console-color is abandoned, you should avoid using it. Use php-parallel-lint/php-console-color instead. Package jakub-onderka/php-console-highlighter is abandoned, you should avoid using it. Use php-parallel-lint/php-console-highlighter instead. Generating optimized autoload files [RuntimeException] Could not scan for classes inside \u0026#34;/home/vagrant/Code/blog/vendor/phpunit/php-code-coverage/src/\u0026#34; which does not appear to be a file nor a folder install [--prefer-source] [--prefer-dist] [--dry-run] [--dev] [--no-dev] [--no-custom-installers] [--no-autoloader] [--no-scripts] [--no-progress] [--no-suggest] [-v|vv|vvv|--verbose] [-o|--optimize-autoloader] [-a|--classmap-authoritative] [--apcu-autoloader] [--ignore-platform-reqs] [--] [\u0026lt;packages\u0026gt;]... vagrant@homestead:~/Code/test$ 在搜尋了許久發現 Homestead 9新盒子建立一个新的Laravel專案作曲家無法掃描裏面的類/ vendor / phpunit / php-code-coverage / src / - laravel - Codebug 文章中提到了一個關鍵字\n 將 VirtualBox 更新為 v6。\n  在GitHub上查看此問题：https://github.com/laravel/homestead/issues/1219\n  Unable to load the \u0026ldquo;app\u0026rdquo; configuration file. · Issue #1219 · laravel/homestead\n 發現自己的 VirtualBox 版本為 5.x，立即去官網將 VirtualBox 更新至 6.x 就可以順利安裝了，安裝過程中完全沒有提到跟 VirtualBox 有關的錯誤訊息，導致我鬼打牆了好久 QQ\n也有人遇到的問題是因為 composer cache 的問題，也可以用這個方式移除 compser cache 來解決安裝問題\ncomposer clear-cache cd project/ rm -rf vendor composer install 參考資料  Say Hello to Laravel Homestead 2.0 Laravel - Homestead Virtualbox Vagrant Vagrant 常用指令 SSL read: error · Issue #401 · Varying-Vagrant-Vagrants/VVV Vagrant: Fix for error 60 / SSL read - Slick Change ip homestead Vagrant error on Windows 10 · Issue #195 · scotch-io/scotch-box · GitHub VBoxManage: error: VT-x is disabled in the BIOS for all CPU modes · Issue #1301 · openebs/openebs · GitHub How to Enable Intel VT-x in Your Computer’s BIOS or UEFI Firmware Homestead 9新盒子建立一个新的Laravel專案作曲家無法掃描裏面的類/ vendor / phpunit / php-code-coverage / src / - laravel - Codebug Unable to load the \u0026ldquo;app\u0026rdquo; configuration file. · Issue #1219 · laravel/homestead Fresh install laravel 5.3 on Homestead 3.0.2 fail \u0026ldquo;/vendor/phpunit/php-code-coverage/src/\u0026rdquo; · Issue #15105 · laravel/framework  "
},
{
	"uri": "https://kejyun.github.io/laravel5-book/design-pattern/psr/",
	"title": "PSR",
	"tags": [],
	"description": "",
	"content": "PSR (php standard recommendations) 為了讓大家開發的套件，能夠更輕鬆地整合到自己的專案當中，在 PHP 社群中大家一起定義了一些標準的程式碼撰寫規則\n但是 Laravel 5.0.x 版本之前，Laravel 都沒有真正的遵照 PSR 的規範去撰寫程式碼，直到 Laravel 5.1 LTS 版本時，Laravel 終於將所有的程式碼遵照 PSR-2 及 PSR-4 的程式碼撰寫規則了，詳細的規則說明大家可以自己參考相關的說明文件。\n而為了讓自己專案的開發也能夠遵照 PSR 規則，除了自己一個檔案一個檔案自己修改外，也可以用 PHP Coding Standards Fixer 套件去幫我們自動地將程式修改成遵照 PSR 規則的程式！\nPHP Coding Standards Fixer 安裝使用教學 使用 compser 下載套件 使用 composer 將 php-cs-fixer 安裝到全域（global）目錄下\n$ composer global require fabpot/php-cs-fixer 設定 composer bin 目錄到環境變數中 我們必須要將我們家目錄下的全域 ~/.composer/vendor/bin 目錄，設到環境變數中，這樣我們在命令列就可以直接執行 ~/.composer/vendor/bin 下面的可執行檔案了\n$ export PATH=\u0026#34;$PATH:$HOME/.composer/vendor/bin\u0026#34;  我們可以直接在命令列下這樣的指令就可以了，但每次開啟新的 Terminal 視窗時，都要再重新的設定一次這樣的環境變數，所以我們也可以把這個設定寫在 ~/.bash_profile 檔案中，這樣每次執行 Terminal 時，就會自動將 ~/.composer/vendor/bin 設到環境變數中了！\n 使用 php-cs-fixer 修正 PHP 檔案 設定完成後，我們就可以使用 php-cs-fixer fix /path/to/project --level=psr2 這樣的指令去修正我們專案目錄下的檔案了\n一些 php-cs-fixer 相關的指令會像這樣:\n$ php-cs-fixer fix /path/to/project --level=psr0 $ php-cs-fixer fix /path/to/project --level=psr1 $ php-cs-fixer fix /path/to/project --level=psr2 $ php-cs-fixer fix /path/to/project --level=symfony 設定 Sublime 使用 php-cs-fixer 修正程式碼 在 Sublime 上方工具列 Tools\\Bulid System\\New Build System 我們可以新增一個新的建立指令，指令中我們輸入像這樣的指令：\n{ \u0026#34;shell_cmd\u0026#34;: \u0026#34;php-cs-fixer fix $file --level=psr2\u0026#34; } 將新的指令檔案名稱取為 php-cs-fixer.sublime-bulid，這樣我們回到 Sublime 去開啟任一 PHP 檔案，只要按下 Command（⌘）+B，Sublime 就會自動幫我們執行 php-cs-fixer 的 shell script 指令，去修正我們的 PHP 檔案了！！\nphp-cs-fixer 使用小技巧 我們可以將修改 ~/.bash_profile 檔案，將使用 php-cs-fixer 修正 Terminal 目前目錄的 PHP 指令加入，這樣我們只要用 Terminal 瀏覽到我們想要做 php-cs-fixer 的目錄下，我們每次只需要下 phpCSFixerThisFolder 指令就可以了，這樣就不用記住也不用打那麼落落長的 php-cs-fixer 指令了！\nalias phpCSFixerThisFolder=\u0026#34;php-cs-fixer fix ./ --level=psr2\u0026#34; PSR 中文文件  PSR-1 - Basic Coding Standard PSR-2 - Coding Style Guide PSR-3 - 日誌介面 PSR-4 - Autoloader  參考資料  PHP-FIG — PHP Framework Interop Group PHP: The Right Way - 繁體中文 PHP Coding Standards Fixer PHP-CS-Fixer Adopting PSR-2 - laracasts  "
},
{
	"uri": "https://kejyun.github.io/laravel5-book/database/qa/cannot-mass-insert/",
	"title": "使用大量資料的方式新增時無法新增",
	"tags": [],
	"description": "",
	"content": "使用大量資料的方式新增（Mass Assignment）時無法新增 在 Laravel 若沒有在模型（Model）中同時設定「可以新增的欄位變數 $fillable」及「需要保護的欄位變數 $guarded」時，為了安全性著想，在做大量的新增或異動資料時（Mass Assignment），會無法正確的去新增或異動資料。\n設定「可以新增的欄位變數 $fillable」 設定你覺得允許做大量新增的欄位名稱\nclass User extends Model { protected $fillable = [\u0026#39;first_name\u0026#39;, \u0026#39;last_name\u0026#39;, \u0026#39;email\u0026#39;]; } 設定「需要保護的欄位變數 $guarded」 我們可以指定某些欄位，不能被使用大量新增或異動，去變更欄位的資料值\nclass User extends Model { protected $guarded = [\u0026#39;id\u0026#39;, \u0026#39;password\u0026#39;]; } 若我們想要讓模型（Model）可以被大量新增，且我們沒有需要保護的欄位時，我們還是需要設定 $guarded 變數為空陣列 []，否則 Laravel 預會保護所有的欄位資料，讓你無法進行大量的新增或異動資料\nclass User extends Model { protected $fillable = [\u0026#39;id\u0026#39;, \u0026#39;password\u0026#39;, \u0026#39;first_name\u0026#39;, \u0026#39;last_name\u0026#39;, \u0026#39;email\u0026#39;]; protected $guarded = []; } 參考資料  Eloquent ORM 新增、更新、刪除 - Laravel.tw Laravel Eloquent Save to DB Using Create - Unhelpful Error Eloquent Create Method - Always inserts blank entries. Unable to create a model with Eloquent create method. Error telling MassAssignMentException  "
},
{
	"uri": "https://kejyun.github.io/laravel5-book/http/route/sub-domain-route/",
	"title": "子網域路由（Sub-Domain Route）",
	"tags": [],
	"description": "",
	"content": "子網域路由（Sub-Domain Route） 我們可能會因為有多個子網域，而我們希望各個不同的子網域有自己的路由設定，像是我們希望各個子網域的首頁能夠藍道不同的頁面，這個時候我們可以透過子網域路由去幫我們達成這樣的工作\n加入您的子網域到 hosts 設定 如果是正式環境則不用做此設定，如果是測試環境也想要達到子網域路由的效果，則必須做此設定\n開啟 /etc/hosts 檔案，並加入您需要的子網域\n127.0.0.1 resume.kejyun.dev 127.0.0.1 book.kejyun.dev Homestead 加入此子網域的虛擬主機設定 sites: - map: resume.kejyun.dev to: /home/vagrant/Code/KeJyunProject/public - map: book.kejyun.dev to: /home/vagrant/Code/KeJyunProject/public 重新讀取 Homestead 設定 若設定檔有修改要重新讀取，則可以使用下列指令重新讀取設定\nvagrant provision 加入子網域路由 在 route.php 檔案中加入子網域路由\nRoute::group([\u0026#39;domain\u0026#39; =\u0026gt; \u0026#39;resume.kejyun.dev\u0026#39;], function() { Route::get(\u0026#39;/\u0026#39;, function() { return \u0026#39;KeJyun Resume\u0026#39;; }); }); Route::group([\u0026#39;domain\u0026#39; =\u0026gt; \u0026#39;book.kejyun.dev\u0026#39;], function() { Route::get(\u0026#39;/\u0026#39;, function() { return \u0026#39;KeJyun Book\u0026#39;; }); }); 這樣我們就可以在 http://resume.kejyun.dev 及 http://book.kejyun.dev 這兩個子網域看到不同的首頁了！\n參考資料  Homestead and Subdomains  "
},
{
	"uri": "https://kejyun.github.io/laravel5-book/services/unit-test/unit-test-assert/",
	"title": "Assert",
	"tags": [],
	"description": "",
	"content": "Assert 狀態碼測試 assertOk ： 測試回傳狀態碼為 200 assertForbidden ： 測試回傳狀態碼為 403 assertNotFound ： 測試回傳狀態碼為 404 assertSuccessful ： 測試回傳狀態碼為 200 ~ 299 \u0026lt;?php $response = $this-\u0026gt;json(\u0026#39;GET\u0026#39;, \u0026#39;/api/status-code\u0026#39;); // 測試狀態碼 $response-\u0026gt;assertOk(); // 狀態碼 200 $response-\u0026gt;assertNotFound(); // 狀態碼 404 $response-\u0026gt;assertForbidden(); // 狀態碼 403 $response-\u0026gt;assertSuccessful(); // 狀態碼 200 ~ 299 assertStatus ： 測試指定狀態碼 \u0026lt;?php $response = $this-\u0026gt;json(\u0026#39;GET\u0026#39;, \u0026#39;/api/status-code\u0026#39;); // 測試狀態碼 $response-\u0026gt;assertStatus(201); // 狀態碼 201 assertRedirect ： 測試是否為重新導向狀態碼  重新導向狀態碼：201, 301, 302, 303, 307, 308\n \u0026lt;?php $response = $this-\u0026gt;call(\u0026#39;GET\u0026#39;, \u0026#39;/redirect-uri\u0026#39;); // 測試狀態碼 $response-\u0026gt;assertRedirect($redirect_uri); 狀態測試 assertLocation ： 測試目前網址位置 \u0026lt;?php $response = $this-\u0026gt;call(\u0026#39;GET\u0026#39;, \u0026#39;/specific-location\u0026#39;); // 測試是否包含指定資料 $response-\u0026gt;assertLocation(\u0026#39;/specific-location\u0026#39;); 資料測試 assertSee ： 測試是否有包含指定資料 \u0026lt;?php $response = $this-\u0026gt;call(\u0026#39;GET\u0026#39;, \u0026#39;/hello-world\u0026#39;); // 測試是否包含指定資料 $response-\u0026gt;assertSee(\u0026#39;\u0026lt;h1\u0026gt;Hello World\u0026lt;/h1\u0026gt;\u0026#39;); assertSeeInOrder ： 測試是否看到指定順序資料 \u0026lt;?php $response = $this-\u0026gt;call(\u0026#39;GET\u0026#39;, \u0026#39;/hello-world\u0026#39;); // 測試是否沒有包含指定資料 $response-\u0026gt;assertSeeInOrder([ \u0026#39;\u0026lt;h1\u0026gt;\u0026#39;, \u0026#39;Hello\u0026#39;, \u0026#39;World\u0026#39;, \u0026#39;\u0026lt;/h1\u0026gt;\u0026#39;, ]); assertSeeText ： 測試是否看到指定文字（不包含 html tag） \u0026lt;?php $response = $this-\u0026gt;call(\u0026#39;GET\u0026#39;, \u0026#39;/hello-world\u0026#39;); // 測試是否包含指定資料 $response-\u0026gt;assertSeeText(\u0026#39;Hello World\u0026#39;); assertSeeTextInOrder ： 測試是否看到指定順序文字（不包含 html tag） \u0026lt;?php $response = $this-\u0026gt;call(\u0026#39;GET\u0026#39;, \u0026#39;/hello-world\u0026#39;); // 測試是否沒有包含指定資料 $response-\u0026gt;assertSeeTextInOrder([ \u0026#39;Hello\u0026#39;, \u0026#39;World\u0026#39;, ]); assertDontSee ： 測試是否沒有看到指定資料 \u0026lt;?php $response = $this-\u0026gt;call(\u0026#39;GET\u0026#39;, \u0026#39;/hello-world\u0026#39;); // 測試是否沒有包含指定資料 $response-\u0026gt;assertDontSee(\u0026#39;\u0026lt;h1\u0026gt;No Hello World\u0026lt;/h1\u0026gt;\u0026#39;); assertDontSeeText ： 測試是否沒有看到指定文字 \u0026lt;?php $response = $this-\u0026gt;call(\u0026#39;GET\u0026#39;, \u0026#39;/hello-world\u0026#39;); // 測試是否沒有包含指定資料 $response-\u0026gt;assertDontSeeText(\u0026#39;No Hello World\u0026#39;); Cookie 測試 assertPlainCookie ： 測試是否為未加密 Cookie \u0026lt;?php $response = $this-\u0026gt;call(\u0026#39;GET\u0026#39;, \u0026#39;/get-cookie\u0026#39;); // 測試是否包含指定資料 $response-\u0026gt;assertPlainCookie(\u0026#39;cookie-name\u0026#39;); assertCookie ： 測試指定 Cookie 是否有包含指定鍵值資料 \u0026lt;?php $response = $this-\u0026gt;call(\u0026#39;GET\u0026#39;, \u0026#39;/get-cookie\u0026#39;); // 測試是否包含指定資料 $response-\u0026gt;assertCookie(\u0026#39;cookie-name\u0026#39;, \u0026#39;cookie-value\u0026#39;, $encrypted = true, $unserialize = false); assertCookieExpired ： 測試指定鍵值 cookie 是否失效 \u0026lt;?php $response = $this-\u0026gt;call(\u0026#39;GET\u0026#39;, \u0026#39;/get-cookie\u0026#39;); // 測試是否包含指定資料 $response-\u0026gt;assertCookieExpired(\u0026#39;expired-cookie-name\u0026#39;); JSON 測試 assertJson ： 測試 JSON 子集合資訊  測試的資料，僅需為原始資料的子集合即可\n 回傳資料 { \u0026#34;status\u0026#34; : true, \u0026#34;data\u0026#34;: { \u0026#34;title\u0026#34;: \u0026#34;Nam saepe earum molestias consequuntur et doloremque ea.\u0026#34;, \u0026#34;body\u0026#34;: \u0026#34;Consequatur iure omnis distinctio tempore accusamus...\u0026#34;, \u0026#34;active\u0026#34;: false } } 測試 JSON 子集合資訊 $response = $this-\u0026gt;json(\u0026#39;GET\u0026#39;, \u0026#39;/api/json\u0026#39;); // 測試成功 $response-\u0026gt;assertJsonFragment([ \u0026#39;status\u0026#39; =\u0026gt; true, ]); // 測試成功 $response-\u0026gt;assertJsonFragment([ \u0026#39;status\u0026#39; =\u0026gt; true, \u0026#39;data\u0026#39; =\u0026gt; [ \u0026#34;active\u0026#34;=\u0026gt; false ] ]); assertJsonFragment ： 測試 JSON 部分鍵值資訊 回傳資料 { \u0026#34;status\u0026#34; : true, \u0026#34;data\u0026#34;: { \u0026#34;title\u0026#34;: \u0026#34;Nam saepe earum molestias consequuntur et doloremque ea.\u0026#34;, \u0026#34;body\u0026#34;: \u0026#34;Consequatur iure omnis distinctio tempore accusamus...\u0026#34;, \u0026#34;active\u0026#34;: false } } 測試成功\n$response = $this-\u0026gt;json(\u0026#39;GET\u0026#39;, \u0026#39;/api/json\u0026#39;); // 測試成功 $response-\u0026gt;assertJsonFragment([ \u0026#39;status\u0026#39; =\u0026gt; true, ]); // 測試成功 $response-\u0026gt;assertJsonFragment([ \u0026#39;status\u0026#39; =\u0026gt; true, \u0026#39;data\u0026#39; =\u0026gt; [ \u0026#34;title\u0026#34; =\u0026gt; \u0026#34;Nam saepe earum molestias consequuntur et doloremque ea.\u0026#34;, \u0026#34;body\u0026#34;=\u0026gt; \u0026#34;Consequatur iure omnis distinctio tempore accusamus...\u0026#34;, \u0026#34;active\u0026#34;=\u0026gt; false ] ]); 測試 JSON 部分鍵值資訊  若有要指定測試鍵值的資料，則測試的鍵值資料必須包含所有的資訊\n 測試成功\n$response = $this-\u0026gt;json(\u0026#39;GET\u0026#39;, \u0026#39;/api/json\u0026#39;); // 測試成功 $response-\u0026gt;assertJsonFragment([ \u0026#39;status\u0026#39; =\u0026gt; true, ]); // 測試成功 $response-\u0026gt;assertJsonFragment([ \u0026#39;status\u0026#39; =\u0026gt; true, \u0026#39;data\u0026#39; =\u0026gt; [ \u0026#34;title\u0026#34; =\u0026gt; \u0026#34;Nam saepe earum molestias consequuntur et doloremque ea.\u0026#34;, \u0026#34;body\u0026#34;=\u0026gt; \u0026#34;Consequatur iure omnis distinctio tempore accusamus...\u0026#34;, \u0026#34;active\u0026#34;=\u0026gt; false ] ]); 測試失敗\n// 測試失敗 $response-\u0026gt;assertJsonFragment([ 'status' =\u0026gt; true, 'data' =\u0026gt; [ \u0026quot;title\u0026quot; =\u0026gt; \u0026quot;Nam saepe earum molestias consequuntur et doloremque ea.\u0026quot;, ] ]); assertJsonStructure ： 測試 JSON 結構 回傳資料 { \u0026#34;status\u0026#34; : true, \u0026#34;data\u0026#34;: { \u0026#34;title\u0026#34;: \u0026#34;Nam saepe earum molestias consequuntur et doloremque ea.\u0026#34;, \u0026#34;body\u0026#34;: \u0026#34;Consequatur iure omnis distinctio tempore accusamus...\u0026#34;, \u0026#34;active\u0026#34;: false } } 測試 JSON 結構 $response = $this-\u0026gt;json(\u0026#39;GET\u0026#39;, \u0026#39;/api/json\u0026#39;); $response-\u0026gt;assertJsonStructure([ \u0026#39;status\u0026#39;, \u0026#39;data\u0026#39; =\u0026gt; [ \u0026#39;body\u0026#39;, \u0026#39;title\u0026#39;, \u0026#39;active\u0026#39; ] ]) assertExactJson ： 測試 JSON 資料是否完全符合 回傳資料 { \u0026#34;status\u0026#34; : true, \u0026#34;data\u0026#34;: { \u0026#34;title\u0026#34;: \u0026#34;Nam saepe earum molestias consequuntur et doloremque ea.\u0026#34;, \u0026#34;body\u0026#34;: \u0026#34;Consequatur iure omnis distinctio tempore accusamus...\u0026#34;, \u0026#34;active\u0026#34;: false } } 測試 JSON 結構 $response = $this-\u0026gt;json(\u0026#39;GET\u0026#39;, \u0026#39;/api/json\u0026#39;); $response-\u0026gt;assertExactJson([ \u0026#39;status\u0026#39; =\u0026gt; true, \u0026#39;data\u0026#39; =\u0026gt; [ \u0026#34;title\u0026#34; =\u0026gt; \u0026#34;Nam saepe earum molestias consequuntur et doloremque ea.\u0026#34;, \u0026#34;body\u0026#34;=\u0026gt; \u0026#34;Consequatur iure omnis distinctio tempore accusamus...\u0026#34;, \u0026#34;active\u0026#34;=\u0026gt; false ] ]) 參考資料  Testing JSON APIs, specifically: assertJsonStructure  "
},
{
	"uri": "https://kejyun.github.io/laravel5-book/services/laravel-mix/laravel-mix-browser-sync/",
	"title": "BrowserSync",
	"tags": [],
	"description": "",
	"content": "BrowserSync 使用 BrowserSync 可以在我們對於 blade 檔案做異動時，自動重新載入頁面\n 安裝 BrowserSync  npm install browser-sync --save-dev npm install browser-sync-webpack-plugin@2.0.1 --save-dev 設定 BrowserSync 至 webpack.mix.js  mix.browserSync({ proxy: 'my-domain.test' }); 監控 BrowserSync 運作  npm run watch 參考資料  BrowserSync | Laravel Mix Documentation  "
},
{
	"uri": "https://kejyun.github.io/laravel5-book/services/errors-logs/service/errors-log-service-bugsnag/",
	"title": "Bugsnag",
	"tags": [],
	"description": "",
	"content": "Bugsnag  版本：Laravel 5.0 ~ 5.6\n  紀錄指定的錯誤訊息及系統錯誤\n 1. 安裝\ncomposer require \u0026#34;bugsnag/bugsnag-laravel:^2.0\u0026#34; 2. 設定 config/app.php\n\u0026lt;?php // config/app.php return [ \u0026#39;providers\u0026#39; =\u0026gt; [ Bugsnag\\BugsnagLaravel\\BugsnagServiceProvider::class, ], ]; 3. 設定 API KEY\n到 .env 檔案設定 API KEY，根據官方安裝引導可以取得此 API KEY\n# .env BUGSNAG_API_KEY=\u0026lt;API_KEY\u0026gt; 3. 設定檔\nLaravel 5.6\n\u0026lt;?php // config/logging.php: return [ \u0026#39;channels\u0026#39; =\u0026gt; [ \u0026#39;stack\u0026#39; =\u0026gt; [ \u0026#39;driver\u0026#39; =\u0026gt; \u0026#39;stack\u0026#39;, // Add bugsnag to the stack:  \u0026#39;channels\u0026#39; =\u0026gt; [\u0026#39;single\u0026#39;, \u0026#39;bugsnag\u0026#39;], ], // Create a bugsnag logging channel:  \u0026#39;bugsnag\u0026#39; =\u0026gt; [ \u0026#39;driver\u0026#39; =\u0026gt; \u0026#39;bugsnag\u0026#39;, ], ], ] Laravel 5.0~5.5\n到 app/Providers/AppServiceProvider.php 檔案中的 register 方法加入此設定\nclass AppServiceProvider extends ServiceProvider { public function register() { $this-\u0026gt;app-\u0026gt;alias(\u0026#39;bugsnag.logger\u0026#39;, \\Illuminate\\Contracts\\Logging\\Log::class); $this-\u0026gt;app-\u0026gt;alias(\u0026#39;bugsnag.logger\u0026#39;, \\Psr\\Log\\LoggerInterface::class); } } 4. 發送錯誤訊息到 Bugsnag\nuse Bugsnag\\BugsnagLaravel\\Facades\\Bugsnag; use RuntimeException; Bugsnag::notifyException(new RuntimeException(\u0026#34;Test error\u0026#34;)); 5. 檢視 Bugsnag 錯誤訊息\n6. 留下麵包屑\ntry { // 留下麵包屑 Bugsnag::leaveBreadcrumb(\u0026#39;leaveBreadcrumb 111\u0026#39;); Bugsnag::leaveBreadcrumb(\u0026#39;leaveBreadcrumb 222\u0026#39;); throw new Exception(\u0026#39;Test Hello Exception\u0026#39;); } catch (Exception $exception) { // 傳送訊息 Bugsnag::notifyException($exception); } 7. 檢視麵包屑訊息\n可以看到在程式中留下的麵包屑，可以知道程式在哪一段麵包屑後出錯\n程式系統錯誤 當程式或系統發生錯誤時，也會記錄相關資訊\n參考資料  Error reporting, monitoring, and resolution with Bugsnag bugsnag/bugsnag-laravel: Bugsnag notifier for the Laravel PHP framework. Monitor and report Laravel errors. Bugsnag docs › Platforms › PHP › Laravel  "
},
{
	"uri": "https://kejyun.github.io/laravel5-book/http/middleware/middleware-intro/",
	"title": "中介層介紹",
	"tags": [],
	"description": "",
	"content": "中介層介紹 這裏會介紹如何在 Laravel 5 使用中介層處理資料，Middleware 在 Laravel 4 叫做 Filter，他可以在處理資料之前，先過濾條件判斷，符合條件的再繼續處理之後的 Http 請求。\n就像實作一個部落格，使用者發表文章的時候，一定要登入，否則就會被導到登入頁（或首頁），判斷登入條件的部分在 Laravel 5 可以用中介層去實現。\n檢視中介層類別 我們可以看看內建的驗證使用者是否有登入的 Authenticate 中介層\n\u0026lt;?php namespace App\\Http\\Middleware; // app\\Http\\Middleware\\Authenticate.php  use Closure; use Illuminate\\Contracts\\Auth\\Guard; class Authenticate { protected $auth; /** * Create a new filter instance. * 建立過濾器實例，建構時注入 Guard 類別並存到 auth 變數 * * @param Guard $auth * @return void */ public function __construct(Guard $auth) { $this-\u0026gt;auth = $auth; } /** * Handle an incoming request. * 處理 request * * @param \\Illuminate\\Http\\Request $request * @param \\Closure $next * @return mixed */ public function handle($request, Closure $next) { if ($this-\u0026gt;auth-\u0026gt;guest()) { if ($request-\u0026gt;ajax()) { return response(\u0026#39;Unauthorized.\u0026#39;, 401); } else { return redirect()-\u0026gt;guest(\u0026#39;auth/login\u0026#39;); } } return $next($request); } } 有設定 Http Request 中介層時，所有的請求都會丟給中介層的 handle() 函式做處理，第一個變數傳入的是 Request 本身，第二個變數是若檢查驗證成功之後要執行的函數，並把 Request 丟給下一層處理 $next($request)。\n註冊中介層變數 中介層設定好之後，必須要到 app\\Http\\Kernel.php 去註冊你的中介層\n\u0026lt;?php namespace App\\Http; // app\\Http\\Kernel.php  use Illuminate\\Foundation\\Http\\Kernel as HttpKernel; class Kernel extends HttpKernel { /** * The application\u0026#39;s global HTTP middleware stack. * 全域中介層堆疊 * * @var array */ protected $middleware = [ \u0026#39;Illuminate\\Foundation\\Http\\Middleware\\CheckForMaintenanceMode\u0026#39;, // 檢查應用程式是不是維護中  \u0026#39;Illuminate\\Cookie\\Middleware\\EncryptCookies\u0026#39;, // 加密 Cookies  \u0026#39;Illuminate\\Cookie\\Middleware\\AddQueuedCookiesToResponse\u0026#39;, // 加入 Queued Cookies 到 Response  \u0026#39;Illuminate\\Session\\Middleware\\StartSession\u0026#39;, // 開啟 Session  \u0026#39;Illuminate\\View\\Middleware\\ShareErrorsFromSession\u0026#39;, // 從 Session 中共享錯誤資訊  \u0026#39;App\\Http\\Middleware\\VerifyCsrfToken\u0026#39;, // 驗證 CSRF Token  ]; /** * The application\u0026#39;s route middleware. * 路由中介層 * * @var array */ protected $routeMiddleware = [ \u0026#39;auth\u0026#39; =\u0026gt; \u0026#39;App\\Http\\Middleware\\Authenticate\u0026#39;, \u0026#39;auth.basic\u0026#39; =\u0026gt; \u0026#39;Illuminate\\Auth\\Middleware\\AuthenticateWithBasicAuth\u0026#39;, \u0026#39;guest\u0026#39; =\u0026gt; \u0026#39;App\\Http\\Middleware\\RedirectIfAuthenticated\u0026#39;, ]; } 在 app\\Http\\Kernel.php 類別中，$middleware 變數是設定全域中介層堆疊清單，每一個 Http Request 都會依序經過 $middleware 所有的中介層做判斷\n$middleware 中介層判斷完後都沒問題，才丟給路由中介層 $routeMiddleware 做處理（若路由有設定要使用哪個中介層的話，沒有設定則略過）。\n當我們有自己的中介層，我們可以依自己需求看要將中介層設定加到哪一個變數設定中，如果需要每一個 Request 都做檢查的話，則將中介層設定到 $middleware，否則設定在。 $routeMiddleware 並指定中介層名稱即可。\n在 Controller 使用中介層 我們可以強制設定，當使用者要存取文章的資源時都必須要登入，所以在 ArticleController 控制器的建構子，我們可以用 $this-\u0026gt;middleware('auth'); 設定全部 ArticleController 中的函式皆使用 auth 中介層。\n auth 中介層名稱是參照 app\\Http\\Kernel.php 中的 $routeMiddleware 變數設定\n class ArticleController extends Controller { public function __construct() { $this-\u0026gt;middleware(\u0026#39;auth\u0026#39;); } // 新增文章 public function store(Requests $request) { } } 我們也可以使用 only 方式，指定中介層只有在指定的函式中才使用，或是使用 except 方式指定除了某些函式不使用中介層外，其他都要使用中介層當作過濾\n// 只有設定的函式使用中介層 $this-\u0026gt;middleware(\u0026#39;auth\u0026#39;, [\u0026#39;only\u0026#39;=\u0026gt;\u0026#39;create\u0026#39;]); // 只有設定的函式\u0026#34;不要\u0026#34;使用中介層 $this-\u0026gt;middleware(\u0026#39;auth\u0026#39;, [\u0026#39;except\u0026#39;=\u0026gt;\u0026#39;index\u0026#39;]); 在 Route 使用中介層 // app\\Http\\routes.php Route::get(\u0026#39;about\u0026#39;, [ \u0026#39;middleware\u0026#39; =\u0026gt; \u0026#39;auth\u0026#39;, \u0026#39;uses\u0026#39;=\u0026gt; \u0026#39;HomeController@about\u0026#39; ]); 建立自己的中介層 我們可以使用指令建立自己的 Middleware，假如我建立一個 KeJyunMiddleware 為名稱的中介層，可以在命令列輸入：\n$ php artisan make:middleware KeJyunMiddleware 建立的中介層會放在 app\\Http\\Middleware\\KeJyunMiddleware.php 中\n\u0026lt;?php namespace App\\Http\\Middleware; // app\\Http\\Middleware\\KeJyunMiddleware.php  use Closure; class KeJyunMiddleware { public function handle($request, Closure $next) { return $next($request); } } 建立好自訂的中介層之後，到 app\\Http\\Kernel.php 註冊中介層後即可使用\n\u0026lt;?php namespace App\\Http; // app\\Http\\Kernel.php  class Kernel extends HttpKernel { protected $routeMiddleware = [ \u0026#39;kejyun\u0026#39; =\u0026gt; \u0026#39;App\\Http\\Middleware\\KeJyunMiddleware\u0026#39;, ]; } 參考資料  Ogres Are Like Middleware - Laracasts  "
},
{
	"uri": "https://kejyun.github.io/laravel5-book/http/middleware/",
	"title": "中介層（Middleware）",
	"tags": [],
	"description": "",
	"content": "這裏會介紹如何在 Laravel 處理 中介層（Middleware）。\n"
},
{
	"uri": "https://kejyun.github.io/laravel5-book/services/errors-logs/errors-log-macro/",
	"title": "日誌巨集",
	"tags": [],
	"description": "",
	"content": "日誌巨集 前言 我們會用 Laravel 內建的 Response 去回應服務的訊息，我們可能會用的回應會像這樣：\n// 建立 JSON 回應 return Response::json([\u0026#39;name\u0026#39; =\u0026gt; \u0026#39;KeJyun\u0026#39;, \u0026#39;Country\u0026#39; =\u0026gt; \u0026#39;Taiwan\u0026#39;]); return response()-\u0026gt;json([\u0026#39;name\u0026#39; =\u0026gt; \u0026#39;KeJyun\u0026#39;, \u0026#39;Country\u0026#39; =\u0026gt; \u0026#39;Taiwan\u0026#39;]); // 建立 JSONP 回應 return Response::json([\u0026#39;name\u0026#39; =\u0026gt; \u0026#39;KeJyun\u0026#39;, \u0026#39;Country\u0026#39; =\u0026gt; \u0026#39;Taiwan\u0026#39;]) -\u0026gt;setCallback($request-\u0026gt;input(\u0026#39;callback\u0026#39;)); return response()-\u0026gt;json([\u0026#39;name\u0026#39; =\u0026gt; \u0026#39;KeJyun\u0026#39;, \u0026#39;Country\u0026#39; =\u0026gt; \u0026#39;Taiwan\u0026#39;]) -\u0026gt;setCallback($request-\u0026gt;input(\u0026#39;callback\u0026#39;)); // 建立檔案下載的回應 return response()-\u0026gt;download($pathToFile); return response()-\u0026gt;download($pathToFile, $name, $headers); return response()-\u0026gt;download($pathToFile)-\u0026gt;deleteFileAfterSend(true); 在這樣的使用下，我們可以很容易的回應訊息給使用者，但是在伺服器發生程式例外錯誤 (Exception) 時，我們可能也需要回應像是這樣的資料：\nreturn Response::json([\u0026#39;status\u0026#39; =\u0026gt; \u0026#39;failure\u0026#39;, \u0026#39;error_code\u0026#39; =\u0026gt; \u0026#39;5566\u0026#39;]); return response()-\u0026gt;json([\u0026#39;status\u0026#39; =\u0026gt; \u0026#39;failure\u0026#39;, \u0026#39;error_code\u0026#39; =\u0026gt; \u0026#39;5566\u0026#39;]); 在我們用 Laravel 做 API 給手機用的時候，更需要有這些錯誤狀態的資料，所以我們沒辦法直接像網頁一樣跳出整個的錯誤 debug 畫面\n但我們若想在 API 回應給手機這樣的錯誤資訊時，也能夠將例外錯誤記錄下來，以便我們進行除錯，我們可以做一個 Response 的巨集，去處理紀錄我們的回應\n建立服務提供者 我們在命令列輸入 php artisan make:provider ResponseServiceProvider 建立回應的服務提供者\n$ php artisan make:provider ResponseServiceProvider 該服務提供者檔案會被建立在 app/Providers/ResponseServiceProvider.php 中，命名空間為 App\\Providers\\ResponseServiceProvider\n 我們不一定要將服務提供者的檔案放到 app/Providers 目錄中，我們可以依照自己專案的需求，將他移動到像是 app/KeJyun/Providers 目錄中，這樣命名空間就會變成 App\\KeJyun\\Providers\\ResponseServiceProvider，檔案放置的位置隨自己專案需求而定，只要遵照 PSR-4 的規定去設定命名空間及檔案位置即可\n 我新增了一個名稱為 jsonLog 的 Response 巨集，該巨集會回應 json 資料，並依照記錄層級紀錄我們傳給他的資訊，ResponseServiceProvider 程式會像這樣\n\u0026lt;?php namespace App\\KeJyun\\Providers; // app/KeJyun/Providers/ResponseServiceProvider.php  use Illuminate\\Support\\ServiceProvider; use Response, Log; class ResponseServiceProvider extends ServiceProvider { /** * Bootstrap the application services. * * @return void */ public function boot() { /** * 註冊 Response 記錄錯誤巨集 * * @param Array $response_data 回傳的 json 資料 * @param Array|Object|String $log_data 紀錄的資料 * @param String $log_level 紀錄資料的等級（預設為 info） * * @return Response $response 回應的 json 資料 * * @access public * @author KeJyun kejyun@gmail.com * @date 2015-06-06 */ Response::macro(\u0026#39;jsonLog\u0026#39;, function( $response_data, $log_data =\u0026#39;No Data Be log!!!\u0026#39;, $log_level = \u0026#39;info\u0026#39; ) { // 增加 Log檔案錯訊息間距以便閱讀  Log::debug(\u0026#34;\\n\\n\\n\\n\\n\u0026#34;); Log::debug($response_data); Log::debug(\u0026#34;\\n\\n\u0026#34;); switch ($log_level) { case \u0026#39;debug\u0026#39;: Log::debug($log_data); break; case \u0026#39;notice\u0026#39;: Log::notice($log_data); break; case \u0026#39;warning\u0026#39;: Log::warning($log_data); break; case \u0026#39;error\u0026#39;: Log::error($log_data); break; case \u0026#39;critical\u0026#39;: Log::critical($log_data); break; case \u0026#39;alert\u0026#39;: Log::alert($log_data); break; case \u0026#39;info\u0026#39;: default: Log::info($log_data); break; } // 增加 Log檔案錯訊息間距以便閱讀  Log::debug(\u0026#34;\\n\\n\\n\\n\\n\u0026#34;); return Response::json($response_data); }); } /** * Register the application services. * * @return void */ public function register() { //  } } 設定服務提供者 設定完自己的 jsonLog 紀錄巨集後，我們需要到 config/app.php 設定這個 Response 服務提供者，我的命名空間為 App\\KeJyun\\Providers\\ResponseServiceProvider，所以設定會像這樣：\n// config/app.php \u0026#39;providers\u0026#39; =\u0026gt; [ // 其他的服務提供者 \u0026#39;App\\KeJyun\\Providers\\ResponseServiceProvider\u0026#39;, ], 設定完之後，Laravel 在啟動時就會自動載入該服務提供者了\n使用自定的 Response 巨集 jsonLog 在我們撰寫商業邏輯時若發生無法預期的例外狀況，我們會想要紀錄該例外狀況的資料，我們就可以這樣使用 Response jsonLog 巨集：\ntry{ // 商業邏輯處理 } catch (Exception $exception) { $response_data = [ \u0026#39;status\u0026#39;=\u0026gt;\u0026#39;failure\u0026#39;, \u0026#39;error_code\u0026#39;=\u0026gt;5566, ]; return response()-\u0026gt;jsonLog($response_data, $exception, \u0026#39;alert\u0026#39;); } 這樣在系統發生預期之外的例外時，我們也有參考的資料可以幫我們進行除錯了！！\n參考資料  HTTP 回應：回應巨集 - Laravel.tw 服務提供者 - Laravel.tw  "
},
{
	"uri": "https://kejyun.github.io/laravel5-book/services/queue/",
	"title": "隊列（Queue）",
	"tags": [],
	"description": "",
	"content": "這裏介紹 Laravel 提供的隊列（Queue）功能\n"
},
{
	"uri": "https://kejyun.github.io/laravel5-book/services/queue/queue-async/",
	"title": "非同步資料庫隊列（Async Database Queue）",
	"tags": [],
	"description": "",
	"content": "非同步資料庫隊列（Async Database Queue） 在我們使用 Laravel 提供的資料庫隊列（Database Queue）時，我們需要在命令列執行 php artisan queue:listen 指令，持續的去監聽是否有需要執行的 Queue。\nbarryvdh/laravel-async-queue 隊列套件，可以讓我們不用持續的監聽隊列資料，並在使用隊列時，立即的使用 shell 在背景執行隊列的工作。\n目前（2015-06-01） 套件 0.4.x 版本有支援 Laravel 5\n安裝 $ composer require \u0026#39;barryvdh/laravel-async-queue:0.4.*@dev\u0026#39; 加入 Service Provider 在 config/app.php 檔案中加入 'Barryvdh\\Queue\\AsyncServiceProvider'\n// config/app.php return [ \u0026#39;providers\u0026#39; =\u0026gt; [ \u0026#39;Barryvdh\\Queue\\AsyncServiceProvider\u0026#39;, ] ]; 產生隊列資料表 barryvdh/laravel-async-queue 隊列套件使用原生的資料庫隊列資料表（Database Queue）去時做的，所以我們可以使用 php artisan queue:table 指令去產生隊列的 Migration\n$ php artisan queue:table 所以執行命令後，你可以找到像是 database/migrations/2015_05_26_225627_create_queue_jobs_table.php 這樣的隊列 Migration 檔案\n Migration 檔名日期 2015_05_26_225627 每個人皆不同，會依照你建立當時的時間去產生\n 產生的隊列 Migration 會長的像這樣：\n\u0026lt;?php use Illuminate\\Database\\Schema\\Blueprint; use Illuminate\\Database\\Migrations\\Migration; class CreateQueueJobsTable extends Migration { /** * Run the migrations. * * @return void */ public function up() { Schema::create(\u0026#39;jobs\u0026#39;, function(Blueprint $table) { $table-\u0026gt;bigIncrements(\u0026#39;id\u0026#39;); $table-\u0026gt;string(\u0026#39;queue\u0026#39;); $table-\u0026gt;text(\u0026#39;payload\u0026#39;); $table-\u0026gt;tinyInteger(\u0026#39;attempts\u0026#39;)-\u0026gt;unsigned(); $table-\u0026gt;tinyInteger(\u0026#39;reserved\u0026#39;)-\u0026gt;unsigned(); $table-\u0026gt;unsignedInteger(\u0026#39;reserved_at\u0026#39;)-\u0026gt;nullable(); $table-\u0026gt;unsignedInteger(\u0026#39;available_at\u0026#39;); $table-\u0026gt;unsignedInteger(\u0026#39;created_at\u0026#39;); }); } /** * Reverse the migrations. * * @return void */ public function down() { Schema::drop(\u0026#39;jobs\u0026#39;); } } 建立隊列資料表 執行 php artisan migrate 將隊列資料表新增至資料庫\n設定隊列驅動 在 config/queue.php 檔案中設定非同步資料庫隊列（Async Database Queue）驅動設定，設定如下：\n// config/queue.php return [ \u0026#39;default\u0026#39; =\u0026gt; \u0026#39;async\u0026#39;, \u0026#39;connections\u0026#39; =\u0026gt; [ \u0026#39;async\u0026#39; =\u0026gt; [ \u0026#39;driver\u0026#39; =\u0026gt; \u0026#39;async\u0026#39;, \u0026#39;table\u0026#39; =\u0026gt; \u0026#39;jobs\u0026#39;, \u0026#39;queue\u0026#39; =\u0026gt; \u0026#39;default\u0026#39;, \u0026#39;expire\u0026#39; =\u0026gt; 60, \u0026#39;connection_name\u0026#39;=\u0026gt;\u0026#39;\u0026#39;, ], ], ]; 建立隊列工作 我們可以使用 \\Queue::push('App\\Commands\\SendEmail@fire', $queue_data); 的方法去新增要執行的隊列\n第一個參數是執行隊列需要呼叫的類別名稱位置（App\\Commands\\SendEmail）及方法（fire）\n類別名稱需要正確的指定類別的命名空間（namespace），可以指定這個隊列要執行的類別方法，只要將方法使用 @ 加在後方即可（@customMethod）\n若沒有指定用哪個方法，Laravel 預設會執行 fire 的類別方法（@fire）\n我們使用隊列來寄送 Email，設定隊列的方式大概像這樣：\n// 需要傳送給隊列處理的資料 $queue_data = [ \u0026#39;email\u0026#39; =\u0026gt; \u0026#39;kejyun@gmail.com\u0026#39;, \u0026#39;name\u0026#39; =\u0026gt; \u0026#39;KeJyun\u0026#39;, ]; // 建立隊列 $queue_id = \\Queue::push(\u0026#39;App\\Commands\\SendEmail@fire\u0026#39;, $queue_data); 在 App\\Commands\\Sendmail.php 檔案大概會像這樣：\n\u0026lt;?php namespace App\\Commands; class SendEmail { /** * 執行隊列 * * @return void */ public function fire($job, $data) { // 寄送 Email  \\Mail::send(\u0026#39;emails.welcome\u0026#39;, [], function($message) use ($data) { $message-\u0026gt;to($data[\u0026#39;email\u0026#39;], $data[\u0026#39;name\u0026#39;])-\u0026gt;subject(\u0026#39;歡迎使用 Laravel 5 資料庫隊列寄送 Email!!!\u0026#39;); }); } } 這樣我們就可以正常的使用隊列去幫我們寄信摟！！\n 目前（2015-06-01） barryvdh/laravel-async-queue 在執行完隊列時，無法直接刪除隊列資料，待作者修復這個 bug\n 參考資料  隊列 - Laravel.tw Queues in Laravel with Redis barryvdh/laravel-async-queue - packagist Laravel 5 Async Queue Driver - Github  "
},
{
	"uri": "https://kejyun.github.io/laravel5-book/environment/install-composer/",
	"title": "Composer 安裝",
	"tags": [],
	"description": "",
	"content": "Composer 安裝 Carbon 1 is deprecated, see how to migrate to Carbon 2. 在安裝 Laravel 時會跑出 Carbon 的版本過舊問題\n$ composer install Loading composer repositories with package information Installing dependencies (including require-dev) from lock file Warning: The lock file is not up to date with the latest changes in composer.json. You may be getting outdated dependencies. Run update to update them. Nothing to install or update Package phpunit/phpunit-mock-objects is abandoned, you should avoid using it. No replacement was suggested. Generating optimized autoload files Carbon 1 is deprecated, see how to migrate to Carbon 2. https://carbon.nesbot.com/docs/#api-carbon-2 You can run './vendor/bin/upgrade-carbon' to get help in updating carbon and other frameworks and libraries that depend on it. 建議我們將 Carbon 升級到 Carbon 2，但因為 Carbon 2 至少要 Laravel 5.8，但線上專案因為是用 Laravel 5.5，無法升級，所以可以在 composer 加入此套件即可向下相容\n{ \u0026quot;require\u0026quot;: { \u0026quot;nesbot/carbon\u0026quot;: \u0026quot;2.21.3 as 1.34.0\u0026quot; \u0026quot;kylekatarnls/laravel-carbon-2\u0026quot;: \u0026quot;^1.0.0\u0026quot; } } 參考資料  陈华博客 | Laravel5.5执行composer update报错问题 - 陈华编程学院 Carbon - A simple PHP API extension for DateTime.  "
},
{
	"uri": "https://kejyun.github.io/laravel5-book/database/model/eloquent-magic-function/",
	"title": "Eloquent 魔術函式",
	"tags": [],
	"description": "",
	"content": "Eloquent 魔術函式 預先處理被異動的欄位資料 在使用 Eloquent 新增或異動資料時，我們可能想要對輸入的資料做預先的處理，我們可以使用 Laravel 提供的魔術函式 setNameAttribute() 去預先處理欄位資料。\n如果我們要預先處理文章模型（Article）的發布時間欄位（published_at），我們的魔術函式就會是像：\nclass Article extends Model { public function setPublishedAtAttribute($date) { // 將傳入的 Y-m-d 時間設為 datetime 格式的現在時間 $this-\u0026gt;attributes[\u0026#39;published_at\u0026#39;] = Carbon::createFromFormat(\u0026#39;Y-m-d\u0026#39;, $date); // 將傳入的 Y-m-d 時間設為 datetime 格式的凌晨零時 00:00:00 $this-\u0026gt;attributes[\u0026#39;published_at\u0026#39;] = Carbon::parse($date); } }  魔術函式 setNameAttribute() 中，若遇到欄位名稱有底線的狀況，則將名稱設為駝峰式大小寫（Camel-Case），像是 published_at 則變成 PublishedAt\n 自定義 query 處理函式 假如我們要讀取發表的文章，但是發表的時間 published_at 必須過去的時間，設定於未來發表時間的文章不能被撈取出來，我們可以用這樣的方式去撈取：\n// 取得已經發表的文章，依照發表時間降冪（Desc）排序 $article = \\App\\Article::latest(\u0026#39;published_at\u0026#39;) -\u0026gt;where(\u0026#39;published_at\u0026#39;, \u0026#39;\u0026lt;=\u0026#39;, Carbon::now()) -\u0026gt;get(); 我們可以簡化這個 query，把它寫在 Model 用函式的方式做處理，這樣我們就可以用這樣去取得已發表的文章：\n// 取得已經發表的文章，依照發表時間降冪（Desc）排序 $article = \\App\\Article::latest(\u0026#39;published_at\u0026#39;) -\u0026gt;published() -\u0026gt;get(); 而 Model 裡面我們用 scopeName 魔術函式的方式去設定 published()：\nclass Article extends Model { public function scopePublished($query) { $query-\u0026gt;where(\u0026#39;published_at\u0026#39;, \u0026#39;\u0026lt;=\u0026#39;, Carbon::now()); } } 若我們想要取得尚未被發表的文章資訊，我們模式函式也可以設定成：\nclass Article extends Model { public function scopeUnpublished($query) { $query-\u0026gt;where(\u0026#39;published_at\u0026#39;, \u0026#39;\u0026gt;\u0026#39;, Carbon::now()); } } 這樣我們就可以用 unpublished() 去設定取得文章資訊了\n// 取得已經發表的文章，依照發表時間降冪（Desc）排序 $article = \\App\\Article::latest(\u0026#39;published_at\u0026#39;) -\u0026gt;unpublished() -\u0026gt;get(); 這樣的優點是:\n 簡化程式的長度 讓我們在不同的地方不需要寫同樣落落長的查詢 讓查詢的可讀性增加，published() 與 unpublish() 我們不需要看查詢的語法條件就可以知道這個地方是要做什麼樣的查詢了  參考資料  Eloquent 101 - Laracast Dates, Mutators, and Scopes - Laracast Eloquent ORM - Laravel.tw  "
},
{
	"uri": "https://kejyun.github.io/laravel5-book/http/",
	"title": "Http",
	"tags": [],
	"description": "",
	"content": "這裏會介紹如何在 Laravel 處理 HTTP 請求。\n"
},
{
	"uri": "https://kejyun.github.io/laravel5-book/design-pattern/model/",
	"title": "Model",
	"tags": [],
	"description": "",
	"content": "Model 模型設計模式 我們在使用任何的 Framework 中，都會聽到 MVC 模型，V（View）是負責畫面顯示，C（Controller）是負責控制程式呼叫模型的邏輯，而最重要的 M（Model）是負責整個資料庫的操作，以及撈取資料的邏輯\n我們常常把模型用來作為處理資料的商業邏輯，不管是任何的「資料樣式的轉換」、「資料撈取的邏輯」、「資料格式的驗證」、「資料處理的順序及商業邏輯」\u0026hellip;等等都是放在模型（Model）去處理\n資料樣式的轉換\n// 2016-01-01 00:00:00.123789 $now = Carbon::now(); // 2016/01/01 $now_date = $now-\u0026gt;format(\u0026#39;Y/m/d\u0026#39;); 資料撈取的邏輯\n撈取所有的女會員資料，年紀小於 30 歲\nUser::where(\u0026#39;gender\u0026#39;=\u0026gt;\u0026#39;female\u0026#39;) -\u0026gt;where(\u0026#39;age\u0026#39;, \u0026#39;\u0026lt;\u0026#39;, 30) -\u0026gt;get(); 撈取所有的男會員資料，年紀大於 30 歲\nUser::where(\u0026#39;gender\u0026#39;=\u0026gt;\u0026#39;male\u0026#39;) -\u0026gt;where(\u0026#39;age\u0026#39;, \u0026#39;\u0026gt;\u0026#39;, 30) -\u0026gt;get(); 資料格式的驗證\n$validator = Validator::make(Request::all(), [ \u0026#39;title\u0026#39; =\u0026gt; \u0026#39;required|unique:posts|max:255\u0026#39;, \u0026#39;content\u0026#39; =\u0026gt; \u0026#39;required\u0026#39;, ]); 資料處理的順序及商業邏輯\n/** * 發送 Email 及簡訊給所有女會員 */ // 取得所有女會員資料 $users = User::where(\u0026#39;gender\u0026#39;=\u0026gt;\u0026#39;female\u0026#39;) -\u0026gt;get(); // 發送 Email foreach ($users as $u) { Mail::send(\u0026#39;emails.hello\u0026#39;, [\u0026#39;user\u0026#39; =\u0026gt; $u], function ($mail) use ($u) { $mail-\u0026gt;to($u-\u0026gt;email, $u-\u0026gt;name) -\u0026gt;subject(\u0026#39;安安!\u0026#39;); }); } // 發送簡訊 foreach ($users as $u) { SMS::send(\u0026#39;sms.hello\u0026#39;, [\u0026#39;user\u0026#39; =\u0026gt; $u], function ($sms) use ($u) { $sms-\u0026gt;to($u-\u0026gt;mobile_phone, $u-\u0026gt;name) -\u0026gt;content(\u0026#39;安安!\u0026#39;); }); } 如果把這些不同類別的資料全部丟到 Model 模型去處理會變得很亂，程式碼難以維護，所以我們會用設計模式來降低程式碼的耦合性，讓程式變得容易維護，我們會將 Model 分成：\n 實體（Entity） 資源庫（Repository） 服務（Service） 表單驗證（Form） 資料呈現（Presenter） ARCA 架構檔案結構  實體（Entity） 實體就是我們用來設定 Eloquent Model 的相關設定，像是資料表名稱（$table）、主鍵名稱（$primaryKey) 等等，裡面除了 Eloquent 相關設定以外，不要擺任何的商業邏輯或資料撈取方法\n實體與資料表的關係是「1 對 1」的關係，有幾個資料表就有幾個實體\n 詳情請見Eloquent Model (模型) - 設定\n 資源庫（Repository） 資源庫是我們要用來撈取資料表資料的各個邏輯，我們資料表會有不同的欄位，不同的欄位條件代表不同的意義，像是：\n撈取所有的女會員資料，年紀小於 30 歲\nUser::where(\u0026#39;gender\u0026#39;=\u0026gt;\u0026#39;female\u0026#39;) -\u0026gt;where(\u0026#39;age\u0026#39;, \u0026#39;\u0026lt;\u0026#39;, 30) -\u0026gt;get(); 撈取所有的男會員資料，年紀大於 30 歲\nUser::where(\u0026#39;gender\u0026#39;=\u0026gt;\u0026#39;male\u0026#39;) -\u0026gt;where(\u0026#39;age\u0026#39;, \u0026#39;\u0026gt;\u0026#39;, 30) -\u0026gt;get(); 這些不同的撈取資料邏輯，我會將它包在資源庫中，該資源庫長得會像這樣：\nclass UserRepository { /** * 撈取所有的女會員資料，年紀小於 30 歲 */ public function getYoungFemale() { return User::where(\u0026#39;gender\u0026#39;=\u0026gt;\u0026#39;female\u0026#39;) -\u0026gt;where(\u0026#39;age\u0026#39;, \u0026#39;\u0026lt;\u0026#39;, 30) -\u0026gt;get(); } /** * 撈取所有的男會員資料，年紀大於 30 歲 */ public function getOldMale() { return User::where(\u0026#39;gender\u0026#39;=\u0026gt;\u0026#39;male\u0026#39;) -\u0026gt;where(\u0026#39;age\u0026#39;, \u0026#39;\u0026gt;\u0026#39;, 30) -\u0026gt;get(); } } 這樣我們撈取這些不同資料邏輯時就可以這樣去撈取：\n$userRepository = new UserRepository(); // 撈取所有的女會員資料，年紀小於 30 歲 $young_female_user = $userRepository-\u0026gt;getYoungFemale(); // 撈取所有的男會員資料，年紀大於 30 歲 $old_male_user = $userRepository-\u0026gt;getOldMale(); 這樣除了可以讓程式碼易讀性提高之外，撈取資料的邏輯也可以抽離出來，下次如果有需要撈取同樣的資料時，就可以重複的去使用它，而且不會有重複的程式碼出現在專案的各個地方，讓管理程式碼變得簡單\n資源庫與實體的關係是「1 對 1」的關係，有幾個實體就有幾個資源庫，每個資源庫是代表那個實體的各個不同的資料撈取邏輯\n服務（Service） 服務代表我們程式要處理資料的商業邏輯，我會將各個功能邏輯獨立成一個服務，像是使用者「註冊身份驗證」是一個服務，而使用者「個人隱私設定」也是一個服務\n服務與資源庫的關係是「多 對 1」的關係，像是同樣使用者資料，有「註冊身份驗證」及「個人隱私設定」2 種不同類型的服務\n使用者「註冊身份驗證」服務\n/** * 使用者「註冊身份驗證」服務 */ class UserAuthService { /** * 註冊 */ public function signup() { } /** * 登入驗證 */ public function signin() { } } 使用者「個人隱私設定」服務\n/** * 使用者「個人隱私設定」服務 */ class UserPrivacyService extends AnotherClass { /** * 取得使用者隱私設定 */ public function getUserPrivacy() { } /** * 設定使用者隱私 */ public function setUserPrivacy() { } } 不同類型的服務，只要彼此耦合性很低，我傾向把他分成不同的服務去處理，這樣可以很清楚的知道哪個個服務是專門處理哪一種商業邏輯，程式也比較好管理，在異動程式時也比較不會影響到彼此，避免牽一髮動全身的狀況發生\n表單驗證（Form） 我們設計後端程式的原則，是不要相信任何第三方傳來的資料，在資料做進一步處理時都需要對資料格式做檢查，若於我們設定的資料格式相符，我們才會去做進一步的資料商業邏輯處理\n但是我們可能會在控制器（Controller）做表單資料的驗證，但是服務（Service）、資源庫（Repository）或實體（Entity）為了保護自己的程式邏輯，也有可能去做表單資料的驗證，若每一個階段都做表單資料的驗證，這樣不僅造成了資料發生重複驗證的狀況，也會降低程式的執行速度，更慘的是會造成驗證程式重複出現，如果有驗證規則要修改，我們就必須要確保所有有驗證表單資料的地方，都有正確的被修改，不然程式的商業邏輯可能會沒辦法順利的去執行。\n因為我們對模型做了分層地處理，所以模型的層級架構會像：\n 控制器 (Controller） \u0026gt; 服務（Service） \u0026gt; 資源庫（Repository） \u0026gt; 實體（Entity）\n 控制器會根據他需要的商業邏輯，呼叫不同的服務來處理他的程式邏輯，而且每個控制器，而且每個控制器可能會有不同類型的服務，可能會有使用者（User）的資料、文章（Posts）的資料\u0026hellip;等等需要做資料的驗證，所以驗證資料的規則複雜度會很多。\n我自己會傾向將所有的表單資料驗證都放在服務（Service）中去驗證，不同的商業邏輯可能需要驗證的資料規則不同，但是我們可以確定的是，同一個服務會是同一個類型的資料，像是使用者「註冊身份驗證」服務及使用者「個人隱私設定」服務\u0026lt; 裡面的資料一定是使用者相關的資料，若我們也有文章的服務（PostService），我們也一定可以確保裡面的驗證資料一定是文章相關的資料。\n所以除了服務（Service）層去做資料的驗證外，其他的層級都不需要做任何的資料驗證！\n資料呈現（Presenter） 我們會將需要處理不同資料樣式的邏輯，使用 laracasts/presenter 去做實體（Entity）的分層處理，不要將有程式邏輯的功能出現在實體（Entity）中\nARCA 架構檔案結構 我會將 Model 的檔案結構依照 Domain 去區分，檔案結構大概會像這樣\n/app /KeJyunApp /User /Entities User.php UserPrivacy.php /Repositories UserRepository.php UserPrivacyRepository.php /Service UserAuthService.php UserPrivacyService.php /Form UserForm.php UserPrivacyForm.php /Presenter UserPresenter.php UserPrivacyPresenter.php /Post /Entities Post.php /Repositories /Service /Form /Presenter 這樣區分的好處是，類似功能的程式可以方便集中管理，當我們在撰寫某一功能的程式，我們可以很快地在同一個資料夾中找到這些檔案，若要找其他功能的程式時，也可以在同一個資料夾很快地去找到\n如果我們將程式檔案依照功能去放置，可能會像這樣\n/app /SomeApp /Entities User.php Post.php Tags.php News.php Event.php ... /Repositories /Service UserAuthService.php UserPrivacyService.php UserStatisticService.php PostManageService.php PostRankService.php PostStatisticService.php TagsService.php NewsService.php EventService.php ... /Form /Presenter 當專案還小，只有少數幾個模型資料需要管理時，還沒有什麼大的問題，但是當我們撰寫很多複雜功能時，這樣檔案管理的方式會是個很大的夢靨，像是服務（Service）與資源庫（Repository）的關係是「多 對 1」的關係，所以服務（Services）資料夾的檔案可能有 40~50 個以上，在我們要找相關的檔案時，就很考驗我們的眼力了（工程師的眼睛是很珍貴的，我們要好好的珍惜～）\n參考資料  在 Laravel 4 使用資源庫 (Repositories) 及服務 (Services) 去降低程式的耦合性 胖胖Model減重的五個方法 by howtomakeaturn PHP 也有 Day #16 - 胖胖 Model 減重的五個方法 by 尤川豪  "
},
{
	"uri": "https://kejyun.github.io/laravel5-book/database/qa/cannot-mass-insert-with-extend-model/",
	"title": "使用中繼模型繼承 Eloquent 模型造成無法使用大量資料新增",
	"tags": [],
	"description": "",
	"content": "使用中繼模型繼承（extends）Eloquent 模型造成無法使用大量資料新增（Mess Assignment） 大部份的情況可能專案較小，所以我們會直接使用模型（Model）去新增資料，但若專案較大時，且不同的模型之間有共用的方法的話，我會會希望這些模型繼承同一個 Eloquent 模型的中繼類別物件，就像這樣：\nEloquent 模型的中繼類別物件\nclass CustomBaseModel extends Model { public $someVariable = null; public function doSomething() { } } 使用者模型繼承「Eloquent 模型的中繼類別物件」\nclass User extends CustomBaseModel { protected $fillable = [\u0026#39;first_name\u0026#39;, \u0026#39;last_name\u0026#39;, \u0026#39;email\u0026#39;]; } 使用這樣的中繼類別時，如果我們只有設定變數或實作中繼模型類別方法時，我們可以運作的很正常，但是如果我們需要實作中繼類別的建構子__construct()時，我們必須要時做原本 Eloquent Model 類別的建構子，否鑿會無法正常的運作原有的 Eloquent 模型\n在 vendor/laravel/framework/src/Illuminate/Database/Eloquent/Model.php Eloquent 模型的檔案中，我們可以看到建構子__construct()有需要傳入資料表欄位的屬性值 $attributes。\n// vendor/laravel/framework/src/Illuminate/Database/Eloquent/Model.php abstract class Model implements ArrayAccess, Arrayable, Jsonable, JsonSerializable, QueueableEntity, UrlRoutable { public function __construct(array $attributes = array()) { $this-\u0026gt;bootIfNotBooted(); $this-\u0026gt;syncOriginal(); $this-\u0026gt;fill($attributes); } } 這個部分是用來做大量資料新增或異動時（Mass Assignment）需要用到的資料，所以如果我們在中繼類別沒有實作這個建構子__construct()，會讓我們的完整 Eloquent Model 出現問題\n所以在 Eloquent 中繼類別中我們必須要時作的建構子__construct()會長的像這樣：\nclass CustomBaseModel extends Model { public $someVariable = null; function __construct(array $attributes = array()) { parent::__construct($attributes); // 做中繼類別建構子想要做的事 $this-\u0026gt;someVariable = \u0026#39;5566\u0026#39;; } } 我們的中繼類別，需要傳入資料表欄位的屬性值 $attributes，並執行母類別 Eloquent Model 的建構子，這樣我們的 Eloquent 模型就能夠正常運作了！\n"
},
{
	"uri": "https://kejyun.github.io/laravel5-book/design-pattern/learning-resource/",
	"title": "學習資源",
	"tags": [],
	"description": "",
	"content": "學習資源 文章  框架不應該有「MODELS」資料夾  投影片  胖胖Model減重的五個方法 by howtomakeaturn  影片  PHP 也有 Day #16 - 胖胖 Model 減重的五個方法 by 尤川豪  Repository  recca0120/laravel-repository: Repository Design Pattern for Laravel 5 with Eloquent or Collection  "
},
{
	"uri": "https://kejyun.github.io/laravel5-book/database/qa/",
	"title": "資料庫常見問題",
	"tags": [],
	"description": "",
	"content": "資料庫常見問題 這裏會列出一些 Laravel 在處理資料庫會遇到的一些常見的問題\n"
},
{
	"uri": "https://kejyun.github.io/laravel5-book/database/postgresql/",
	"title": "PostgreSQL",
	"tags": [],
	"description": "",
	"content": "PostgreSQL 這裏會介紹如何在 Laravel 使用 PostgreSQL 資料庫\n"
},
{
	"uri": "https://kejyun.github.io/laravel5-book/database/redis/",
	"title": "Redis",
	"tags": [],
	"description": "",
	"content": "Redis 這裏會介紹如何在 Laravel 使用 Redis\n"
},
{
	"uri": "https://kejyun.github.io/laravel5-book/http/middleware/etag-middleware/",
	"title": "ETag Middleware",
	"tags": [],
	"description": "",
	"content": "ETag Middleware 在我們的網站若資料未變更，我們會希望告訴請求資源的使用者，本資源未修改(304 Not Modified)，所以不用重複讀取資料，這樣可以節省我們傳輸資料頻寬。\n我可以用 Middleware 來達到 ETag 的效果\n建立 ETag Middleware  App\\Http\\Middleware\\ETagMiddleware.php\n \u0026lt;?php namespace App\\Http\\Middleware; use Closure; class ETagMiddleware { /** * Implement Etag support * * @param \\Illuminate\\Http\\Request $request * @param \\Closure $next * @return mixed */ public function handle($request, Closure $next) { // Get response  $response = $next($request); // 如果是 get request  if ($request-\u0026gt;isMethod(\u0026#39;get\u0026#39;)) { // 產生回應內容的 etag  $etag = md5($response-\u0026gt;getContent()); $requestEtag = str_replace(\u0026#39;\u0026#34;\u0026#39;, \u0026#39;\u0026#39;, $request-\u0026gt;getETags()); // 檢查 etag 是否變更  if($requestEtag AND ($requestEtag[0] == $etag OR $requestEtag[0] == \u0026#39;W/\u0026#39;.$etag)) { // 若 etag 相同，設定表頭為資料未修改  $response-\u0026gt;setNotModified(); } // 設定 etag  $response-\u0026gt;setEtag($etag); } // 傳送回應  return $response; } } 設定 Etag Middleware  app/Http/Kernel.php\n \u0026lt;?php namespace App\\Http; use Illuminate\\Foundation\\Http\\Kernel as HttpKernel; class Kernel extends HttpKernel { protected $middlewareGroups = [ \u0026#39;web\u0026#39; =\u0026gt; [ \\App\\Http\\Middleware\\ETagMiddleware::class, ], ]; 這樣我們就完成 Etag Middleware 的設定了!\n參考資料  Setting Etags in Laravel 5 - Matthew Daly\u0026rsquo;s Blog  "
},
{
	"uri": "https://kejyun.github.io/laravel5-book/services/errors-logs/service/errors-log-service-rollbar/",
	"title": "Rollbar",
	"tags": [],
	"description": "",
	"content": "Rollbar 1. 安裝\ncomposer require rollbar/rollbar-laravel 2. 設定 config/app.php\n Laravel 5.5 以上不用做這個設定\n \u0026lt;?php // config/app.php return [ \u0026#39;providers\u0026#39; =\u0026gt; [ Rollbar\\Laravel\\RollbarServiceProvider::class, ], ]; 3. 設定 API KEY\n到 .env 檔案設定 API KEY，根據官方安裝引導可以取得此 API KEY\n# .env ROLLBAR_TOKEN=\u0026lt;API_KEY\u0026gt; 4. 發送錯誤訊息到 rollbar\ntry { throw new Exception(\u0026#39;Hello there is something wrong\u0026#39;); } catch (Exception $exception) { Log::debug($exception); Log::debug(\u0026#39;Hello my test\u0026#39;); } 5. 檢視 rollbar 錯誤訊息\n錯誤訊息 dashboard\n個別錯誤訊息\n參考資料  Error Tracking \u0026amp; Crash Reporting for Software Developers - Rollbar Rollbar Doc - Laravel  "
},
{
	"uri": "https://kejyun.github.io/laravel5-book/services/queue/queue-supervisor/",
	"title": "Supervisor 啟動 queue",
	"tags": [],
	"description": "",
	"content": "Supervisor 啟動 queue 安裝 Supervisor sudo apt-get install supervisor 設定檔案路徑 /etc/supervisor/conf.d 設定 vim /etc/supervisor/conf.d/laravel-worker.conf 設定檔案 [program:laravel-worker] process_name=%(program_name)s_%(process_num)02d command=php /home/forge/app.com/artisan artisan queue:work --queue=instant,high,medium,default,low --delay=1 --memory=512 --sleep=15 --tries=1 --env=dev --daemon autostart=true autorestart=true user=www-data numprocs=8 redirect_stderr=true stdout_logfile=/home/forge/app.com/worker.log 啟動 Supervisor sudo supervisorctl reread sudo supervisorctl update sudo supervisorctl start laravel-worker:* 停止 Supervisor sudo supervisorctl stop laravel-worker:* 重新啟動 Supervisor 若當 Laravel 設定檔有做異動時，需要重啟 Supervisor 以讀取新的設定\n# 重新啟動指定的 worker supervisorctl restart laravel-worker: # 重新啟動所有的 worker supervisorctl restart all 參考資料  Queues - Laravel - The PHP Framework For Web Artisans supervisord - how to restart only certain processes using supervisorctl? - Stack Overflow  "
},
{
	"uri": "https://kejyun.github.io/laravel5-book/services/unit-test/unit-test-login-and-upload-file/",
	"title": "單元測試登入及上傳檔案",
	"tags": [],
	"description": "",
	"content": "單元測試登入及上傳檔案 登入使用者 $User = User::find(12345); $this-\u0026gt;be($User); 上傳檔案 // 設定上傳檔案 $post_file = new UploadedFile($path, $name, filesize($path), \u0026#39;image/png\u0026#39;, null, true); // 呼叫上傳網址 $response = $this-\u0026gt;call(\u0026#39;POST\u0026#39;, \u0026#39;/photo/store\u0026#39;, [], [], $post_file); // 取得回傳內容 $content = json_decode($response-\u0026gt;getContent()); dump($content); 參考資料  php - How to test file upload in Laravel 5.2 - Stack Overflow How to mock authentication user on unit test in Laravel?  "
},
{
	"uri": "https://kejyun.github.io/laravel5-book/services/errors-logs/packages/",
	"title": "日誌套件",
	"tags": [],
	"description": "",
	"content": "這裏介紹 Laravel 提供的日誌套件功能\n參考資料  cr0wst/laravel-slack-log: Utilizes Laravel\u0026rsquo;s notifications to provide logging to slack at various levels. Inspired by Log4j. laravel - Send a slack notification every time Log::error is triggered - Stack Overflow laravel - Send a slack notification every time Log::error is triggered - Stack Overflow  "
},
{
	"uri": "https://kejyun.github.io/laravel5-book/services/helpers/",
	"title": "輔助方法 (Helpers)",
	"tags": [],
	"description": "",
	"content": "這裏介紹 Laravel 提供的輔助方法 (Helpers)功能\n"
},
{
	"uri": "https://kejyun.github.io/laravel5-book/database/model/eloquent-apply/",
	"title": "使用 Eloquent",
	"tags": [],
	"description": "",
	"content": "使用 Eloquent 新增資料 大量指定新增資料 // 新增 \\App\\User::Create([ \u0026#39;first_name\u0026#39;=\u0026gt; \u0026#39;KeJyun\u0026#39;, \u0026#39;last_name\u0026#39; =\u0026gt; \u0026#39;Hong\u0026#39;, \u0026#39;email\u0026#39; =\u0026gt; \u0026#39;kejyun@gmail.com\u0026#39;, ]); 填入要新增的資料 // 使用者的資料 $user_data = [ \u0026#39;first_name\u0026#39;=\u0026gt; \u0026#39;KeJyun\u0026#39;, \u0026#39;last_name\u0026#39; =\u0026gt; \u0026#39;Hong\u0026#39;, \u0026#39;email\u0026#39; =\u0026gt; \u0026#39;kejyun@gmail.com\u0026#39;, ]; $user = new \\App\\User; // 填入要新增的資料 $user-\u0026gt;fill($user_info); // 儲存資料 $user-\u0026gt;save(); "
},
{
	"uri": "https://kejyun.github.io/laravel5-book/view/",
	"title": "視圖 (View)",
	"tags": [],
	"description": "",
	"content": "這裏會介紹如何在 Laravel 5 處理視圖 (View)。\n"
},
{
	"uri": "https://kejyun.github.io/laravel5-book/environment/debug/",
	"title": "除錯",
	"tags": [],
	"description": "",
	"content": "環境除錯 Laravel 5 : Parse error: syntax error, unexpected \u0026lsquo;?\u0026rsquo;, expecting variable (T_VARIABLE) 當安裝 Laravel 5.5 時，出現 Parse error: syntax error, unexpected '?', expecting variable (T_VARIABLE) 的訊息\n You need to install PHP version 7.1 because nullable types were introduced in 7.1:\n ?string $value 要解決這個問題只需要使用 php \u0026gt; 7.1.3 版本即可\n參考資料  php - Laravel 5 : Parse error: syntax error, unexpected \u0026lsquo;?\u0026rsquo;, expecting variable (T_VARIABLE) - Stack Overflow  "
},
{
	"uri": "https://kejyun.github.io/laravel5-book/services/errors-logs/service/errors-log-service-cloudwatch/",
	"title": "CloudWatch Log",
	"tags": [],
	"description": "",
	"content": "CloudWatch Log 參考資料  Using AWS CloudWatch for Laravel Logs on Forge – James Fairhurst – Medium jamesfairhurst/laravel-cloudwatch-logs-lambda-slack: Use AWS CloudWatch Logs \u0026amp; Lambda to post Laravel Log messages to Slack maxbanton/cwh: Amazon Web Services CloudWatch Logs Handler for Monolog library  "
},
{
	"uri": "https://kejyun.github.io/laravel5-book/services/unit-test/",
	"title": "單元測試",
	"tags": [],
	"description": "",
	"content": "這裏介紹 Laravel 提供的單元測試功能\n"
},
{
	"uri": "https://kejyun.github.io/laravel5-book/services/errors-logs/service/",
	"title": "日誌服務",
	"tags": [],
	"description": "",
	"content": "這裏介紹 Laravel 提供的日誌服務功能\n參考資料  Understand.io - Online Event and Log Management understand/understand-laravel5 Sentry | Error Tracking Software — JavaScript, Python, PHP, Ruby, more Error reporting, monitoring, and resolution with Bugsnag Error Tracking \u0026amp; Crash Reporting for Software Developers - Rollbar  "
},
{
	"uri": "https://kejyun.github.io/laravel5-book/services/unit-test/unit-test-change-root-url/",
	"title": "變更請求網址",
	"tags": [],
	"description": "",
	"content": "Unit test 變更請求網址(Root Url) 在單元測試(Unit test)的時候，測試網址預設會抓取 .env 檔案的 APP_URL，但若同個專案有不同的網址時，則需要再寫測試時變更為特定的網址\n可以在 setUp() 函式使用 \\URL::forceRootUrl() 強制轉換網址，這樣就可以使用指定的網址進行測試了\n\u0026lt;?php class TestCase { function setUp(): void { parent::setUp(); $app_url= \u0026#34;http://kejyun.com\u0026#34;; \\URL::forceRootUrl($app_url); } } "
},
{
	"uri": "https://kejyun.github.io/laravel5-book/services/",
	"title": "服務",
	"tags": [],
	"description": "",
	"content": "這裏介紹一些 Laravel 提供的一些服務\n"
},
{
	"uri": "https://kejyun.github.io/laravel5-book/database/model/eloquent-lock/",
	"title": "鎖定資料 Lock",
	"tags": [],
	"description": "",
	"content": "鎖定資料 Lock 鎖定資料有 shared lock (sharedLock) 與 lock for update (lockForUpdate)，兩者都可以避面同一行資料被其他的 transaction update\n在 Laravel 鎖定資料庫資料 範例 sharedLock DB::table(\u0026#39;users\u0026#39;) -\u0026gt;where(\u0026#39;votes\u0026#39;, \u0026#39;\u0026gt;\u0026#39;, 100) -\u0026gt;sharedLock() -\u0026gt;get(); select * from `users` where `votes` \u0026gt; \u0026#39;100\u0026#39; lock in share mode DB::table(\u0026#39;tasks\u0026#39;) -\u0026gt;select(\u0026#39;details\u0026#39;, \u0026#39;created_at\u0026#39;) -\u0026gt;whereDate(\u0026#39;created_at\u0026#39;, \u0026#39;=\u0026#39;, \u0026#39;2011-11-11\u0026#39;) -\u0026gt;sharedLock() -\u0026gt;get(); select `details`, `created_at` from `tasks` where date(`created_at`) = \u0026#39;2011-11-11\u0026#39; lock in share mode 可以使用 -\u0026gt;sharedLock() 或 -\u0026gt;lock(false) 去做 sharedLock\nlockForUpdate DB::table(\u0026#39;users\u0026#39;)-\u0026gt;where(\u0026#39;votes\u0026#39;, \u0026#39;\u0026gt;\u0026#39;, 100)-\u0026gt;lockForUpdate()-\u0026gt;get(); select * from `users` where `votes` \u0026gt; \u0026#39;100\u0026#39; for update DB::table(\u0026#39;tasks\u0026#39;) -\u0026gt;select(\u0026#39;details\u0026#39;, \u0026#39;created_at\u0026#39;) -\u0026gt;whereDate(\u0026#39;created_at\u0026#39;, \u0026#39;\u0026gt;\u0026#39;, \u0026#39;2016-11-24\u0026#39;) -\u0026gt;lockForUpdate() -\u0026gt;get(); select `details`, `created_at` from `tasks` where date(`created_at`) = \u0026#39;2016-11-24\u0026#39; for update 可以使用 -\u0026gt;lockForUpdate() 或 -\u0026gt;lock(true) 去做 lockForUpdate\n不同的地方 定義  sharedLock locks only for write, lockForUpdate also prevents them from being selected\n shared lock (sharedLock) 與 lock for update (lockForUpdate) 兩者都是鎖定類型的 transaction，但這兩個鎖定類型的 transaction 不會避免非鎖定的 transaction 去讀取到資料。\nsharedLock 其他的 Session 可以 Select，但無法 Update 資料\n如果 Session_1 使用 sharedLock 去讀取資料並對資料進行修改，而 Session_2 也使用 sharedLock 去讀取資料並對資料進行修改，則 Session_2 會等到 Session_1 commit 之後，才能對資料進行 update，若 Session_1 與 Session_2 都有修改到同樣欄位資料，則會變成最後修改的 Session_2 的資料。\n使用情境\n有 parent 及 child 兩個資料表，而兩者資料是有關聯性的，當要新增資料至 child 資料表時，必須確保 parent 資料表有資料，才不會讓 child 找不到他的 parent，此時可以使用 sharedLock 去避免資料被異動（刪除、更新）\nSELECT * FROM parent WHERE NAME = \u0026#39;Jones\u0026#39; FOR SHARE; lockForUpdate 可以避免被其他鎖定型 transaction 進行 Select\n當需要對同一欄位確保資料 update 是正確的，如計數器，則必須使用 lockForUpdate 來鎖定資料\n當 parent 內有一個計數器欄位紀錄總共有多少 child，則為了數字正確更新，必須避免其他鎖定型的 transaction 進行資料異動\nSELECT counter_field FROM child_codes FOR UPDATE; UPDATE child_codes SET counter_field = counter_field + 1; 參考資料  Database: Query Builder - Laravel - The PHP Framework For Web Artisans Laravel 5: Query Builder Helpers – locks – Jeff\u0026rsquo;s Reference Pessimistic Locking in Laravel 5 使用 Laravel sharedLock 与 lockForUpdate 进行数据表行锁 - Laravel - 大象笔记 MySQL :: MySQL 8.0 Reference Manual :: 15.5.2.4 Locking Reads transactions - MySQL InnoDB: Difference Between FOR UPDATE and LOCK IN SHARE MODE - Stack Overflow MySQL InnoDB Transaction – 交易指南 (SELECT … FOR UPDATE) – YIDAS Code Pessimistic vs Optimistic Locking in Laravel – Ali AslRousta – Medium  "
},
{
	"uri": "https://kejyun.github.io/laravel5-book/services/errors-logs/",
	"title": "錯誤與日誌 Log",
	"tags": [],
	"description": "",
	"content": "這裏介紹 Laravel 提供的錯誤與日誌 Log 功能\n"
},
{
	"uri": "https://kejyun.github.io/laravel5-book/api/",
	"title": "API",
	"tags": [],
	"description": "",
	"content": "這裏介紹一些 Laravel 提供的 API 功能\n"
},
{
	"uri": "https://kejyun.github.io/laravel5-book/database/model/eloquent-tips/",
	"title": "Eloquent 小技巧",
	"tags": [],
	"description": "",
	"content": "Eloquent 小技巧 取得主鍵名稱 - getKeyName() User Eloquent 物件\n\u0026lt;?php use Illuminate\\Database\\Eloquent\\Model; class User extends Model { protected $table = \u0026#39;user\u0026#39;; protected $primaryKey = \u0026#39;user_id\u0026#39;; } 取得主鍵名稱\n\u0026lt;?php $User = new User; $primary_key_name = $User-\u0026gt;getKeyName(); // user_id "
},
{
	"uri": "https://kejyun.github.io/laravel5-book/design-pattern/",
	"title": "設計模式",
	"tags": [],
	"description": "",
	"content": "這裏介紹一些 Laravel 的設計模式\n"
},
{
	"uri": "https://kejyun.github.io/laravel5-book/services/encryption/encryption-intro/",
	"title": "加密（encryption）",
	"tags": [],
	"description": "",
	"content": "加密（encryption） 使用情境 我們若需要在資料庫儲存一些敏感資料（像是信用卡的資料），但我們又為了避免資料庫遭到入侵，而導致所有使用者相關的敏感資料全都被竊取，我們可以使用 Laravel 提供的「加密與解密」演算法，將我們的敏感資料加密儲存到資料庫，待我們讀取資料的時候，再將其資料解密出來處理。\n設定 在 Laravel 做「加密與解密」演算法時，會使用 config/app.php 中的 key 值去當作加解密的 salt，自己的應用需要設定自己的 key 值，若沒有設定的話被加密過的值還是有可能被暴力破解出來，所以要記得去設定，而這個 key 值若變更了，雜湊的驗證也不會相同喔～\n使用 // 加密 $original_data = \u0026#39;需要加密的資料\u0026#39;; $encrypt_data = Crypt::encrypt($original_data); // 解密 $decrypted = Crypt::decrypt($encrypt_data); 備註 重複加密相同的資料得到的密文不會一樣，所以不要使用像 md5 的方式去比對密文資料是否相同\n使用 md5 比較密文 $original_data = \u0026#39;需要加密的資料\u0026#39;; // 第 1 次使用 md5 加密的資料 $first_md5_hash_data = md5($original_data); // 第 2 次使用 md5 加密的資料 $second_md5_hash_data = md5($original_data); // 資料相同 // true var_dump($first_md5_hash_data === $second_md5_hash_data); 使用加密演算法比較密文 $original_data = \u0026#39;需要加密的資料\u0026#39;; // 第 1 次使用加密演算法加密的資料 $first_encrypt_data = Crypt::encrypt($original_data); // 第 2 次使用加密演算法加密的資料 $second_encrypt_data = Crypt::encrypt($original_data); // 資料不相同 // false var_dump($first_encrypt_data === $second_encrypt_data); 參考資料  加密 - Laravel.tw  "
},
{
	"uri": "https://kejyun.github.io/laravel5-book/database/model/eloquent-sub-query/",
	"title": "子查詢",
	"tags": [],
	"description": "",
	"content": "子查詢 當我想要計算子查詢的數量時，會想要執行像下方的 SQL 查詢語法\nSELECT count(*) FROM ( SELECT UID FROM `posts` WHERE `status` = 1 GROUP BY `user_id` ) sub 在 Eloquent 可以用下面方式達到子查詢的目的\n\u0026lt;?php // Eloquent Builder instance $SubQuery = Posts::where(\u0026#39;status\u0026#39;, 1) -\u0026gt;groupBy(\u0026#39;user_id\u0026#39;); $count = DB::table( DB::raw(\u0026#34;({$SubQuery-\u0026gt;toSql()}) as sub\u0026#34;) ) -\u0026gt;mergeBindings($SubQuery-\u0026gt;getQuery()) -\u0026gt;count(); 記得當你的子查詢結束後，若有更多的條件需要執行，則必須將查詢條件放在 mergeBindings() 方法後方，否則原本 SubQuery 的查詢資料順序會綁定錯誤\n$count = DB::table( DB::raw(\u0026#34;({$SubQuery-\u0026gt;toSql()}) as sub\u0026#34;) ) // -\u0026gt;where(..) 這裡會出錯 -\u0026gt;mergeBindings($SubQuery-\u0026gt;getQuery()) // -\u0026gt;where(..) 正確 -\u0026gt;count(); Laravel v5.6.12 (2018-03-14) 之後，加入了 fromSub() 及 fromRaw() 的方法可以直接產生子查詢語法\n\u0026lt;?php DB::query()-\u0026gt;fromSub(function ($query) { $query-\u0026gt;from(\u0026#39;posts\u0026#39;) -\u0026gt;where(\u0026#39;status\u0026#39;, 1) -\u0026gt;groupBy(\u0026#39;user_id\u0026#39;); }, \u0026#39;sub\u0026#39;)-\u0026gt;count(); // select count(*) as aggregate from (select * from `abc` group by `col1`) as `a` 參考資料  sql - How to select from subquery using Laravel Query Builder? - Stack Overflow  "
},
{
	"uri": "https://kejyun.github.io/laravel5-book/structure/",
	"title": "程式架構規範",
	"tags": [],
	"description": "",
	"content": "這裏介紹一些 Laravel 的程式架構規範\n"
},
{
	"uri": "https://kejyun.github.io/laravel5-book/services/hashing/hashing-intro/",
	"title": "雜湊（Hashing）",
	"tags": [],
	"description": "",
	"content": "雜湊（Hashing） 使用情境 使用者輸入的密碼，通常我們將其加密再存到資料庫中，但這類的資料我們通常不需要反解回來處理，所以我們不需要使用加密的演算法去加密資料\n因為加密演算法需要完整的解回原先的資料，所以若資料越長密文也會越長，但雜湊不需要解回原先的資料，只需要驗證原先的資料，經過再雜湊的檢查是相同的就好（輸入的密碼雜湊驗證與原先存在資料庫的雜湊資料相同），所以雜湊的資料可以有固定的長度，像是 md5 的雜湊資料長度固定為 32，而 Laravel 提供的 Hash 雜湊演算法，資料長度固定為 60。\n設定 在 Laravel 做「雜湊」演算法時，會使用 config/app.php 中的 key 值去當作雜湊的 salt，自己的應用需要設定自己的 key 值，若沒有設定的話被加密過的值還是有可能被暴力破解出來，所以要記得去設定，而這個 key 值若變更了，雜湊的驗證也不會相同喔～\n使用 雜湊 // 雜湊 $original_password = \u0026#39;密碼明碼\u0026#39;; $hash_password = Hash::make($original_password); 驗證 // 雜湊 $original_password = \u0026#39;密碼明碼\u0026#39;; $hash_password = Hash::make($original_password); // 驗證 $check_result = Hash::check($original_password, $hash_password); // true var_dump($check_result); 備註 重複雜湊相同的資料得到的密文不會一樣，所以不要使用像 md5 的方式去比對密文資料是否相同\n使用 md5 比較密文 $original_password = \u0026#39;密碼明碼\u0026#39;; // 第 1 次使用 md5 加密的資料 $first_md5_hash_password = md5($original_password); // 第 2 次使用 md5 加密的資料 $second_md5_hash_password = md5($original_password); // 資料相同 // true var_dump($first_md5_encrypt_password === $second_md5_encrypt_password); 雖然每次雜湊的結果都不一樣，但你可以放心的將任何一次雜湊的資料存放到資料庫中，因為雖然密文不同，但 Laravel 的雜湊演算法，還是可以比對出來是不是由相同的資料去做雜湊的\n使用雜湊演算法比較資料是否相同 $original_password = \u0026#39;密碼明碼\u0026#39;; // 第 1 次使用雜湊演算法雜湊的資料 $first_hash_password = Hash::make($original_password); // 第 2 次使用雜湊演算法雜湊的資料 $second_hash_password = Hash::make($original_password); // 資料不相同 // false var_dump($first_encrypt_password === $second_encrypt_password); // 驗證雜湊資料 true $first_check_result = Hash::check($original_password, $first_hash_password); $second_check_result = Hash::check($original_password, $second_hash_password); 參考資料  雜湊 - Laravel.tw  "
},
{
	"uri": "https://kejyun.github.io/laravel5-book/services/response/response-intro/",
	"title": "回應（Response）",
	"tags": [],
	"description": "",
	"content": "回應（Response） 強制回應 JSON 建立 Middleware\nnamespace App\\Http\\Middleware; use Closure; class ForceJsonMiddleware { /** * Handle an incoming request. * * @param \\Illuminate\\Http\\Request $request * @param \\Closure $next * @return mixed */ public function handle($request, Closure $next) { $request-\u0026gt;headers-\u0026gt;set(\u0026#39;accept\u0026#39;, \u0026#39;application/json\u0026#39;); return $next($request); } } 在 Kernel.php 加入此 Middleware\n\u0026#39;force-json-response\u0026#39; =\u0026gt; \\App\\Http\\Middleware\\ForceJsonMiddleware::class, 設定使用 Middleware\nRoute::group([\u0026#39;middleware\u0026#39; =\u0026gt; [\u0026#39;force-json-response\u0026#39;, \u0026#39;auth:api\u0026#39;]], function () { }); 參考資料  Laravel 响应：永远返回 JSON 响应 | Laravel China 社区  "
},
{
	"uri": "https://kejyun.github.io/laravel5-book/services/scheduling/scheduling-intro/",
	"title": "任務排程（Scheduling）",
	"tags": [],
	"description": "",
	"content": "任務排程（Scheduling） 我們通常會把一些每小時、每 6 小時、每日、每週、每月等等之類固定時間要做的工作丟到 Linux 系統的 crontab 中去執行，通常像是每日要統計昨天網站的活動資訊做數據分析之類的工作，這類的工作通常會花費比較久的時間\n在 Linux 設定排程工作 我們通常會在命令列用 $ crontab -e 的方式去編輯排程工作\n$ crontab -e 在用到 crontab 的時候，我們需要瞭解怎麼設定排程工作的執行時間，整個的 crontab 的設定可能會像這樣：\n# 每天凌晨 3 點統計昨天的 Pageview 0 3 * * * /usr/bin/php /home/kejyun/laravel4/artisan cronjob:statisticYesterdayPageview 在前方可以看到有 5 個數字可以做設定，依序分別代表的意思為：\n 分鐘 (0-59) 小時 (0-23) 每個月第幾天 (1-31) 月份 (1-12) 每週的第幾天 (0-6) 0：星期日 1：星期一 2：星期二 3：星期三 4：星期四 5：星期五 6：星期六  這 5 個參數之間用空白隔開，每個參數除了設定單一個數字，也可以用逗號(,)去隔開設定相同單位的時間設定，像是：\n# 每天凌晨 4 點及 16 點寄送廣告信 0 4,16 * * * /usr/bin/php /home/kejyun/laravel4/artisan cronjob:sendCommercialMail 這裏有一些相關的設定範例可以當作參考：\n# 每小時的第 18 分鐘執行 18 * * * * # 8 點 10 分執行 10 8 * * * # 8 點的每分鐘執行一次（共執行 60 次） * 8 * * * # 在每個禮拜二每小時的第 18 分鐘執行 18 * * * 2 # 你也可以每隔一段時間去執行 crontab # 如果我們每 15 分鐘要去執行，你可以用這樣的格式 */15 # 這樣的意思是將分鐘數，切割成（除以）每 15 分鐘執行 */15 * * * * # 每 2 小時執行 0 */2 * * * # 每 2 小時又 20 分鐘執行 */20 */2 * * * 小提醒\n 系統的 crontab 運作方式是每分鐘會到設定的 crontab 找看看有沒有符合現在這個時間的排程工作，所以像是 * 8 * * * 這樣的設定，因為沒有明確指定分鐘，在 8 點每分鐘檢查的 60 次都符合條件，所以會執行 60 次，若僅要 8 點時執行一次，請明確設定要執行的分鐘條件，像是 0 8 * * *\n 使用 Laravel 5.2 Scheduling 設定排程工作 因為 Linux 每分鐘都會去檢查當時是否有排程需要執行的工作，符合條件的時間就會執行，Laravel 利用這個特性，告訴排程每分鐘都要執行 Laravel 的 schedule:run 的指令\n* * * * * php /path/to/artisan schedule:run \u0026gt;\u0026gt; /dev/null 2\u0026gt;\u0026amp;1 之後 Laravel 每分鐘就會執行 app/Console/Command/Kernal@schedule 的程式，Laravel 會依照 schedule 裡面的設定時間，執行符合條件的排程工作\n排程範例 假如我們有一個排程每分鐘都會紀錄他執行的時間，程式碼會放在 app/Console/Command/TestLog.php，程式碼會像是：\n\u0026lt;?php namespace App\\Console\\Commands; use Illuminate\\Console\\Command; use File; class TestLog extends Command { // 命令名稱  protected $signature = \u0026#39;test:Log\u0026#39;; // 說明文字  protected $description = \u0026#39;[測試] Log 檔案\u0026#39;; public function __construct() { parent::__construct(); } // Console 執行的程式  public function handle() { // 檔案紀錄在 storage/test.log  $log_file_path = storage_path(\u0026#39;test.log\u0026#39;); // 記錄當時的時間  $log_info = [ \u0026#39;date\u0026#39;=\u0026gt;date(\u0026#39;Y-m-d H:i:s\u0026#39;) ]; // 記錄 JSON 字串  $log_info_json = json_encode($log_info) . \u0026#34;\\r\\n\u0026#34;; // 記錄 Log  File::append($log_file_path, $log_info_json); } } 以上排程的命令是 php artisan test:Log，執行之後就會記錄當時執行的時間\n排程程式建立好之後，在 app/Console/Command/Kernal.php 定義此排程的工作，並設定每分鐘執行一次，程式碼會像是：\n\u0026lt;?php namespace App\\Console; use Illuminate\\Console\\Scheduling\\Schedule; use Illuminate\\Foundation\\Console\\Kernel as ConsoleKernel; class Kernel extends ConsoleKernel { // 定義應用程式的 Artisan 指令  protected $commands = [ \\App\\Console\\Commands\\TestLog::class, ]; // 定義應用程式的排程  protected function schedule(Schedule $schedule) { // 每分鐘執行 Artisan 命令 test:Log  $schedule-\u0026gt;command(\u0026#39;test:Log\u0026#39;)-\u0026gt;everyMinute(); } } 這樣你就可以在 storage/test.log 每分鐘看到像這樣的紀錄，這樣就表示你的排程設定成功了！！\n{\u0026quot;date\u0026quot;:\u0026quot;2016-01-11 22:12:05\u0026quot;} {\u0026quot;date\u0026quot;:\u0026quot;2016-01-11 22:13:05\u0026quot;} {\u0026quot;date\u0026quot;:\u0026quot;2016-01-11 22:14:05\u0026quot;} {\u0026quot;date\u0026quot;:\u0026quot;2016-01-11 22:15:05\u0026quot;} {\u0026quot;date\u0026quot;:\u0026quot;2016-01-11 22:16:05\u0026quot;} {\u0026quot;date\u0026quot;:\u0026quot;2016-01-11 22:17:07\u0026quot;} {\u0026quot;date\u0026quot;:\u0026quot;2016-01-11 22:18:09\u0026quot;} {\u0026quot;date\u0026quot;:\u0026quot;2016-01-11 22:19:05\u0026quot;} 你也可以使用其他 Laravel 提供的時間方法去定義要執行的時間\n   方法 說明     -\u0026gt;cron('* * * * * *'); 自訂 Cron 排成時間   -\u0026gt;everyMinute(); 每分鐘執行   -\u0026gt;everyFiveMinutes(); 每 5 分鐘執行   -\u0026gt;everyTenMinutes(); 每 10 分鐘執行   -\u0026gt;everyThirtyMinutes(); 每 30 分鐘執行   -\u0026gt;hourly(); 每小時執行   -\u0026gt;daily(); 每天執行   -\u0026gt;dailyAt(\u0026lsquo;13:00\u0026rsquo;); 每天 13:00 執行   -\u0026gt;twiceDaily(1, 13); 每天 1:00 及 13:00 執行   -\u0026gt;weekly(); 每週執行   -\u0026gt;monthly(); 每月執行   -\u0026gt;yearly(); 每年執行   -\u0026gt;sundays() 每週日執行   -\u0026gt;mondays() 每週一執行   -\u0026gt;tuesdays() 每週二執行   -\u0026gt;wednesdays() 每週三執行   -\u0026gt;thursdays() 每週四執行   -\u0026gt;fridays() 每週五執行   -\u0026gt;saturdays() 每週六執行   -\u0026gt;when(Closure) 每當符合條件就執行（return true）    避免重複執行排程 排程預設每次符合條件就要執行，但若我們執行一個需要跑很久的程式，在下一次符合條件的時間若上一個同樣的工作還沒有執行完，我們就不執行的話，我們可以用 -\u0026gt;withoutOverlapping() 方法去避免排程程式重複執行，像是\n$schedule-\u0026gt;command(\u0026#39;emails:send\u0026#39;)-\u0026gt;withoutOverlapping(); 輸出執行結果 我們的在執行 Artisan 指令時，我們通常會在畫面上列印一些執行狀態，像是 $this-\u0026gt;info('把我顯示在畫面上');，如果我們想要知道排程執行時，這些顯示在畫面的文字記錄下來，我們可以用\n   方法 說明     -\u0026gt;sendOutputTo($filePath); 將結果輸出到檔案（複寫該檔案）   -\u0026gt;appendOutputTo($filePath); 將結果附加在檔案後面（不複寫檔案）   -\u0026gt;emailOutputTo('foo@example.com'); 將結果寄送到指定 Email    *** 將結果輸出到檔案（複寫該檔案） ***\n$schedule-\u0026gt;command(\u0026#39;emails:send\u0026#39;) -\u0026gt;daily() -\u0026gt;sendOutputTo($filePath); *** 將結果附加在檔案後面（不複寫檔案） ***\n$schedule-\u0026gt;command(\u0026#39;emails:send\u0026#39;) -\u0026gt;daily() -\u0026gt;appendOutputTo($filePath); *** 將結果寄送到指定 Email ***\n$schedule-\u0026gt;command(\u0026#39;foo\u0026#39;) -\u0026gt;daily() -\u0026gt;sendOutputTo($filePath) -\u0026gt;emailOutputTo(\u0026#39;foo@example.com\u0026#39;); 排程觸發 我們可以在排程執行前後，分別使用 -\u0026gt;before() 或 -\u0026gt;after() 去執行排程其他的工作\n$schedule-\u0026gt;command(\u0026#39;emails:send\u0026#39;) -\u0026gt;daily() -\u0026gt;before(function () { // 在排程執行前觸發 }) -\u0026gt;after(function () { // 在排程執行完成後觸發 }); 參考資料  crontab.guru - the cron schedule expression editor A visual crontab editor Task Scheduling - Laravel 5.2  "
},
{
	"uri": "https://kejyun.github.io/laravel5-book/services/laravel-mix/",
	"title": "Laravel Mix",
	"tags": [],
	"description": "",
	"content": "這裏介紹 Laravel 提供的 Laravel Mix 功能\n"
},
{
	"uri": "https://kejyun.github.io/laravel5-book/services/compass/compass-intro/",
	"title": "Compass",
	"tags": [],
	"description": "",
	"content": "Compass 安裝 RVM 1. 安裝 GPG keys\n$ gpg --keyserver hkp://keys.gnupg.net --recv-keys 409B6B1796C275462A1703113804BB82D39DC0E3 7D2BAF1CF37B13E2069D6956105BD0E739499BDB 2. 安裝 RVM\n\\curl -sSL https://get.rvm.io | bash 使用 RVM 安裝 Ruby 列出所有可以安裝的版本\nrvm list known 安裝指定版本\nrvm install 2.3.1  必須使用管理者權限安裝過以下套件：\n  autoconf, automake, bison, libffi-dev, libgdbm-dev, libncurses5-dev, libsqlite3-dev, libtool, libyaml-dev, pkg-config, sqlite3, zlib1g-dev, libgmp-dev, libreadline6-dev\n 安裝 Compass gem update --system gem install compass 監控 Compass gulp watch 參考資料  RVM: Ruby Version Manager - Installing RVM Install the Compass Stylesheet Authoring Framework | Compass Documentation creationix/nvm: Node Version Manager - Simple bash script to manage multiple active node.js versions  "
},
{
	"uri": "https://kejyun.github.io/laravel5-book/",
	"title": "首頁",
	"tags": [],
	"description": "",
	"content": "Laravel 學習筆記 "
},
{
	"uri": "https://kejyun.github.io/laravel5-book/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://kejyun.github.io/laravel5-book/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]